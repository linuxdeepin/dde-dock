<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="Gio" version="2.0"/>
  <package name="libnm"/>
  <namespace name="NM"
             version="1.0"
             shared-library="libnm.so.0"
             c:identifier-prefixes="NM"
             c:symbol-prefixes="nm">
    <bitfield name="80211ApFlags"
              glib:type-name="NM80211ApFlags"
              glib:get-type="nm_802_11_ap_flags_get_type"
              c:type="NM80211ApFlags">
      <doc xml:space="preserve">802.11 access point flags.</doc>
      <member name="none"
              value="0"
              c:identifier="NM_802_11_AP_FLAGS_NONE"
              glib:nick="none">
        <doc xml:space="preserve">access point has no special capabilities</doc>
      </member>
      <member name="privacy"
              value="1"
              c:identifier="NM_802_11_AP_FLAGS_PRIVACY"
              glib:nick="privacy">
        <doc xml:space="preserve">access point requires authentication and
encryption (usually means WEP)</doc>
      </member>
    </bitfield>
    <bitfield name="80211ApSecurityFlags"
              glib:type-name="NM80211ApSecurityFlags"
              glib:get-type="nm_802_11_ap_security_flags_get_type"
              c:type="NM80211ApSecurityFlags">
      <doc xml:space="preserve">802.11 access point security and authentication flags.  These flags describe
the current security requirements of an access point as determined from the
access point's beacon.</doc>
      <member name="none"
              value="0"
              c:identifier="NM_802_11_AP_SEC_NONE"
              glib:nick="none">
        <doc xml:space="preserve">the access point has no special security requirements</doc>
      </member>
      <member name="pair_wep40"
              value="1"
              c:identifier="NM_802_11_AP_SEC_PAIR_WEP40"
              glib:nick="pair-wep40">
        <doc xml:space="preserve">40/64-bit WEP is supported for
pairwise/unicast encryption</doc>
      </member>
      <member name="pair_wep104"
              value="2"
              c:identifier="NM_802_11_AP_SEC_PAIR_WEP104"
              glib:nick="pair-wep104">
        <doc xml:space="preserve">104/128-bit WEP is supported for
pairwise/unicast encryption</doc>
      </member>
      <member name="pair_tkip"
              value="4"
              c:identifier="NM_802_11_AP_SEC_PAIR_TKIP"
              glib:nick="pair-tkip">
        <doc xml:space="preserve">TKIP is supported for pairwise/unicast encryption</doc>
      </member>
      <member name="pair_ccmp"
              value="8"
              c:identifier="NM_802_11_AP_SEC_PAIR_CCMP"
              glib:nick="pair-ccmp">
        <doc xml:space="preserve">AES/CCMP is supported for pairwise/unicast encryption</doc>
      </member>
      <member name="group_wep40"
              value="16"
              c:identifier="NM_802_11_AP_SEC_GROUP_WEP40"
              glib:nick="group-wep40">
        <doc xml:space="preserve">40/64-bit WEP is supported for group/broadcast
encryption</doc>
      </member>
      <member name="group_wep104"
              value="32"
              c:identifier="NM_802_11_AP_SEC_GROUP_WEP104"
              glib:nick="group-wep104">
        <doc xml:space="preserve">104/128-bit WEP is supported for
group/broadcast encryption</doc>
      </member>
      <member name="group_tkip"
              value="64"
              c:identifier="NM_802_11_AP_SEC_GROUP_TKIP"
              glib:nick="group-tkip">
        <doc xml:space="preserve">TKIP is supported for group/broadcast encryption</doc>
      </member>
      <member name="group_ccmp"
              value="128"
              c:identifier="NM_802_11_AP_SEC_GROUP_CCMP"
              glib:nick="group-ccmp">
        <doc xml:space="preserve">AES/CCMP is supported for group/broadcast
encryption</doc>
      </member>
      <member name="key_mgmt_psk"
              value="256"
              c:identifier="NM_802_11_AP_SEC_KEY_MGMT_PSK"
              glib:nick="key-mgmt-psk">
        <doc xml:space="preserve">WPA/RSN Pre-Shared Key encryption is
supported</doc>
      </member>
      <member name="key_mgmt_802_1x"
              value="512"
              c:identifier="NM_802_11_AP_SEC_KEY_MGMT_802_1X"
              glib:nick="key-mgmt-802-1x">
        <doc xml:space="preserve">802.1x authentication and key management
is supported</doc>
      </member>
    </bitfield>
    <enumeration name="80211Mode"
                 glib:type-name="NM80211Mode"
                 glib:get-type="nm_802_11_mode_get_type"
                 c:type="NM80211Mode">
      <doc xml:space="preserve">Indicates the 802.11 mode an access point or device is currently in.</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_802_11_MODE_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">the device or access point mode is unknown</doc>
      </member>
      <member name="adhoc"
              value="1"
              c:identifier="NM_802_11_MODE_ADHOC"
              glib:nick="adhoc">
        <doc xml:space="preserve">for both devices and access point objects, indicates
  the object is part of an Ad-Hoc 802.11 network without a central
  coordinating access point.</doc>
      </member>
      <member name="infra"
              value="2"
              c:identifier="NM_802_11_MODE_INFRA"
              glib:nick="infra">
        <doc xml:space="preserve">the device or access point is in infrastructure mode.
  For devices, this indicates the device is an 802.11 client/station.  For
  access point objects, this indicates the object is an access point that
  provides connectivity to clients.</doc>
      </member>
      <member name="ap"
              value="3"
              c:identifier="NM_802_11_MODE_AP"
              glib:nick="ap">
        <doc xml:space="preserve">the device is an access point/hotspot.  Not valid for
  access point objects; used only for hotspot mode on the local machine.</doc>
      </member>
    </enumeration>
    <constant name="ACCESS_POINT_BSSID"
              value="bssid"
              c:type="NM_ACCESS_POINT_BSSID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_FLAGS"
              value="flags"
              c:type="NM_ACCESS_POINT_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_FREQUENCY"
              value="frequency"
              c:type="NM_ACCESS_POINT_FREQUENCY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_HW_ADDRESS"
              value="hw-address"
              c:type="NM_ACCESS_POINT_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_LAST_SEEN"
              value="last-seen"
              c:type="NM_ACCESS_POINT_LAST_SEEN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_MAX_BITRATE"
              value="max-bitrate"
              c:type="NM_ACCESS_POINT_MAX_BITRATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_MODE"
              value="mode"
              c:type="NM_ACCESS_POINT_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_RSN_FLAGS"
              value="rsn-flags"
              c:type="NM_ACCESS_POINT_RSN_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_SSID"
              value="ssid"
              c:type="NM_ACCESS_POINT_SSID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_STRENGTH"
              value="strength"
              c:type="NM_ACCESS_POINT_STRENGTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_WPA_FLAGS"
              value="wpa-flags"
              c:type="NM_ACCESS_POINT_WPA_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_CONNECTION"
              value="connection"
              c:type="NM_ACTIVE_CONNECTION_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_DEFAULT"
              value="default"
              c:type="NM_ACTIVE_CONNECTION_DEFAULT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_DEFAULT6"
              value="default6"
              c:type="NM_ACTIVE_CONNECTION_DEFAULT6">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_DEVICES"
              value="devices"
              c:type="NM_ACTIVE_CONNECTION_DEVICES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_DHCP4_CONFIG"
              value="dhcp4-config"
              c:type="NM_ACTIVE_CONNECTION_DHCP4_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_DHCP6_CONFIG"
              value="dhcp6-config"
              c:type="NM_ACTIVE_CONNECTION_DHCP6_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_ID"
              value="id"
              c:type="NM_ACTIVE_CONNECTION_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_IP4_CONFIG"
              value="ip4-config"
              c:type="NM_ACTIVE_CONNECTION_IP4_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_IP6_CONFIG"
              value="ip6-config"
              c:type="NM_ACTIVE_CONNECTION_IP6_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_MASTER"
              value="master"
              c:type="NM_ACTIVE_CONNECTION_MASTER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_SPECIFIC_OBJECT_PATH"
              value="specific-object-path"
              c:type="NM_ACTIVE_CONNECTION_SPECIFIC_OBJECT_PATH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_STATE"
              value="state"
              c:type="NM_ACTIVE_CONNECTION_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_TYPE"
              value="type"
              c:type="NM_ACTIVE_CONNECTION_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_UUID"
              value="uuid"
              c:type="NM_ACTIVE_CONNECTION_UUID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_VPN"
              value="vpn"
              c:type="NM_ACTIVE_CONNECTION_VPN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="AccessPoint"
           c:symbol-prefix="access_point"
           c:type="NMAccessPoint"
           parent="Object"
           glib:type-name="NMAccessPoint"
           glib:get-type="nm_access_point_get_type"
           glib:type-struct="AccessPointClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <method name="connection_valid"
              c:identifier="nm_access_point_connection_valid">
        <doc xml:space="preserve">Validates a given connection against a given Wi-Fi access point to ensure that
the connection may be activated with that AP.  The connection must match the
@ap's SSID, (if given) BSSID, and other attributes like security settings,
channel, band, etc.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection may be activated with this Wi-Fi AP,
%FALSE if it cannot be.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">an #NMAccessPoint to validate @connection against</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">an #NMConnection to validate against @ap</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="filter_connections"
              c:identifier="nm_access_point_filter_connections">
        <doc xml:space="preserve">Filters a given array of connections for a given #NMAccessPoint object and
returns connections which may be activated with the access point.  Any
returned connections will match the @ap's SSID and (if given) BSSID and
other attributes like security settings, channel, etc.

To obtain the list of connections that are compatible with this access point,
use nm_client_get_connections() and then filter the returned list for a given
#NMDevice using nm_device_filter_connections() and finally filter that list
with this function.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">an array of
#NMConnections that could be activated with the given @ap.  The array should
be freed with g_ptr_array_unref() when it is no longer required.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="Connection"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">an #NMAccessPoint to filter connections for</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
          <parameter name="connections" transfer-ownership="none">
            <doc xml:space="preserve">an array of #NMConnections to
filter</doc>
            <array name="GLib.PtrArray" c:type="const GPtrArray*">
              <type name="Connection"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_bssid" c:identifier="nm_access_point_get_bssid">
        <doc xml:space="preserve">Gets the Basic Service Set ID (BSSID) of the Wi-Fi access point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the BSSID of the access point. This is an internal string and must
not be modified or freed.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="nm_access_point_get_flags">
        <doc xml:space="preserve">Gets the flags of the access point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the flags</doc>
          <type name="80211ApFlags" c:type="NM80211ApFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_frequency"
              c:identifier="nm_access_point_get_frequency">
        <doc xml:space="preserve">Gets the frequency of the access point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the frequency</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_last_seen"
              c:identifier="nm_access_point_get_last_seen"
              version="1.2">
        <doc xml:space="preserve">Returns the timestamp (in CLOCK_BOOTTIME seconds) for the last time the
access point was found in scan results.  A value of -1 means the access
point has not been found in a scan.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the last seen time in seconds</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_bitrate"
              c:identifier="nm_access_point_get_max_bitrate">
        <doc xml:space="preserve">Gets the maximum bit rate of the access point in kbit/s.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the maximum bit rate (kbit/s)</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mode" c:identifier="nm_access_point_get_mode">
        <doc xml:space="preserve">Gets the mode of the access point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the mode</doc>
          <type name="80211Mode" c:type="NM80211Mode"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_rsn_flags"
              c:identifier="nm_access_point_get_rsn_flags">
        <doc xml:space="preserve">Gets the RSN (Robust Secure Network, ie WPA version 2) flags of the access
point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the RSN flags</doc>
          <type name="80211ApSecurityFlags" c:type="NM80211ApSecurityFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ssid" c:identifier="nm_access_point_get_ssid">
        <doc xml:space="preserve">Gets the SSID of the access point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GBytes containing the SSID, or %NULL if the
  SSID is unknown.</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_strength" c:identifier="nm_access_point_get_strength">
        <doc xml:space="preserve">Gets the current signal strength of the access point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the signal strength</doc>
          <type name="guint8" c:type="guint8"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_wpa_flags"
              c:identifier="nm_access_point_get_wpa_flags">
        <doc xml:space="preserve">Gets the WPA (version 1) flags of the access point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the WPA flags</doc>
          <type name="80211ApSecurityFlags" c:type="NM80211ApSecurityFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="bssid" transfer-ownership="none">
        <doc xml:space="preserve">The BSSID of the access point.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="flags" transfer-ownership="none">
        <doc xml:space="preserve">The flags of the access point.</doc>
        <type name="80211ApFlags"/>
      </property>
      <property name="frequency" transfer-ownership="none">
        <doc xml:space="preserve">The frequency of the access point.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="hw-address"
                deprecated="1"
                deprecated-version="1.0"
                transfer-ownership="none">
        <doc xml:space="preserve">Alias for #NMAccessPoint:bssid.</doc>
        <doc-deprecated xml:space="preserve">use #NMAccessPoint:bssid.</doc-deprecated>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="last-seen" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The timestamp (in CLOCK_BOOTTIME seconds) for the last time the
access point was found in scan results.  A value of -1 means the
access point has not been found in a scan.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="max-bitrate" transfer-ownership="none">
        <doc xml:space="preserve">The maximum bit rate of the access point in kbit/s.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="mode" transfer-ownership="none">
        <doc xml:space="preserve">The mode of the access point; either "infrastructure" (a central
coordinator of the wireless network allowing clients to connect) or
"ad-hoc" (a network with no central controller).</doc>
        <type name="80211Mode"/>
      </property>
      <property name="rsn-flags" transfer-ownership="none">
        <doc xml:space="preserve">The RSN flags of the access point.</doc>
        <type name="80211ApSecurityFlags"/>
      </property>
      <property name="ssid" transfer-ownership="none">
        <doc xml:space="preserve">The SSID of the access point, or %NULL if it is not known.</doc>
        <type name="GLib.Bytes"/>
      </property>
      <property name="strength" transfer-ownership="none">
        <doc xml:space="preserve">The current signal strength of the access point.</doc>
        <type name="guint8" c:type="guint8"/>
      </property>
      <property name="wpa-flags" transfer-ownership="none">
        <doc xml:space="preserve">The WPA flags of the access point.</doc>
        <type name="80211ApSecurityFlags"/>
      </property>
      <field name="parent">
        <type name="Object" c:type="NMObject"/>
      </field>
    </class>
    <record name="AccessPointClass"
            c:type="NMAccessPointClass"
            glib:is-gtype-struct-for="AccessPoint">
      <field name="parent">
        <type name="ObjectClass" c:type="NMObjectClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="ActiveConnection"
           c:symbol-prefix="active_connection"
           c:type="NMActiveConnection"
           parent="Object"
           glib:type-name="NMActiveConnection"
           glib:get-type="nm_active_connection_get_type"
           glib:type-struct="ActiveConnectionClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <method name="get_connection"
              c:identifier="nm_active_connection_get_connection">
        <doc xml:space="preserve">Gets the #NMRemoteConnection associated with @connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMRemoteConnection which this
#NMActiveConnection is an active instance of.</doc>
          <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_connection_type"
              c:identifier="nm_active_connection_get_connection_type">
        <doc xml:space="preserve">Gets the #NMConnection's type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type of the #NMConnection that backs the #NMActiveConnection.
This is the internal string used by the connection, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_default"
              c:identifier="nm_active_connection_get_default">
        <doc xml:space="preserve">Whether the active connection is the default IPv4 one (that is, is used for
the default IPv4 route and DNS information).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the active connection is the default IPv4 connection</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_default6"
              c:identifier="nm_active_connection_get_default6">
        <doc xml:space="preserve">Whether the active connection is the default IPv6 one (that is, is used for
the default IPv6 route and DNS information).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the active connection is the default IPv6 connection</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_devices"
              c:identifier="nm_active_connection_get_devices">
        <doc xml:space="preserve">Gets the #NMDevices used for the active connections.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GPtrArray containing #NMDevices.
This is the internal copy used by the connection, and must not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="Device"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dhcp4_config"
              c:identifier="nm_active_connection_get_dhcp4_config">
        <doc xml:space="preserve">Gets the current IPv4 #NMDhcpConfig (if any) associated with the
#NMActiveConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IPv4 #NMDhcpConfig, or %NULL if the connection
  does not use DHCP, or is not in the %NM_ACTIVE_CONNECTION_STATE_ACTIVATED
  state.</doc>
          <type name="DhcpConfig" c:type="NMDhcpConfig*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">an #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dhcp6_config"
              c:identifier="nm_active_connection_get_dhcp6_config">
        <doc xml:space="preserve">Gets the current IPv6 #NMDhcpConfig (if any) associated with the
#NMActiveConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IPv6 #NMDhcpConfig, or %NULL if the connection
  does not use DHCPv6, or is not in the %NM_ACTIVE_CONNECTION_STATE_ACTIVATED
  state.</doc>
          <type name="DhcpConfig" c:type="NMDhcpConfig*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">an #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_id" c:identifier="nm_active_connection_get_id">
        <doc xml:space="preserve">Gets the #NMConnection's ID.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the ID of the #NMConnection that backs the #NMActiveConnection.
This is the internal string used by the connection, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ip4_config"
              c:identifier="nm_active_connection_get_ip4_config">
        <doc xml:space="preserve">Gets the current IPv4 #NMIPConfig associated with the #NMActiveConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IPv4 #NMIPConfig, or %NULL if the connection is
  not in the %NM_ACTIVE_CONNECTION_STATE_ACTIVATED state.</doc>
          <type name="IPConfig" c:type="NMIPConfig*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">an #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ip6_config"
              c:identifier="nm_active_connection_get_ip6_config">
        <doc xml:space="preserve">Gets the current IPv6 #NMIPConfig associated with the #NMActiveConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IPv6 #NMIPConfig, or %NULL if the connection is
  not in the %NM_ACTIVE_CONNECTION_STATE_ACTIVATED state.</doc>
          <type name="IPConfig" c:type="NMIPConfig*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">an #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_master" c:identifier="nm_active_connection_get_master">
        <doc xml:space="preserve">Gets the master #NMDevice of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the master #NMDevice of the #NMActiveConnection.</doc>
          <type name="Device" c:type="NMDevice*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_specific_object_path"
              c:identifier="nm_active_connection_get_specific_object_path">
        <doc xml:space="preserve">Gets the path of the "specific object" used at activation.

Currently there is no single method that will allow you to automatically turn
this into an appropriate #NMObject; you need to know what kind of object it
is based on other information. (Eg, if @connection corresponds to a Wi-Fi
connection, then the specific object will be an #NMAccessPoint, and you can
resolve it with nm_device_wifi_get_access_point_by_path().)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the specific object's D-Bus path. This is the internal string used
by the connection, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_state" c:identifier="nm_active_connection_get_state">
        <doc xml:space="preserve">Gets the active connection's state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the state</doc>
          <type name="ActiveConnectionState" c:type="NMActiveConnectionState"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_state_reason"
              c:identifier="nm_active_connection_get_state_reason"
              version="1.8">
        <doc xml:space="preserve">Gets the reason for active connection's state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the reason</doc>
          <type name="ActiveConnectionStateReason"
                c:type="NMActiveConnectionStateReason"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uuid" c:identifier="nm_active_connection_get_uuid">
        <doc xml:space="preserve">Gets the #NMConnection's UUID.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the UUID of the #NMConnection that backs the #NMActiveConnection.
This is the internal string used by the connection, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vpn" c:identifier="nm_active_connection_get_vpn">
        <doc xml:space="preserve">Whether the active connection is a VPN connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the active connection is a VPN connection</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="connection" transfer-ownership="none">
        <doc xml:space="preserve">The connection that this is an active instance of.</doc>
        <type name="RemoteConnection"/>
      </property>
      <property name="default" transfer-ownership="none">
        <doc xml:space="preserve">Whether the active connection is the default IPv4 one.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="default6" transfer-ownership="none">
        <doc xml:space="preserve">Whether the active connection is the default IPv6 one.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="devices" transfer-ownership="none">
        <doc xml:space="preserve">The devices of the active connection.

Element-type: NMDevice</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="dhcp4-config" transfer-ownership="none">
        <doc xml:space="preserve">The IPv4 #NMDhcpConfig of the connection.</doc>
        <type name="DhcpConfig"/>
      </property>
      <property name="dhcp6-config" transfer-ownership="none">
        <doc xml:space="preserve">The IPv6 #NMDhcpConfig of the connection.</doc>
        <type name="DhcpConfig"/>
      </property>
      <property name="id" transfer-ownership="none">
        <doc xml:space="preserve">The active connection's ID</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="ip4-config" transfer-ownership="none">
        <doc xml:space="preserve">The IPv4 #NMIPConfig of the connection.</doc>
        <type name="IPConfig"/>
      </property>
      <property name="ip6-config" transfer-ownership="none">
        <doc xml:space="preserve">The IPv6 #NMIPConfig of the connection.</doc>
        <type name="IPConfig"/>
      </property>
      <property name="master" transfer-ownership="none">
        <doc xml:space="preserve">The master device if one exists.</doc>
        <type name="Device"/>
      </property>
      <property name="specific-object-path" transfer-ownership="none">
        <doc xml:space="preserve">The path to the "specific object" of the active connection; see
nm_active_connection_get_specific_object_path() for more details.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="state" transfer-ownership="none">
        <doc xml:space="preserve">The state of the active connection.</doc>
        <type name="ActiveConnectionState"/>
      </property>
      <property name="type" transfer-ownership="none">
        <doc xml:space="preserve">The active connection's type</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="uuid" transfer-ownership="none">
        <doc xml:space="preserve">The active connection's UUID</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="vpn" transfer-ownership="none">
        <doc xml:space="preserve">Whether the active connection is a VPN connection.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="Object" c:type="NMObject"/>
      </field>
      <glib:signal name="state-changed" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ActiveConnectionClass"
            c:type="NMActiveConnectionClass"
            glib:is-gtype-struct-for="ActiveConnection">
      <field name="parent">
        <type name="ObjectClass" c:type="NMObjectClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="ActiveConnectionState"
                 glib:type-name="NMActiveConnectionState"
                 glib:get-type="nm_active_connection_state_get_type"
                 c:type="NMActiveConnectionState">
      <doc xml:space="preserve">#NMActiveConnectionState values indicate the state of a connection to a
specific network while it is starting, connected, or disconnecting from that
network.</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">the state of the connection is unknown</doc>
      </member>
      <member name="activating"
              value="1"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_ACTIVATING"
              glib:nick="activating">
        <doc xml:space="preserve">a network connection is being prepared</doc>
      </member>
      <member name="activated"
              value="2"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_ACTIVATED"
              glib:nick="activated">
        <doc xml:space="preserve">there is a connection to the network</doc>
      </member>
      <member name="deactivating"
              value="3"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_DEACTIVATING"
              glib:nick="deactivating">
        <doc xml:space="preserve">the network connection is being
  torn down and cleaned up</doc>
      </member>
      <member name="deactivated"
              value="4"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_DEACTIVATED"
              glib:nick="deactivated">
        <doc xml:space="preserve">the network connection is disconnected
  and will be removed</doc>
      </member>
    </enumeration>
    <enumeration name="ActiveConnectionStateReason"
                 version="1.8"
                 glib:type-name="NMActiveConnectionStateReason"
                 glib:get-type="nm_active_connection_state_reason_get_type"
                 c:type="NMActiveConnectionStateReason">
      <doc xml:space="preserve">Active connection state reasons.</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_REASON_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">The reason for the active connection
  state change is unknown.</doc>
      </member>
      <member name="none"
              value="1"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_REASON_NONE"
              glib:nick="none">
        <doc xml:space="preserve">No reason was given for the active
  connection state change.</doc>
      </member>
      <member name="user_disconnected"
              value="2"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_REASON_USER_DISCONNECTED"
              glib:nick="user-disconnected">
        <doc xml:space="preserve">The active connection changed
  state because the user disconnected it.</doc>
      </member>
      <member name="device_disconnected"
              value="3"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED"
              glib:nick="device-disconnected">
        <doc xml:space="preserve">The active connection
  changed state because the device it was using was disconnected.</doc>
      </member>
      <member name="service_stopped"
              value="4"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_STOPPED"
              glib:nick="service-stopped">
        <doc xml:space="preserve">The service providing the
  VPN connection was stopped.</doc>
      </member>
      <member name="ip_config_invalid"
              value="5"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_REASON_IP_CONFIG_INVALID"
              glib:nick="ip-config-invalid">
        <doc xml:space="preserve">The IP config of the active
  connection was invalid.</doc>
      </member>
      <member name="connect_timeout"
              value="6"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_REASON_CONNECT_TIMEOUT"
              glib:nick="connect-timeout">
        <doc xml:space="preserve">The connection attempt to
  the VPN service timed out.</doc>
      </member>
      <member name="service_start_timeout"
              value="7"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT"
              glib:nick="service-start-timeout">
        <doc xml:space="preserve">A timeout occurred
  while starting the service providing the VPN connection.</doc>
      </member>
      <member name="service_start_failed"
              value="8"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_FAILED"
              glib:nick="service-start-failed">
        <doc xml:space="preserve">Starting the service
  providing the VPN connection failed.</doc>
      </member>
      <member name="no_secrets"
              value="9"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_REASON_NO_SECRETS"
              glib:nick="no-secrets">
        <doc xml:space="preserve">Necessary secrets for the
  connection were not provided.</doc>
      </member>
      <member name="login_failed"
              value="10"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_REASON_LOGIN_FAILED"
              glib:nick="login-failed">
        <doc xml:space="preserve">Authentication to the
  server failed.</doc>
      </member>
      <member name="connection_removed"
              value="11"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_REASON_CONNECTION_REMOVED"
              glib:nick="connection-removed">
        <doc xml:space="preserve">The connection was
  deleted from settings.</doc>
      </member>
      <member name="dependency_failed"
              value="12"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_REASON_DEPENDENCY_FAILED"
              glib:nick="dependency-failed">
        <doc xml:space="preserve">Master connection of this
  connection failed to activate.</doc>
      </member>
      <member name="device_realize_failed"
              value="13"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REALIZE_FAILED"
              glib:nick="device-realize-failed">
        <doc xml:space="preserve">Could not create the
  software device link.</doc>
      </member>
      <member name="device_removed"
              value="14"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REMOVED"
              glib:nick="device-removed">
        <doc xml:space="preserve">The device this connection
  depended on disappeared.</doc>
      </member>
    </enumeration>
    <enumeration name="AgentManagerError"
                 glib:type-name="NMAgentManagerError"
                 glib:get-type="nm_agent_manager_error_get_type"
                 c:type="NMAgentManagerError"
                 glib:error-domain="nm-agent-manager-error-quark">
      <doc xml:space="preserve">Errors returned from the secret-agent manager.

These errors may be returned from operations that could cause secrets to be
requested (such as nm_client_activate_connection()), and correspond to D-Bus
errors in the "org.freedesktop.NetworkManager.AgentManager" namespace.</doc>
      <member name="Failed"
              value="0"
              c:identifier="NM_AGENT_MANAGER_ERROR_FAILED"
              glib:nick="Failed">
        <doc xml:space="preserve">unknown or unspecified error</doc>
      </member>
      <member name="PermissionDenied"
              value="1"
              c:identifier="NM_AGENT_MANAGER_ERROR_PERMISSION_DENIED"
              glib:nick="PermissionDenied">
        <doc xml:space="preserve">The caller does not have permission
  to register a secret agent, or is trying to register the same secret agent
  twice.</doc>
      </member>
      <member name="InvalidIdentifier"
              value="2"
              c:identifier="NM_AGENT_MANAGER_ERROR_INVALID_IDENTIFIER"
              glib:nick="InvalidIdentifier">
        <doc xml:space="preserve">The identifier is not a valid
  secret agent identifier.</doc>
      </member>
      <member name="NotRegistered"
              value="3"
              c:identifier="NM_AGENT_MANAGER_ERROR_NOT_REGISTERED"
              glib:nick="NotRegistered">
        <doc xml:space="preserve">The caller tried to unregister an agent
  that was not registered.</doc>
      </member>
      <member name="NoSecrets"
              value="4"
              c:identifier="NM_AGENT_MANAGER_ERROR_NO_SECRETS"
              glib:nick="NoSecrets">
        <doc xml:space="preserve">No secret agent returned secrets for this
  request</doc>
      </member>
      <member name="UserCanceled"
              value="5"
              c:identifier="NM_AGENT_MANAGER_ERROR_USER_CANCELED"
              glib:nick="UserCanceled">
        <doc xml:space="preserve">The user canceled the secrets request.</doc>
      </member>
      <function name="quark" c:identifier="nm_agent_manager_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <bitfield name="BluetoothCapabilities"
              glib:type-name="NMBluetoothCapabilities"
              glib:get-type="nm_bluetooth_capabilities_get_type"
              c:type="NMBluetoothCapabilities">
      <doc xml:space="preserve">#NMBluetoothCapabilities values indicate the usable capabilities of a
Bluetooth device.</doc>
      <member name="none"
              value="0"
              c:identifier="NM_BT_CAPABILITY_NONE"
              glib:nick="none">
        <doc xml:space="preserve">device has no usable capabilities</doc>
      </member>
      <member name="dun"
              value="1"
              c:identifier="NM_BT_CAPABILITY_DUN"
              glib:nick="dun">
        <doc xml:space="preserve">device provides Dial-Up Networking capability</doc>
      </member>
      <member name="nap"
              value="2"
              c:identifier="NM_BT_CAPABILITY_NAP"
              glib:nick="nap">
        <doc xml:space="preserve">device provides Network Access Point capability</doc>
      </member>
    </bitfield>
    <constant name="CLIENT_ACTIVATING_CONNECTION"
              value="activating-connection"
              c:type="NM_CLIENT_ACTIVATING_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_ACTIVE_CONNECTIONS"
              value="active-connections"
              c:type="NM_CLIENT_ACTIVE_CONNECTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_ACTIVE_CONNECTION_ADDED"
              value="active-connection-added"
              c:type="NM_CLIENT_ACTIVE_CONNECTION_ADDED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_ACTIVE_CONNECTION_REMOVED"
              value="active-connection-removed"
              c:type="NM_CLIENT_ACTIVE_CONNECTION_REMOVED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_ALL_DEVICES"
              value="all-devices"
              c:type="NM_CLIENT_ALL_DEVICES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_ANY_DEVICE_ADDED"
              value="any-device-added"
              c:type="NM_CLIENT_ANY_DEVICE_ADDED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_ANY_DEVICE_REMOVED"
              value="any-device-removed"
              c:type="NM_CLIENT_ANY_DEVICE_REMOVED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_CAN_MODIFY"
              value="can-modify"
              c:type="NM_CLIENT_CAN_MODIFY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_CONNECTIONS"
              value="connections"
              c:type="NM_CLIENT_CONNECTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_CONNECTION_ADDED"
              value="connection-added"
              c:type="NM_CLIENT_CONNECTION_ADDED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_CONNECTION_REMOVED"
              value="connection-removed"
              c:type="NM_CLIENT_CONNECTION_REMOVED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_CONNECTIVITY"
              value="connectivity"
              c:type="NM_CLIENT_CONNECTIVITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_DEVICES" value="devices" c:type="NM_CLIENT_DEVICES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_DEVICE_ADDED"
              value="device-added"
              c:type="NM_CLIENT_DEVICE_ADDED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_DEVICE_REMOVED"
              value="device-removed"
              c:type="NM_CLIENT_DEVICE_REMOVED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_DNS_CONFIGURATION"
              value="dns-configuration"
              c:type="NM_CLIENT_DNS_CONFIGURATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_DNS_MODE"
              value="dns-mode"
              c:type="NM_CLIENT_DNS_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_DNS_RC_MANAGER"
              value="dns-rc-manager"
              c:type="NM_CLIENT_DNS_RC_MANAGER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_HOSTNAME"
              value="hostname"
              c:type="NM_CLIENT_HOSTNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_METERED" value="metered" c:type="NM_CLIENT_METERED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_NETWORKING_ENABLED"
              value="networking-enabled"
              c:type="NM_CLIENT_NETWORKING_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_NM_RUNNING"
              value="nm-running"
              c:type="NM_CLIENT_NM_RUNNING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_PERMISSION_CHANGED"
              value="permission-changed"
              c:type="NM_CLIENT_PERMISSION_CHANGED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_PRIMARY_CONNECTION"
              value="primary-connection"
              c:type="NM_CLIENT_PRIMARY_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_STARTUP" value="startup" c:type="NM_CLIENT_STARTUP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_STATE" value="state" c:type="NM_CLIENT_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_VERSION" value="version" c:type="NM_CLIENT_VERSION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_WIMAX_ENABLED"
              value="wimax-enabled"
              c:type="NM_CLIENT_WIMAX_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_WIMAX_HARDWARE_ENABLED"
              value="wimax-hardware-enabled"
              c:type="NM_CLIENT_WIMAX_HARDWARE_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_WIRELESS_ENABLED"
              value="wireless-enabled"
              c:type="NM_CLIENT_WIRELESS_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_WIRELESS_HARDWARE_ENABLED"
              value="wireless-hardware-enabled"
              c:type="NM_CLIENT_WIRELESS_HARDWARE_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_WWAN_ENABLED"
              value="wwan-enabled"
              c:type="NM_CLIENT_WWAN_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_WWAN_HARDWARE_ENABLED"
              value="wwan-hardware-enabled"
              c:type="NM_CLIENT_WWAN_HARDWARE_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CONNECTION_CHANGED"
              value="changed"
              c:type="NM_CONNECTION_CHANGED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CONNECTION_NORMALIZE_PARAM_IP6_CONFIG_METHOD"
              value="ip6-config-method"
              c:type="NM_CONNECTION_NORMALIZE_PARAM_IP6_CONFIG_METHOD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CONNECTION_SECRETS_CLEARED"
              value="secrets-cleared"
              c:type="NM_CONNECTION_SECRETS_CLEARED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CONNECTION_SECRETS_UPDATED"
              value="secrets-updated"
              c:type="NM_CONNECTION_SECRETS_UPDATED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="Capability"
                 glib:type-name="NMCapability"
                 glib:get-type="nm_capability_get_type"
                 c:type="NMCapability">
      <doc xml:space="preserve">#NMCapability names the numbers in the Capabilities property.
Capabilities are positive numbers. They are part of stable API
and a certain capability number is guaranteed not to change.

The range 0x7000 - 0x7FFF of capabilities is guaranteed not to be
used by upstream NetworkManager. It could thus be used for downstream
extensions.</doc>
      <member name="team"
              value="1"
              c:identifier="NM_CAPABILITY_TEAM"
              glib:nick="team">
        <doc xml:space="preserve">Teams can be managed</doc>
      </member>
    </enumeration>
    <enumeration name="CheckpointCreateFlags"
                 version="1.4"
                 c:type="NMCheckpointCreateFlags">
      <doc xml:space="preserve">The flags for CheckpointCreate call</doc>
      <member name="none"
              value="0"
              c:identifier="NM_CHECKPOINT_CREATE_FLAG_NONE">
        <doc xml:space="preserve">no flags</doc>
      </member>
      <member name="destroy_all"
              value="1"
              c:identifier="NM_CHECKPOINT_CREATE_FLAG_DESTROY_ALL">
        <doc xml:space="preserve">when creating
  a new checkpoint, destroy all existing ones.</doc>
      </member>
      <member name="delete_new_connections"
              value="2"
              c:identifier="NM_CHECKPOINT_CREATE_FLAG_DELETE_NEW_CONNECTIONS">
        <doc xml:space="preserve">upon rollback,
  delete any new connection added after the checkpoint.</doc>
      </member>
      <member name="disconnect_new_devices"
              value="4"
              c:identifier="NM_CHECKPOINT_CREATE_FLAG_DISCONNECT_NEW_DEVICES">
        <doc xml:space="preserve">upon rollback,
  disconnect any new device appeared after the checkpoint.</doc>
      </member>
    </enumeration>
    <class name="Client"
           c:symbol-prefix="client"
           c:type="NMClient"
           parent="GObject.Object"
           glib:type-name="NMClient"
           glib:get-type="nm_client_get_type"
           glib:type-struct="ClientClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_client_new" throws="1">
        <doc xml:space="preserve">Creates a new #NMClient.

Note that this will do blocking D-Bus calls to initialize the
client. You can use nm_client_new_async() if you want to avoid
that.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #NMClient or NULL on an error</doc>
          <type name="Client" c:type="NMClient*"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_finish"
                   c:identifier="nm_client_new_finish"
                   throws="1">
        <doc xml:space="preserve">Gets the result of an nm_client_new_async() call.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #NMClient, or %NULL on error</doc>
          <type name="Client" c:type="NMClient*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="new_async" c:identifier="nm_client_new_async">
        <doc xml:space="preserve">Creates a new #NMClient and begins asynchronously initializing it.
@callback will be called when it is done; use
nm_client_new_finish() to get the result. Note that on an error,
the callback can be invoked with two first parameters as NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">callback to call when the client is created</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="any_device_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="device" transfer-ownership="none">
            <type name="Device" c:type="NMDevice*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="any_device_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="device" transfer-ownership="none">
            <type name="Device" c:type="NMDevice*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="connection_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="connection_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="device_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="device" transfer-ownership="none">
            <type name="Device" c:type="NMDevice*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="device_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="device" transfer-ownership="none">
            <type name="Device" c:type="NMDevice*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="permission_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="permission" transfer-ownership="none">
            <type name="ClientPermission" c:type="NMClientPermission"/>
          </parameter>
          <parameter name="result" transfer-ownership="none">
            <type name="ClientPermissionResult"
                  c:type="NMClientPermissionResult"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="activate_connection_async"
              c:identifier="nm_client_activate_connection_async">
        <doc xml:space="preserve">Asynchronously starts a connection to a particular network using the
configuration settings from @connection and the network device @device.
Certain connection types also take a "specific object" which is the object
path of a connection- specific object, like an #NMAccessPoint for Wi-Fi
connections, or an #NMWimaxNsp for WiMAX connections, to which you wish to
connect.  If the specific object is not given, NetworkManager can, in some
cases, automatically determine which network to connect to given the settings
in @connection.

If @connection is not given for a device-based activation, NetworkManager
picks the best available connection for the device and activates it.

Note that the callback is invoked when NetworkManager has started activating
the new connection, not when it finishes. You can used the returned
#NMActiveConnection object (in particular, #NMActiveConnection:state) to
track the activation to its completion.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="connection"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">an #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="device"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </parameter>
          <parameter name="specific_object"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the object path of a connection-type-specific
  object this activation should use. This parameter is currently ignored for
  wired and mobile broadband connections, and the value of %NULL should be used
  (ie, no specific object).  For Wi-Fi or WiMAX connections, pass the object
  path of a #NMAccessPoint or #NMWimaxNsp owned by @device, which you can
  get using nm_object_get_path(), and which will be used to complete the
  details of the newly added connection.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve">callback to be called when the activation has started</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">caller-specific data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="activate_connection_finish"
              c:identifier="nm_client_activate_connection_finish"
              throws="1">
        <doc xml:space="preserve">Gets the result of a call to nm_client_activate_connection_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #NMActiveConnection on success, %NULL on
  failure, in which case @error will be set.</doc>
          <type name="ActiveConnection" c:type="NMActiveConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">an #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the #GAsyncReadyCallback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_and_activate_connection_async"
              c:identifier="nm_client_add_and_activate_connection_async">
        <doc xml:space="preserve">Adds a new connection using the given details (if any) as a template,
automatically filling in missing settings with the capabilities of the given
device and specific object.  The new connection is then asynchronously
activated as with nm_client_activate_connection_async(). Cannot be used for
VPN connections at this time.

Note that the callback is invoked when NetworkManager has started activating
the new connection, not when it finishes. You can used the returned
#NMActiveConnection object (in particular, #NMActiveConnection:state) to
track the activation to its completion.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="partial"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">an #NMConnection to add; the connection may be
  partially filled (or even %NULL) and will be completed by NetworkManager
  using the given @device and @specific_object before being added</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">the #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </parameter>
          <parameter name="specific_object"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the object path of a connection-type-specific
  object this activation should use. This parameter is currently ignored for
  wired and mobile broadband connections, and the value of %NULL should be used
  (ie, no specific object).  For Wi-Fi or WiMAX connections, pass the object
  path of a #NMAccessPoint or #NMWimaxNsp owned by @device, which you can
  get using nm_object_get_path(), and which will be used to complete the
  details of the newly added connection.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve">callback to be called when the activation has started</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">caller-specific data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_and_activate_connection_finish"
              c:identifier="nm_client_add_and_activate_connection_finish"
              throws="1">
        <doc xml:space="preserve">Gets the result of a call to nm_client_add_and_activate_connection_async().

You can call nm_active_connection_get_connection() on the returned
#NMActiveConnection to find the path of the created #NMConnection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #NMActiveConnection on success, %NULL on
  failure, in which case @error will be set.</doc>
          <type name="ActiveConnection" c:type="NMActiveConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">an #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the #GAsyncReadyCallback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_connection_async"
              c:identifier="nm_client_add_connection_async">
        <doc xml:space="preserve">Requests that the remote settings service add the given settings to a new
connection.  If @save_to_disk is %TRUE, the connection is immediately written
to disk; otherwise it is initially only stored in memory, but may be saved
later by calling the connection's nm_remote_connection_commit_changes()
method.

@connection is untouched by this function and only serves as a template of
the settings to add.  The #NMRemoteConnection object that represents what
NetworkManager actually added is returned to @callback when the addition
operation is complete.

Note that the #NMRemoteConnection returned in @callback may not contain
identical settings to @connection as NetworkManager may perform automatic
completion and/or normalization of connection properties.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">the %NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the connection to add. Note that this object's settings will be
  added, not the object itself</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="save_to_disk" transfer-ownership="none">
            <doc xml:space="preserve">whether to immediately save the connection to disk</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">callback to be called when the add operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">caller-specific data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_connection_finish"
              c:identifier="nm_client_add_connection_finish"
              throws="1">
        <doc xml:space="preserve">Gets the result of a call to nm_client_add_connection_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #NMRemoteConnection on success, %NULL on
  failure, in which case @error will be set.</doc>
          <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">an #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the #GAsyncReadyCallback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="check_connectivity"
              c:identifier="nm_client_check_connectivity"
              throws="1">
        <doc xml:space="preserve">Updates the network connectivity state and returns the (new)
current state. Contrast nm_client_get_connectivity(), which returns
the most recent known state without re-checking.

This is a blocking call; use nm_client_check_connectivity_async()
if you do not want to block.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the (new) current connectivity state</doc>
          <type name="ConnectivityState" c:type="NMConnectivityState"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">an #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="check_connectivity_async"
              c:identifier="nm_client_check_connectivity_async">
        <doc xml:space="preserve">Asynchronously updates the network connectivity state and invokes
@callback when complete. Contrast nm_client_get_connectivity(),
which (immediately) returns the most recent known state without
re-checking, and nm_client_check_connectivity(), which blocks.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">an #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">callback to call with the result</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data for @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="check_connectivity_finish"
              c:identifier="nm_client_check_connectivity_finish"
              throws="1">
        <doc xml:space="preserve">Retrieves the result of an nm_client_check_connectivity_async()
call.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the (new) current connectivity state</doc>
          <type name="ConnectivityState" c:type="NMConnectivityState"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">an #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="deactivate_connection"
              c:identifier="nm_client_deactivate_connection"
              throws="1">
        <doc xml:space="preserve">Deactivates an active #NMActiveConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">success or failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="active" transfer-ownership="none">
            <doc xml:space="preserve">the #NMActiveConnection to deactivate</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="deactivate_connection_async"
              c:identifier="nm_client_deactivate_connection_async">
        <doc xml:space="preserve">Asynchronously deactivates an active #NMActiveConnection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="active" transfer-ownership="none">
            <doc xml:space="preserve">the #NMActiveConnection to deactivate</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">callback to be called when the deactivation has completed</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">caller-specific data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="deactivate_connection_finish"
              c:identifier="nm_client_deactivate_connection_finish"
              throws="1">
        <doc xml:space="preserve">Gets the result of a call to nm_client_deactivate_connection_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">success or failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the #GAsyncReadyCallback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_activating_connection"
              c:identifier="nm_client_get_activating_connection">
        <doc xml:space="preserve">Gets the #NMActiveConnection corresponding to a
currently-activating connection that is expected to become the new
#NMClient:primary-connection upon successful activation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the appropriate #NMActiveConnection, if
any.</doc>
          <type name="ActiveConnection" c:type="NMActiveConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">an #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_active_connections"
              c:identifier="nm_client_get_active_connections">
        <doc xml:space="preserve">Gets the active connections.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GPtrArray
 containing all the active #NMActiveConnections.
The returned array is owned by the client and should not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="ActiveConnection"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_all_devices"
              c:identifier="nm_client_get_all_devices"
              version="1.2">
        <doc xml:space="preserve">Gets both real devices and device placeholders (eg, software devices which
do not currently exist, but could be created automatically by NetworkManager
if one of their NMDevice::ActivatableConnections was activated).  Use
nm_device_is_real() to determine whether each device is a real device or
a placeholder.

Use nm_device_get_type() or the NM_IS_DEVICE_XXXX() functions to determine
what kind of device each member of the returned array is, and then you may
use device-specific methods such as nm_device_ethernet_get_hw_address().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GPtrArray
containing all the #NMDevices.  The returned array is owned by the
#NMClient object and should not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="Device"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_connection_by_id"
              c:identifier="nm_client_get_connection_by_id">
        <doc xml:space="preserve">Returns the first matching %NMRemoteConnection matching a given @id.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the remote connection object on success, or %NULL if no
 matching object was found.

The connection is as received from D-Bus and might not validate according
to nm_connection_verify().</doc>
          <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">the %NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">the id of the remote connection</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_connection_by_path"
              c:identifier="nm_client_get_connection_by_path">
        <doc xml:space="preserve">Returns the %NMRemoteConnection representing the connection at @path.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the remote connection object on success, or %NULL if the object was
 not known

The connection is as received from D-Bus and might not validate according
to nm_connection_verify().</doc>
          <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">the %NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the D-Bus object path of the remote connection</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_connection_by_uuid"
              c:identifier="nm_client_get_connection_by_uuid">
        <doc xml:space="preserve">Returns the %NMRemoteConnection identified by @uuid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the remote connection object on success, or %NULL if the object was
 not known

The connection is as received from D-Bus and might not validate according
to nm_connection_verify().</doc>
          <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">the %NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="uuid" transfer-ownership="none">
            <doc xml:space="preserve">the UUID of the remote connection</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_connections" c:identifier="nm_client_get_connections">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an array
containing all connections provided by the remote settings service.  The
returned array is owned by the #NMClient object and should not be modified.

The connections are as received from D-Bus and might not validate according
to nm_connection_verify().</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="RemoteConnection"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">the %NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_connectivity"
              c:identifier="nm_client_get_connectivity">
        <doc xml:space="preserve">Gets the current network connectivity state. Contrast
nm_client_check_connectivity() and
nm_client_check_connectivity_async(), which re-check the
connectivity state first before returning any information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current connectivity state</doc>
          <type name="ConnectivityState" c:type="NMConnectivityState"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">an #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_device_by_iface"
              c:identifier="nm_client_get_device_by_iface">
        <doc xml:space="preserve">Gets a #NMDevice from a #NMClient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMDevice for the given @iface or %NULL if none is found.</doc>
          <type name="Device" c:type="NMDevice*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="iface" transfer-ownership="none">
            <doc xml:space="preserve">the interface name to search for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_device_by_path"
              c:identifier="nm_client_get_device_by_path">
        <doc xml:space="preserve">Gets a #NMDevice from a #NMClient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMDevice for the given @object_path or %NULL if none is found.</doc>
          <type name="Device" c:type="NMDevice*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">the object path to search for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_devices" c:identifier="nm_client_get_devices">
        <doc xml:space="preserve">Gets all the known network devices.  Use nm_device_get_type() or the
&lt;literal&gt;NM_IS_DEVICE_XXXX&lt;/literal&gt; functions to determine what kind of
device member of the returned array is, and then you may use device-specific
methods such as nm_device_ethernet_get_hw_address().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GPtrArray
containing all the #NMDevices.  The returned array is owned by the
#NMClient object and should not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="Device"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dns_configuration"
              c:identifier="nm_client_get_dns_configuration"
              version="1.6">
        <doc xml:space="preserve">Gets the current DNS configuration</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GPtrArray
containing #NMDnsEntry elements or %NULL in case the value is not
available.  The returned array is owned by the #NMClient object
and should not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="DnsEntry"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dns_mode"
              c:identifier="nm_client_get_dns_mode"
              version="1.6">
        <doc xml:space="preserve">Gets the current DNS processing mode.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the DNS processing mode, or %NULL in case the
  value is not available.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">the #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dns_rc_manager"
              c:identifier="nm_client_get_dns_rc_manager"
              version="1.6">
        <doc xml:space="preserve">Gets the current DNS resolv.conf manager.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the resolv.conf manager or %NULL in case the
  value is not available.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">the #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_logging"
              c:identifier="nm_client_get_logging"
              throws="1">
        <doc xml:space="preserve">Gets NetworkManager current logging level and domains.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="level"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">return location for logging level string</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
          <parameter name="domains"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">return location for log domains string. The string is
  a list of domains separated by ","</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_nm_running" c:identifier="nm_client_get_nm_running">
        <doc xml:space="preserve">Determines whether the daemon is running.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the daemon is running</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_permission_result"
              c:identifier="nm_client_get_permission_result">
        <doc xml:space="preserve">Requests the result of a specific permission, which indicates whether the
client can or cannot perform the action the permission represents</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the permission's result, one of #NMClientPermissionResult</doc>
          <type name="ClientPermissionResult"
                c:type="NMClientPermissionResult"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="permission" transfer-ownership="none">
            <doc xml:space="preserve">the permission for which to return the result, one of #NMClientPermission</doc>
            <type name="ClientPermission" c:type="NMClientPermission"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_primary_connection"
              c:identifier="nm_client_get_primary_connection">
        <doc xml:space="preserve">Gets the #NMActiveConnection corresponding to the primary active
network device.

In particular, when there is no VPN active, or the VPN does not
have the default route, this returns the active connection that has
the default route. If there is a VPN active with the default route,
then this function returns the active connection that contains the
route to the VPN endpoint.

If there is no default route, or the default route is over a
non-NetworkManager-recognized device, this will return %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the appropriate #NMActiveConnection, if
any</doc>
          <type name="ActiveConnection" c:type="NMActiveConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">an #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_startup" c:identifier="nm_client_get_startup">
        <doc xml:space="preserve">Tests whether the daemon is still in the process of activating
connections at startup.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the daemon is still starting up</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_state" c:identifier="nm_client_get_state">
        <doc xml:space="preserve">Gets the current daemon state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current %NMState</doc>
          <type name="State" c:type="NMState"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_version" c:identifier="nm_client_get_version">
        <doc xml:space="preserve">Gets NetworkManager version.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">string with the version (or %NULL if NetworkManager is not running)</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="load_connections"
              c:identifier="nm_client_load_connections"
              throws="1">
        <doc xml:space="preserve">Requests that the remote settings service load or reload the given files,
adding or updating the connections described within.

The changes to the indicated files will not yet be reflected in
@client's connections array when the function returns.

If all of the indicated files were successfully loaded, the
function will return %TRUE, and @failures will be set to %NULL. If
NetworkManager tried to load the files, but some (or all) failed,
then @failures will be set to a %NULL-terminated array of the
filenames that failed to load.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if NetworkManager at least tried to load @filenames,
%FALSE if an error occurred (eg, permission denied).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">the %NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="filenames" transfer-ownership="none">
            <doc xml:space="preserve">%NULL-terminated array of filenames to load</doc>
            <array c:type="char**">
              <type name="utf8" c:type="char*"/>
            </array>
          </parameter>
          <parameter name="failures"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">on return, a %NULL-terminated array of
  filenames that failed to load</doc>
            <type name="utf8" c:type="char***"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_connections_async"
              c:identifier="nm_client_load_connections_async">
        <doc xml:space="preserve">Requests that the remote settings service asynchronously load or reload the
given files, adding or updating the connections described within.

See nm_client_load_connections() for more details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">the %NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="filenames" transfer-ownership="none">
            <doc xml:space="preserve">%NULL-terminated array of filenames to load</doc>
            <array c:type="char**">
              <type name="utf8" c:type="char*"/>
            </array>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">callback to be called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">caller-specific data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_connections_finish"
              c:identifier="nm_client_load_connections_finish"
              throws="1">
        <doc xml:space="preserve">Gets the result of an nm_client_load_connections_async() call.

See nm_client_load_connections() for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if NetworkManager at least tried to load @filenames,
%FALSE if an error occurred (eg, permission denied).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">the %NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="failures"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">on return, a
   %NULL-terminated array of filenames that failed to load</doc>
            <array c:type="char***">
              <type name="utf8" c:type="char**"/>
            </array>
          </parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the #GAsyncReadyCallback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="networking_get_enabled"
              c:identifier="nm_client_networking_get_enabled">
        <doc xml:space="preserve">Whether networking is enabled or disabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if networking is enabled, %FALSE if networking is disabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="networking_set_enabled"
              c:identifier="nm_client_networking_set_enabled"
              throws="1">
        <doc xml:space="preserve">Enables or disables networking.  When networking is disabled, all controlled
interfaces are disconnected and deactivated.  When networking is enabled,
all controlled interfaces are available for activation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to set networking enabled, %FALSE to set networking disabled</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="reload_connections"
              c:identifier="nm_client_reload_connections"
              throws="1">
        <doc xml:space="preserve">Requests that the remote settings service reload all connection
files from disk, adding, updating, and removing connections until
the in-memory state matches the on-disk state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">the #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reload_connections_async"
              c:identifier="nm_client_reload_connections_async">
        <doc xml:space="preserve">Requests that the remote settings service begin reloading all connection
files from disk, adding, updating, and removing connections until the
in-memory state matches the on-disk state.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">the #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">callback to be called when the reload operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">caller-specific data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="reload_connections_finish"
              c:identifier="nm_client_reload_connections_finish"
              throws="1">
        <doc xml:space="preserve">Gets the result of an nm_client_reload_connections_async() call.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">the #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the #GAsyncReadyCallback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="save_hostname"
              c:identifier="nm_client_save_hostname"
              throws="1">
        <doc xml:space="preserve">Requests that the machine's persistent hostname be set to the specified value
or cleared.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the request was successful, %FALSE if it failed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">the %NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="hostname"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the new persistent hostname to set, or %NULL to
  clear any existing persistent hostname</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="save_hostname_async"
              c:identifier="nm_client_save_hostname_async">
        <doc xml:space="preserve">Requests that the machine's persistent hostname be set to the specified value
or cleared.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">the %NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="hostname"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the new persistent hostname to set, or %NULL to
  clear any existing persistent hostname</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">callback to be called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">caller-specific data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="save_hostname_finish"
              c:identifier="nm_client_save_hostname_finish"
              throws="1">
        <doc xml:space="preserve">Gets the result of an nm_client_save_hostname_async() call.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the request was successful, %FALSE if it failed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">the %NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the #GAsyncReadyCallback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_logging"
              c:identifier="nm_client_set_logging"
              throws="1">
        <doc xml:space="preserve">Sets NetworkManager logging level and/or domains.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="level"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">logging level to set (%NULL or an empty string for no change)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="domains"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">logging domains to set. The string should be a list of log
  domains separated by ",". (%NULL or an empty string for no change)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="wimax_get_enabled"
              c:identifier="nm_client_wimax_get_enabled">
        <doc xml:space="preserve">Determines whether WiMAX is enabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if WiMAX is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wimax_hardware_get_enabled"
              c:identifier="nm_client_wimax_hardware_get_enabled">
        <doc xml:space="preserve">Determines whether the WiMAX hardware is enabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the WiMAX hardware is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wimax_set_enabled"
              c:identifier="nm_client_wimax_set_enabled">
        <doc xml:space="preserve">Enables or disables WiMAX devices.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to enable WiMAX</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="wireless_get_enabled"
              c:identifier="nm_client_wireless_get_enabled">
        <doc xml:space="preserve">Determines whether the wireless is enabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if wireless is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wireless_hardware_get_enabled"
              c:identifier="nm_client_wireless_hardware_get_enabled">
        <doc xml:space="preserve">Determines whether the wireless hardware is enabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the wireless hardware is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wireless_set_enabled"
              c:identifier="nm_client_wireless_set_enabled">
        <doc xml:space="preserve">Enables or disables wireless devices.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to enable wireless</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="wwan_get_enabled"
              c:identifier="nm_client_wwan_get_enabled">
        <doc xml:space="preserve">Determines whether WWAN is enabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if WWAN is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wwan_hardware_get_enabled"
              c:identifier="nm_client_wwan_hardware_get_enabled">
        <doc xml:space="preserve">Determines whether the WWAN hardware is enabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the WWAN hardware is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wwan_set_enabled"
              c:identifier="nm_client_wwan_set_enabled">
        <doc xml:space="preserve">Enables or disables WWAN devices.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to enable WWAN</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="activating-connection" transfer-ownership="none">
        <doc xml:space="preserve">The #NMActiveConnection of the activating connection that is
likely to become the new #NMClient:primary-connection.</doc>
        <type name="ActiveConnection"/>
      </property>
      <property name="active-connections" transfer-ownership="none">
        <doc xml:space="preserve">The active connections.

Element-type: NMActiveConnection</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="all-devices" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">List of both real devices and device placeholders.

Element-type: NMDevice</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="can-modify" transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, adding and modifying connections is supported.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="connections" transfer-ownership="none">
        <doc xml:space="preserve">The list of configured connections that are available to the user. (Note
that this differs from the underlying D-Bus property, which may also
contain the object paths of connections that the user does not have
permission to read the details of.)

Element-type: NMRemoteConnection</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="connectivity" transfer-ownership="none">
        <doc xml:space="preserve">The network connectivity state.</doc>
        <type name="ConnectivityState"/>
      </property>
      <property name="devices" transfer-ownership="none">
        <doc xml:space="preserve">List of real network devices.  Does not include placeholder devices.

Element-type: NMDevice</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="dns-configuration"
                version="1.6"
                transfer-ownership="none">
        <doc xml:space="preserve">The current DNS configuration represented as an array of
dictionaries.  Each dictionary has the "nameservers",
"priority" keys and, optionally, "interface" and "vpn".
"nameservers" is the list of DNS servers, "priority" their
relative priority, "interface" the interface on which these
servers are contacted, "vpn" a boolean telling whether the
configuration was obtained from a VPN connection.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="dns-mode" version="1.6" transfer-ownership="none">
        <doc xml:space="preserve">The current DNS processing mode.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="dns-rc-manager" version="1.6" transfer-ownership="none">
        <doc xml:space="preserve">The current resolv.conf management mode.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="hostname" transfer-ownership="none">
        <doc xml:space="preserve">The machine hostname stored in persistent configuration. This can be
modified by calling nm_client_save_hostname().</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="metered" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">Whether the connectivity is metered.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="networking-enabled"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Whether networking is enabled.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="nm-running" transfer-ownership="none">
        <doc xml:space="preserve">Whether the daemon is running.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="primary-connection" transfer-ownership="none">
        <doc xml:space="preserve">The #NMActiveConnection of the device with the default route;
see nm_client_get_primary_connection() for more details.</doc>
        <type name="ActiveConnection"/>
      </property>
      <property name="startup" transfer-ownership="none">
        <doc xml:space="preserve">Whether the daemon is still starting up.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="state" transfer-ownership="none">
        <doc xml:space="preserve">The current daemon state.</doc>
        <type name="State"/>
      </property>
      <property name="version" transfer-ownership="none">
        <doc xml:space="preserve">The NetworkManager version.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="wimax-enabled" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether WiMAX functionality is enabled.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="wimax-hardware-enabled" transfer-ownership="none">
        <doc xml:space="preserve">Whether the WiMAX hardware is enabled.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="wireless-enabled" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether wireless is enabled.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="wireless-hardware-enabled" transfer-ownership="none">
        <doc xml:space="preserve">Whether the wireless hardware is enabled.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="wwan-enabled" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether WWAN functionality is enabled.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="wwan-hardware-enabled" transfer-ownership="none">
        <doc xml:space="preserve">Whether the WWAN hardware is enabled.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="active-connection-added" when="first">
        <doc xml:space="preserve">Notifies that a #NMActiveConnection has been added.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="active_connection" transfer-ownership="none">
            <doc xml:space="preserve">the new active connection</doc>
            <type name="ActiveConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="active-connection-removed" when="first">
        <doc xml:space="preserve">Notifies that a #NMActiveConnection has been removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="active_connection" transfer-ownership="none">
            <doc xml:space="preserve">the removed active connection</doc>
            <type name="ActiveConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="any-device-added" when="first">
        <doc xml:space="preserve">Notifies that a #NMDevice is added.  This signal is emitted for both
regular devices and placeholder devices.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">the new device</doc>
            <type name="Device"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="any-device-removed" when="first">
        <doc xml:space="preserve">Notifies that a #NMDevice is removed.  This signal is emitted for both
regular devices and placeholder devices.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">the removed device</doc>
            <type name="Device"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="connection-added" when="first">
        <doc xml:space="preserve">Notifies that a #NMConnection has been added.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the new connection</doc>
            <type name="RemoteConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="connection-removed" when="first">
        <doc xml:space="preserve">Notifies that a #NMConnection has been removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the removed connection</doc>
            <type name="RemoteConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="device-added" when="first">
        <doc xml:space="preserve">Notifies that a #NMDevice is added.  This signal is not emitted for
placeholder devices.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">the new device</doc>
            <type name="Device"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="device-removed" when="first">
        <doc xml:space="preserve">Notifies that a #NMDevice is removed.  This signal is not emitted for
placeholder devices.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">the removed device</doc>
            <type name="Device"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="permission-changed" when="first">
        <doc xml:space="preserve">Notifies that a permission has changed</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="permission" transfer-ownership="none">
            <doc xml:space="preserve">a permission from #NMClientPermission</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the permission's result, one of #NMClientPermissionResult</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ClientClass"
            c:type="NMClientClass"
            glib:is-gtype-struct-for="Client">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="device_added">
        <callback name="device_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="client" transfer-ownership="none">
              <type name="Client" c:type="NMClient*"/>
            </parameter>
            <parameter name="device" transfer-ownership="none">
              <type name="Device" c:type="NMDevice*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="device_removed">
        <callback name="device_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="client" transfer-ownership="none">
              <type name="Client" c:type="NMClient*"/>
            </parameter>
            <parameter name="device" transfer-ownership="none">
              <type name="Device" c:type="NMDevice*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="any_device_added">
        <callback name="any_device_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="client" transfer-ownership="none">
              <type name="Client" c:type="NMClient*"/>
            </parameter>
            <parameter name="device" transfer-ownership="none">
              <type name="Device" c:type="NMDevice*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="any_device_removed">
        <callback name="any_device_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="client" transfer-ownership="none">
              <type name="Client" c:type="NMClient*"/>
            </parameter>
            <parameter name="device" transfer-ownership="none">
              <type name="Device" c:type="NMDevice*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="permission_changed">
        <callback name="permission_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="client" transfer-ownership="none">
              <type name="Client" c:type="NMClient*"/>
            </parameter>
            <parameter name="permission" transfer-ownership="none">
              <type name="ClientPermission" c:type="NMClientPermission"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <type name="ClientPermissionResult"
                    c:type="NMClientPermissionResult"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="connection_added">
        <callback name="connection_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="client" transfer-ownership="none">
              <type name="Client" c:type="NMClient*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="connection_removed">
        <callback name="connection_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="client" transfer-ownership="none">
              <type name="Client" c:type="NMClient*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="6">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="ClientError"
                 glib:type-name="NMClientError"
                 glib:get-type="nm_client_error_get_type"
                 c:type="NMClientError"
                 glib:error-domain="nm-client-error-quark">
      <doc xml:space="preserve">Describes errors that may result from operations involving a #NMClient.

D-Bus operations may also return errors from other domains, including
#NMManagerError, #NMSettingsError, #NMAgentManagerError, and #NMConnectionError.</doc>
      <member name="failed"
              value="0"
              c:identifier="NM_CLIENT_ERROR_FAILED"
              glib:nick="failed">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="manager_not_running"
              value="1"
              c:identifier="NM_CLIENT_ERROR_MANAGER_NOT_RUNNING"
              glib:nick="manager-not-running">
        <doc xml:space="preserve">an operation that requires NetworkManager
  failed because NetworkManager is not running</doc>
      </member>
      <member name="object_creation_failed"
              value="2"
              c:identifier="NM_CLIENT_ERROR_OBJECT_CREATION_FAILED"
              glib:nick="object-creation-failed">
        <doc xml:space="preserve">NetworkManager claimed that an
  operation succeeded, but the object that was allegedly created (eg,
  #NMRemoteConnection, #NMActiveConnection) was apparently destroyed before
  #NMClient could create a representation of it.</doc>
      </member>
      <function name="quark" c:identifier="nm_client_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMClient if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMClient errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <enumeration name="ClientPermission"
                 glib:type-name="NMClientPermission"
                 glib:get-type="nm_client_permission_get_type"
                 c:type="NMClientPermission">
      <doc xml:space="preserve">#NMClientPermission values indicate various permissions that NetworkManager
clients can obtain to perform certain tasks on behalf of the current user.</doc>
      <member name="none"
              value="0"
              c:identifier="NM_CLIENT_PERMISSION_NONE"
              glib:nick="none">
        <doc xml:space="preserve">unknown or no permission</doc>
      </member>
      <member name="enable_disable_network"
              value="1"
              c:identifier="NM_CLIENT_PERMISSION_ENABLE_DISABLE_NETWORK"
              glib:nick="enable-disable-network">
        <doc xml:space="preserve">controls whether networking
 can be globally enabled or disabled</doc>
      </member>
      <member name="enable_disable_wifi"
              value="2"
              c:identifier="NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIFI"
              glib:nick="enable-disable-wifi">
        <doc xml:space="preserve">controls whether Wi-Fi can be
 globally enabled or disabled</doc>
      </member>
      <member name="enable_disable_wwan"
              value="3"
              c:identifier="NM_CLIENT_PERMISSION_ENABLE_DISABLE_WWAN"
              glib:nick="enable-disable-wwan">
        <doc xml:space="preserve">controls whether WWAN (3G) can be
 globally enabled or disabled</doc>
      </member>
      <member name="enable_disable_wimax"
              value="4"
              c:identifier="NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIMAX"
              glib:nick="enable-disable-wimax">
        <doc xml:space="preserve">controls whether WiMAX can be
 globally enabled or disabled</doc>
      </member>
      <member name="sleep_wake"
              value="5"
              c:identifier="NM_CLIENT_PERMISSION_SLEEP_WAKE"
              glib:nick="sleep-wake">
        <doc xml:space="preserve">controls whether the client can ask
 NetworkManager to sleep and wake</doc>
      </member>
      <member name="network_control"
              value="6"
              c:identifier="NM_CLIENT_PERMISSION_NETWORK_CONTROL"
              glib:nick="network-control">
        <doc xml:space="preserve">controls whether networking connections
 can be started, stopped, and changed</doc>
      </member>
      <member name="wifi_share_protected"
              value="7"
              c:identifier="NM_CLIENT_PERMISSION_WIFI_SHARE_PROTECTED"
              glib:nick="wifi-share-protected">
        <doc xml:space="preserve">controls whether a password
 protected Wi-Fi hotspot can be created</doc>
      </member>
      <member name="wifi_share_open"
              value="8"
              c:identifier="NM_CLIENT_PERMISSION_WIFI_SHARE_OPEN"
              glib:nick="wifi-share-open">
        <doc xml:space="preserve">controls whether an open Wi-Fi hotspot
 can be created</doc>
      </member>
      <member name="settings_modify_system"
              value="9"
              c:identifier="NM_CLIENT_PERMISSION_SETTINGS_MODIFY_SYSTEM"
              glib:nick="settings-modify-system">
        <doc xml:space="preserve">controls whether connections
 that are available to all users can be modified</doc>
      </member>
      <member name="settings_modify_own"
              value="10"
              c:identifier="NM_CLIENT_PERMISSION_SETTINGS_MODIFY_OWN"
              glib:nick="settings-modify-own">
        <doc xml:space="preserve">controls whether connections
 owned by the current user can be modified</doc>
      </member>
      <member name="settings_modify_hostname"
              value="11"
              c:identifier="NM_CLIENT_PERMISSION_SETTINGS_MODIFY_HOSTNAME"
              glib:nick="settings-modify-hostname">
        <doc xml:space="preserve">controls whether the
 persistent hostname can be changed</doc>
      </member>
      <member name="settings_modify_global_dns"
              value="12"
              c:identifier="NM_CLIENT_PERMISSION_SETTINGS_MODIFY_GLOBAL_DNS"
              glib:nick="settings-modify-global-dns">
        <doc xml:space="preserve">modify persistent global
 DNS configuration</doc>
      </member>
      <member name="reload"
              value="13"
              c:identifier="NM_CLIENT_PERMISSION_RELOAD"
              glib:nick="reload">
        <doc xml:space="preserve">controls access to Reload.</doc>
      </member>
      <member name="checkpoint_rollback"
              value="14"
              c:identifier="NM_CLIENT_PERMISSION_CHECKPOINT_ROLLBACK"
              glib:nick="checkpoint-rollback">
        <doc xml:space="preserve">permission to create checkpoints.</doc>
      </member>
      <member name="enable_disable_statistics"
              value="15"
              c:identifier="NM_CLIENT_PERMISSION_ENABLE_DISABLE_STATISTICS"
              glib:nick="enable-disable-statistics">
        <doc xml:space="preserve">controls whether device
 statistics can be globally enabled or disabled</doc>
      </member>
      <member name="last"
              value="15"
              c:identifier="NM_CLIENT_PERMISSION_LAST"
              glib:nick="last">
        <doc xml:space="preserve">a reserved boundary value</doc>
      </member>
    </enumeration>
    <enumeration name="ClientPermissionResult"
                 glib:type-name="NMClientPermissionResult"
                 glib:get-type="nm_client_permission_result_get_type"
                 c:type="NMClientPermissionResult">
      <doc xml:space="preserve">#NMClientPermissionResult values indicate what authorizations and permissions
the user requires to obtain a given #NMClientPermission</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_CLIENT_PERMISSION_RESULT_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">unknown or no authorization</doc>
      </member>
      <member name="yes"
              value="1"
              c:identifier="NM_CLIENT_PERMISSION_RESULT_YES"
              glib:nick="yes">
        <doc xml:space="preserve">the permission is available</doc>
      </member>
      <member name="auth"
              value="2"
              c:identifier="NM_CLIENT_PERMISSION_RESULT_AUTH"
              glib:nick="auth">
        <doc xml:space="preserve">authorization is necessary before the
 permission is available</doc>
      </member>
      <member name="no"
              value="3"
              c:identifier="NM_CLIENT_PERMISSION_RESULT_NO"
              glib:nick="no">
        <doc xml:space="preserve">permission to perform the operation is
 denied by system policy</doc>
      </member>
    </enumeration>
    <interface name="Connection"
               c:symbol-prefix="connection"
               c:type="NMConnection"
               glib:type-name="NMConnection"
               glib:get-type="nm_connection_get_type"
               glib:type-struct="ConnectionInterface">
      <doc xml:space="preserve">NMConnection is the interface implemented by #NMRemoteConnection on the
client side, and #NMSettingsConnection on the daemon side.</doc>
      <virtual-method name="changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="secrets_cleared">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="secrets_updated">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="setting" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_setting" c:identifier="nm_connection_add_setting">
        <doc xml:space="preserve">Adds a #NMSetting to the connection, replacing any previous #NMSetting of the
same name which has previously been added to the #NMConnection.  The
connection takes ownership of the #NMSetting object and does not increase
the setting object's reference count.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="setting" transfer-ownership="full">
            <doc xml:space="preserve">the #NMSetting to add to the connection object</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_secrets" c:identifier="nm_connection_clear_secrets">
        <doc xml:space="preserve">Clears and frees any secrets that may be stored in the connection, to avoid
keeping secret data in memory when not needed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear_secrets_with_flags"
              c:identifier="nm_connection_clear_secrets_with_flags">
        <doc xml:space="preserve">Clears and frees secrets determined by @func.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">function to be called to determine whether a
    specific secret should be cleared or not</doc>
            <type name="SettingClearSecretsWithFlagsFn"
                  c:type="NMSettingClearSecretsWithFlagsFn"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">caller-supplied data passed to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_settings"
              c:identifier="nm_connection_clear_settings">
        <doc xml:space="preserve">Deletes all of @connection's settings.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="compare" c:identifier="nm_connection_compare">
        <doc xml:space="preserve">Compares two #NMConnection objects for similarity, with comparison behavior
modified by a set of flags.  See nm_setting_compare() for a description of
each flag's behavior.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the comparison succeeds, %FALSE if it does not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a second #NMConnection to compare with the first</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">compare flags, e.g. %NM_SETTING_COMPARE_FLAG_EXACT</doc>
            <type name="SettingCompareFlags" c:type="NMSettingCompareFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="diff" c:identifier="nm_connection_diff">
        <doc xml:space="preserve">Compares two #NMConnection objects for similarity, with comparison behavior
modified by a set of flags.  See nm_setting_compare() for a description of
each flag's behavior.  If the connections differ, settings and keys within
each setting that differ are added to the returned @out_settings hash table.
No values are returned, only key names.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connections contain the same values, %FALSE if they do
not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a second #NMConnection to compare with the first</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">compare flags, e.g. %NM_SETTING_COMPARE_FLAG_EXACT</doc>
            <type name="SettingCompareFlags" c:type="NMSettingCompareFlags"/>
          </parameter>
          <parameter name="out_settings" transfer-ownership="none">
            <doc xml:space="preserve">if the
connections differ, on return a hash table mapping setting names to
second-level GHashTable (utf8 to guint32), which contains the key names that
differ mapped to one or more of %NMSettingDiffResult as a bitfield</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="utf8"/>
              <type name="GLib.HashTable">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="dump" c:identifier="nm_connection_dump">
        <doc xml:space="preserve">Print the connection to stdout.  For debugging purposes ONLY, should NOT
be used for serialization of the connection or machine-parsed in any way. The
output format is not guaranteed to be stable and may change at any time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="for_each_setting_value"
              c:identifier="nm_connection_for_each_setting_value">
        <doc xml:space="preserve">Iterates over the properties of each #NMSetting object in the #NMConnection,
calling the supplied user function for each property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">user-supplied function called for each setting's property</doc>
            <type name="SettingValueIterFn" c:type="NMSettingValueIterFn"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data passed to @func at each invocation</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_connection_type"
              c:identifier="nm_connection_get_connection_type">
        <doc xml:space="preserve">A shortcut to return the type from the connection's #NMSettingConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type from the connection's 'connection' setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_id" c:identifier="nm_connection_get_id">
        <doc xml:space="preserve">A shortcut to return the ID from the connection's #NMSettingConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the ID from the connection's 'connection' setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_interface_name"
              c:identifier="nm_connection_get_interface_name">
        <doc xml:space="preserve">Returns the interface name as stored in NMSettingConnection:interface_name.
If the connection contains no NMSettingConnection, it will return %NULL.

For hardware devices and software devices created outside of NetworkManager,
this name is used to match the device. for software devices created by
NetworkManager, this is the name of the created interface.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Name of the kernel interface or %NULL</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_path" c:identifier="nm_connection_get_path">
        <doc xml:space="preserve">Returns the connection's D-Bus path.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the D-Bus path of the connection, previously set by a call to
nm_connection_set_path().</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting" c:identifier="nm_connection_get_setting">
        <doc xml:space="preserve">Gets the #NMSetting with the given #GType, if one has been previously added
to the #NMConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSetting, or %NULL if no setting of that type was previously
added to the #NMConnection</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="setting_type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of the setting object to return</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_setting_802_1x"
              c:identifier="nm_connection_get_setting_802_1x">
        <doc xml:space="preserve">A shortcut to return any #NMSetting8021x the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSetting8021x if the connection contains one, otherwise %NULL</doc>
          <type name="Setting8021x" c:type="NMSetting8021x*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_adsl"
              c:identifier="nm_connection_get_setting_adsl">
        <doc xml:space="preserve">A shortcut to return any #NMSettingAdsl the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingAdsl if the connection contains one, otherwise %NULL</doc>
          <type name="SettingAdsl" c:type="NMSettingAdsl*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_bluetooth"
              c:identifier="nm_connection_get_setting_bluetooth">
        <doc xml:space="preserve">A shortcut to return any #NMSettingBluetooth the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingBluetooth if the connection contains one, otherwise %NULL</doc>
          <type name="SettingBluetooth" c:type="NMSettingBluetooth*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_bond"
              c:identifier="nm_connection_get_setting_bond">
        <doc xml:space="preserve">A shortcut to return any #NMSettingBond the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingBond if the connection contains one, otherwise %NULL</doc>
          <type name="SettingBond" c:type="NMSettingBond*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_bridge"
              c:identifier="nm_connection_get_setting_bridge">
        <doc xml:space="preserve">A shortcut to return any #NMSettingBridge the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingBridge if the connection contains one, otherwise %NULL</doc>
          <type name="SettingBridge" c:type="NMSettingBridge*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_bridge_port"
              c:identifier="nm_connection_get_setting_bridge_port">
        <doc xml:space="preserve">A shortcut to return any #NMSettingBridgePort the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingBridgePort if the connection contains one, otherwise %NULL</doc>
          <type name="SettingBridgePort" c:type="NMSettingBridgePort*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_by_name"
              c:identifier="nm_connection_get_setting_by_name">
        <doc xml:space="preserve">Gets the #NMSetting with the given name, if one has been previously added
the #NMConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSetting, or %NULL if no setting with that name was previously
added to the #NMConnection</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a setting name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_setting_cdma"
              c:identifier="nm_connection_get_setting_cdma">
        <doc xml:space="preserve">A shortcut to return any #NMSettingCdma the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingCdma if the connection contains one, otherwise %NULL</doc>
          <type name="SettingCdma" c:type="NMSettingCdma*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_connection"
              c:identifier="nm_connection_get_setting_connection">
        <doc xml:space="preserve">A shortcut to return any #NMSettingConnection the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingConnection if the connection contains one, otherwise %NULL</doc>
          <type name="SettingConnection" c:type="NMSettingConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_dcb"
              c:identifier="nm_connection_get_setting_dcb">
        <doc xml:space="preserve">A shortcut to return any #NMSettingDcb the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingDcb if the connection contains one, otherwise NULL</doc>
          <type name="SettingDcb" c:type="NMSettingDcb*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_dummy"
              c:identifier="nm_connection_get_setting_dummy"
              version="1.8">
        <doc xml:space="preserve">A shortcut to return any #NMSettingDummy the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingDummy if the connection contains one, otherwise %NULL</doc>
          <type name="SettingDummy" c:type="NMSettingDummy*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_generic"
              c:identifier="nm_connection_get_setting_generic">
        <doc xml:space="preserve">A shortcut to return any #NMSettingGeneric the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingGeneric if the connection contains one, otherwise NULL</doc>
          <type name="SettingGeneric" c:type="NMSettingGeneric*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_gsm"
              c:identifier="nm_connection_get_setting_gsm">
        <doc xml:space="preserve">A shortcut to return any #NMSettingGsm the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingGsm if the connection contains one, otherwise %NULL</doc>
          <type name="SettingGsm" c:type="NMSettingGsm*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_infiniband"
              c:identifier="nm_connection_get_setting_infiniband">
        <doc xml:space="preserve">A shortcut to return any #NMSettingInfiniband the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingInfiniband if the connection contains one, otherwise %NULL</doc>
          <type name="SettingInfiniband" c:type="NMSettingInfiniband*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_ip4_config"
              c:identifier="nm_connection_get_setting_ip4_config">
        <doc xml:space="preserve">A shortcut to return any #NMSettingIP4Config the connection might contain.

Note that it returns the value as type #NMSettingIPConfig, since the vast
majority of IPv4-setting-related methods are on that type, not
#NMSettingIP4Config.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingIP4Config if the
connection contains one, otherwise %NULL</doc>
          <type name="SettingIP4Config" c:type="NMSettingIPConfig*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_ip6_config"
              c:identifier="nm_connection_get_setting_ip6_config">
        <doc xml:space="preserve">A shortcut to return any #NMSettingIP6Config the connection might contain.

Note that it returns the value as type #NMSettingIPConfig, since the vast
majority of IPv6-setting-related methods are on that type, not
#NMSettingIP6Config.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingIP6Config if the
connection contains one, otherwise %NULL</doc>
          <type name="SettingIP6Config" c:type="NMSettingIPConfig*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_ip_tunnel"
              c:identifier="nm_connection_get_setting_ip_tunnel"
              version="1.2">
        <doc xml:space="preserve">A shortcut to return any #NMSettingIPTunnel the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingIPTunnel if the connection contains one, otherwise %NULL</doc>
          <type name="SettingIPTunnel" c:type="NMSettingIPTunnel*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_macsec"
              c:identifier="nm_connection_get_setting_macsec"
              version="1.6">
        <doc xml:space="preserve">A shortcut to return any #NMSettingMacsec the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingMacsec if the connection contains one, otherwise %NULL</doc>
          <type name="SettingMacsec" c:type="NMSettingMacsec*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_macvlan"
              c:identifier="nm_connection_get_setting_macvlan"
              version="1.2">
        <doc xml:space="preserve">A shortcut to return any #NMSettingMacvlan the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingMacvlan if the connection contains one, otherwise %NULL</doc>
          <type name="SettingMacvlan" c:type="NMSettingMacvlan*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_olpc_mesh"
              c:identifier="nm_connection_get_setting_olpc_mesh">
        <doc xml:space="preserve">A shortcut to return any #NMSettingOlpcMesh the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingOlpcMesh if the connection contains one, otherwise %NULL</doc>
          <type name="SettingOlpcMesh" c:type="NMSettingOlpcMesh*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_ppp"
              c:identifier="nm_connection_get_setting_ppp">
        <doc xml:space="preserve">A shortcut to return any #NMSettingPpp the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingPpp if the connection contains one, otherwise %NULL</doc>
          <type name="SettingPpp" c:type="NMSettingPpp*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_pppoe"
              c:identifier="nm_connection_get_setting_pppoe">
        <doc xml:space="preserve">A shortcut to return any #NMSettingPppoe the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingPppoe if the connection contains one, otherwise %NULL</doc>
          <type name="SettingPppoe" c:type="NMSettingPppoe*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_proxy"
              c:identifier="nm_connection_get_setting_proxy"
              version="1.6">
        <doc xml:space="preserve">A shortcut to return any #NMSettingProxy the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingProxy if the connection contains one, otherwise %NULL</doc>
          <type name="SettingProxy" c:type="NMSettingProxy*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_serial"
              c:identifier="nm_connection_get_setting_serial">
        <doc xml:space="preserve">A shortcut to return any #NMSettingSerial the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingSerial if the connection contains one, otherwise %NULL</doc>
          <type name="SettingSerial" c:type="NMSettingSerial*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_team"
              c:identifier="nm_connection_get_setting_team">
        <doc xml:space="preserve">A shortcut to return any #NMSettingTeam the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingTeam if the connection contains one, otherwise %NULL</doc>
          <type name="SettingTeam" c:type="NMSettingTeam*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_team_port"
              c:identifier="nm_connection_get_setting_team_port">
        <doc xml:space="preserve">A shortcut to return any #NMSettingTeamPort the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingTeamPort if the connection contains one, otherwise %NULL</doc>
          <type name="SettingTeamPort" c:type="NMSettingTeamPort*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_tun"
              c:identifier="nm_connection_get_setting_tun"
              version="1.2">
        <doc xml:space="preserve">A shortcut to return any #NMSettingTun the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingTun if the connection contains one, otherwise %NULL</doc>
          <type name="SettingTun" c:type="NMSettingTun*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_vlan"
              c:identifier="nm_connection_get_setting_vlan">
        <doc xml:space="preserve">A shortcut to return any #NMSettingVlan the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingVlan if the connection contains one, otherwise %NULL</doc>
          <type name="SettingVlan" c:type="NMSettingVlan*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_vpn"
              c:identifier="nm_connection_get_setting_vpn">
        <doc xml:space="preserve">A shortcut to return any #NMSettingVpn the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingVpn if the connection contains one, otherwise %NULL</doc>
          <type name="SettingVpn" c:type="NMSettingVpn*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_vxlan"
              c:identifier="nm_connection_get_setting_vxlan"
              version="1.2">
        <doc xml:space="preserve">A shortcut to return any #NMSettingVxlan the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingVxlan if the connection contains one, otherwise %NULL</doc>
          <type name="SettingVxlan" c:type="NMSettingVxlan*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_wimax"
              c:identifier="nm_connection_get_setting_wimax">
        <doc xml:space="preserve">A shortcut to return any #NMSettingWimax the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingWimax if the connection contains one, otherwise %NULL</doc>
          <type name="SettingWimax" c:type="NMSettingWimax*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_wired"
              c:identifier="nm_connection_get_setting_wired">
        <doc xml:space="preserve">A shortcut to return any #NMSettingWired the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingWired if the connection contains one, otherwise %NULL</doc>
          <type name="SettingWired" c:type="NMSettingWired*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_wireless"
              c:identifier="nm_connection_get_setting_wireless">
        <doc xml:space="preserve">A shortcut to return any #NMSettingWireless the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingWireless if the connection contains one, otherwise %NULL</doc>
          <type name="SettingWireless" c:type="NMSettingWireless*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_wireless_security"
              c:identifier="nm_connection_get_setting_wireless_security">
        <doc xml:space="preserve">A shortcut to return any #NMSettingWirelessSecurity the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingWirelessSecurity if the connection contains one, otherwise %NULL</doc>
          <type name="SettingWirelessSecurity"
                c:type="NMSettingWirelessSecurity*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uuid" c:identifier="nm_connection_get_uuid">
        <doc xml:space="preserve">A shortcut to return the UUID from the connection's #NMSettingConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the UUID from the connection's 'connection' setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_virtual_device_description"
              c:identifier="nm_connection_get_virtual_device_description">
        <doc xml:space="preserve">Returns the name that nm_device_disambiguate_names() would
return for the virtual device that would be created for @connection.
Eg, "VLAN (eth1.1)".</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the name of @connection's device,
  or %NULL if @connection is not a virtual connection type</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">an #NMConnection for a virtual device type</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_type" c:identifier="nm_connection_is_type">
        <doc xml:space="preserve">A convenience function to check if the given @connection is a particular
type (ie wired, Wi-Fi, ppp, etc). Checks the #NMSettingConnection:type
property of the connection and matches that against @type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection is of the given @type, %FALSE if not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a setting name to check the connection's type against (like
%NM_SETTING_WIRELESS_SETTING_NAME or %NM_SETTING_WIRED_SETTING_NAME)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_virtual" c:identifier="nm_connection_is_virtual">
        <doc xml:space="preserve">Checks if @connection refers to a virtual device (and thus can potentially be
activated even if the device it refers to doesn't exist).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @connection refers to a virtual device</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">an #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="need_secrets" c:identifier="nm_connection_need_secrets">
        <doc xml:space="preserve">Returns the name of the first setting object in the connection which would
need secrets to make a successful connection.  The returned hints are only
intended as a guide to what secrets may be required, because in some
circumstances, there is no way to conclusively determine exactly which
secrets are needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the setting name of the #NMSetting object which has invalid or
  missing secrets</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="hints"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="container"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">
  the address of a pointer to a #GPtrArray, initialized to %NULL, which on
  return points to an allocated #GPtrArray containing the property names of
  secrets of the #NMSetting which may be required; the caller owns the array
  and must free the array itself with g_ptr_array_free(), but not free its
  elements</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="normalize"
              c:identifier="nm_connection_normalize"
              throws="1">
        <doc xml:space="preserve">Does some basic normalization and fixup of well known inconsistencies
and deprecated fields. If the connection was modified in any way,
the output parameter @modified is set %TRUE.

Finally the connection will be verified and %TRUE returns if the connection
is valid. As this function only performs some specific normalization steps
it cannot repair all connections. If the connection has errors that
cannot be normalized, the connection will not be modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection is valid, %FALSE if it is not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection to normalize</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="parameters"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GHashTable with
normalization parameters to allow customization of the normalization by providing
specific arguments. Unknown arguments will be ignored and the default will be
used. The keys must be strings, hashed by g_str_hash() and g_str_equal() functions.
The values are opaque and depend on the parameter name.</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="gpointer"/>
            </type>
          </parameter>
          <parameter name="modified"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">outputs whether any settings were modified.</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_setting"
              c:identifier="nm_connection_remove_setting">
        <doc xml:space="preserve">Removes the #NMSetting with the given #GType from the #NMConnection.  This
operation dereferences the #NMSetting object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="setting_type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of the setting object to remove</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_settings"
              c:identifier="nm_connection_replace_settings"
              throws="1">
        <doc xml:space="preserve">Replaces @connection's settings with @new_settings (which must be
syntactically valid, and describe a known type of connection, but does not
need to result in a connection that passes nm_connection_verify()).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if connection was updated, %FALSE if @new_settings could not
  be deserialized (in which case @connection will be unchanged).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="new_settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant of type %NM_VARIANT_TYPE_CONNECTION, with the new settings</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_settings_from_connection"
              c:identifier="nm_connection_replace_settings_from_connection">
        <doc xml:space="preserve">Deep-copies the settings of @new_connection and replaces the settings of @connection
with the copied settings.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="new_connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection to replace the settings of @connection with</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_path" c:identifier="nm_connection_set_path">
        <doc xml:space="preserve">Sets the D-Bus path of the connection.  This property is not serialized, and
is only for the reference of the caller.  Sets the #NMConnection:path
property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the D-Bus path of the connection as given by the settings service
which provides the connection</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_dbus" c:identifier="nm_connection_to_dbus">
        <doc xml:space="preserve">Converts the #NMConnection into a #GVariant of type
%NM_VARIANT_TYPE_CONNECTION describing the connection, suitable for
marshalling over D-Bus or otherwise serializing.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a new floating #GVariant describing the connection,
its settings, and each setting's properties.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">serialization flags, e.g. %NM_CONNECTION_SERIALIZE_ALL</doc>
            <type name="ConnectionSerializationFlags"
                  c:type="NMConnectionSerializationFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_secrets"
              c:identifier="nm_connection_update_secrets"
              throws="1">
        <doc xml:space="preserve">Update the specified setting's secrets, given a dictionary of secrets
intended for that setting (deserialized from D-Bus for example).  Will also
extract the given setting's secrets hash if given a connection dictionary.
If @setting_name is %NULL, expects a fully serialized #NMConnection as
returned by nm_connection_to_dbus() and will update all secrets from all
settings contained in @secrets.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the secrets were successfully updated, %FALSE if the update
failed (tried to update secrets for a setting that doesn't exist, etc)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="setting_name" transfer-ownership="none">
            <doc xml:space="preserve">the setting object name to which the secrets apply</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="secrets" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant of secrets, of type %NM_VARIANT_TYPE_CONNECTION
  or %NM_VARIANT_TYPE_SETTING</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="verify" c:identifier="nm_connection_verify" throws="1">
        <doc xml:space="preserve">Validates the connection and all its settings.  Each setting's properties
have allowed values, and some values are dependent on other values.  For
example, if a Wi-Fi connection is security enabled, the #NMSettingWireless
setting object's 'security' property must contain the setting name of the
#NMSettingWirelessSecurity object, which must also be present in the
connection for the connection to be valid.  As another example, the
#NMSettingWired object's 'mac-address' property must be a validly formatted
MAC address.  The returned #GError contains information about which
setting and which property failed validation, and how it failed validation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection is valid, %FALSE if it is not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection to verify</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="verify_secrets"
              c:identifier="nm_connection_verify_secrets"
              version="1.2"
              throws="1">
        <doc xml:space="preserve">Verifies the secrets in the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the secrets are valid, %FALSE if they are not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection to verify in</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <glib:signal name="changed" when="first">
        <doc xml:space="preserve">The ::changed signal is emitted when any property of any property
(including secrets) of any setting of the connection is modified,
or when settings are added or removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="secrets-cleared" when="first">
        <doc xml:space="preserve">The ::secrets-cleared signal is emitted when the secrets of a connection
are cleared.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="secrets-updated" when="first">
        <doc xml:space="preserve">The ::secrets-updated signal is emitted when the secrets of a setting
have been changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="setting_name" transfer-ownership="none">
            <doc xml:space="preserve">the setting name of the #NMSetting for which secrets were
updated</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
    </interface>
    <enumeration name="ConnectionError"
                 glib:type-name="NMConnectionError"
                 glib:get-type="nm_connection_error_get_type"
                 c:type="NMConnectionError"
                 glib:error-domain="nm-connection-error-quark">
      <doc xml:space="preserve">Describes errors that may result from operations involving a #NMConnection
or its #NMSettings.

These errors may be returned directly from #NMConnection and #NMSetting
methods, or may be returned from D-Bus operations (eg on #NMClient or
#NMDevice), where they correspond to errors in the
"org.freedesktop.NetworkManager.Settings.Connection" namespace.</doc>
      <member name="Failed"
              value="0"
              c:identifier="NM_CONNECTION_ERROR_FAILED"
              glib:nick="Failed">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="SettingNotFound"
              value="1"
              c:identifier="NM_CONNECTION_ERROR_SETTING_NOT_FOUND"
              glib:nick="SettingNotFound">
        <doc xml:space="preserve">the #NMConnection object
  did not contain the specified #NMSetting object</doc>
      </member>
      <member name="PropertyNotFound"
              value="2"
              c:identifier="NM_CONNECTION_ERROR_PROPERTY_NOT_FOUND"
              glib:nick="PropertyNotFound">
        <doc xml:space="preserve">the #NMConnection did not contain the
  requested #NMSetting property</doc>
      </member>
      <member name="PropertyNotSecret"
              value="3"
              c:identifier="NM_CONNECTION_ERROR_PROPERTY_NOT_SECRET"
              glib:nick="PropertyNotSecret">
        <doc xml:space="preserve">an operation which requires a secret
  was attempted on a non-secret property</doc>
      </member>
      <member name="MissingSetting"
              value="4"
              c:identifier="NM_CONNECTION_ERROR_MISSING_SETTING"
              glib:nick="MissingSetting">
        <doc xml:space="preserve">the #NMConnection object is missing an
  #NMSetting which is required for its configuration. The error message will
  always be prefixed with "&amp;lt;setting-name&gt;: ", where "&amp;lt;setting-name&gt;" is the
  name of the setting that is missing.</doc>
      </member>
      <member name="InvalidSetting"
              value="5"
              c:identifier="NM_CONNECTION_ERROR_INVALID_SETTING"
              glib:nick="InvalidSetting">
        <doc xml:space="preserve">the #NMConnection object contains an
  invalid or inappropriate #NMSetting. The error message will always be
  prefixed with "&amp;lt;setting-name&gt;: ", where "&amp;lt;setting-name&gt;" is the name of the
  setting that is invalid.</doc>
      </member>
      <member name="MissingProperty"
              value="6"
              c:identifier="NM_CONNECTION_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the #NMConnection object is invalid
  because it is missing a required property. The error message will always be
  prefixed with "&amp;lt;setting-name&gt;.&amp;lt;property-name&gt;: ", where "&amp;lt;setting-name&gt;" is
  the name of the setting with the missing property, and "&amp;lt;property-name&gt;" is
  the property that is missing.</doc>
      </member>
      <member name="InvalidProperty"
              value="7"
              c:identifier="NM_CONNECTION_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the #NMConnection object is invalid
  because a property has an invalid value. The error message will always be
  prefixed with "&amp;lt;setting-name&gt;.&amp;lt;property-name&gt;: ", where "&amp;lt;setting-name&gt;" is
  the name of the setting with the invalid property, and "&amp;lt;property-name&gt;" is
  the property that is invalid.</doc>
      </member>
      <function name="quark" c:identifier="nm_connection_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <record name="ConnectionInterface"
            c:type="NMConnectionInterface"
            glib:is-gtype-struct-for="Connection">
      <field name="parent">
        <doc xml:space="preserve">the parent interace struct</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="secrets_updated">
        <callback name="secrets_updated">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="connection" transfer-ownership="none">
              <type name="Connection" c:type="NMConnection*"/>
            </parameter>
            <parameter name="setting" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="secrets_cleared">
        <callback name="secrets_cleared">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="connection" transfer-ownership="none">
              <type name="Connection" c:type="NMConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="changed">
        <callback name="changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="connection" transfer-ownership="none">
              <type name="Connection" c:type="NMConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <bitfield name="ConnectionSerializationFlags"
              glib:type-name="NMConnectionSerializationFlags"
              glib:get-type="nm_connection_serialization_flags_get_type"
              c:type="NMConnectionSerializationFlags">
      <doc xml:space="preserve">These flags determine which properties are serialized when calling when
calling nm_connection_to_dbus().</doc>
      <member name="all"
              value="0"
              c:identifier="NM_CONNECTION_SERIALIZE_ALL"
              glib:nick="all">
        <doc xml:space="preserve">serialize all properties (including secrets)</doc>
      </member>
      <member name="no_secrets"
              value="1"
              c:identifier="NM_CONNECTION_SERIALIZE_NO_SECRETS"
              glib:nick="no-secrets">
        <doc xml:space="preserve">do not include secrets</doc>
      </member>
      <member name="only_secrets"
              value="2"
              c:identifier="NM_CONNECTION_SERIALIZE_ONLY_SECRETS"
              glib:nick="only-secrets">
        <doc xml:space="preserve">only serialize secrets</doc>
      </member>
    </bitfield>
    <enumeration name="ConnectivityState"
                 glib:type-name="NMConnectivityState"
                 glib:get-type="nm_connectivity_state_get_type"
                 c:type="NMConnectivityState">
      <member name="unknown"
              value="0"
              c:identifier="NM_CONNECTIVITY_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">Network connectivity is unknown. This means the
  connectivity checks are disabled (e.g. on server installations) or has
  not run yet. The graphical shell should assume the Internet connection
  might be available and not present a captive portal window.</doc>
      </member>
      <member name="none"
              value="1"
              c:identifier="NM_CONNECTIVITY_NONE"
              glib:nick="none">
        <doc xml:space="preserve">The host is not connected to any network. There's
  no active connection that contains a default route to the internet and
  thus it makes no sense to even attempt a connectivity check. The graphical
  shell should use this state to indicate the network connection is unavailable.</doc>
      </member>
      <member name="portal"
              value="2"
              c:identifier="NM_CONNECTIVITY_PORTAL"
              glib:nick="portal">
        <doc xml:space="preserve">The Internet connection is hijacked by a captive
  portal gateway. The graphical shell may open a sandboxed web browser window
  (because the captive portals typically attempt a man-in-the-middle attacks
  agains the https connections) for the purpose of authenticating to a gateway
  and retrigger the connectivity check with CheckConnectivity() when the
  browser window is dismissed.</doc>
      </member>
      <member name="limited"
              value="3"
              c:identifier="NM_CONNECTIVITY_LIMITED"
              glib:nick="limited">
        <doc xml:space="preserve">The host is connected to a network, does not appear
  to be able to reach the full Internet, but a captive portal has not been
  detected.</doc>
      </member>
      <member name="full"
              value="4"
              c:identifier="NM_CONNECTIVITY_FULL"
              glib:nick="full">
        <doc xml:space="preserve">The host is connected to a network, and
  appears to be able to reach the full Internet.</doc>
      </member>
    </enumeration>
    <enumeration name="CryptoError"
                 glib:type-name="NMCryptoError"
                 glib:get-type="nm_crypto_error_get_type"
                 c:type="NMCryptoError"
                 glib:error-domain="nm-crypto-error-quark">
      <doc xml:space="preserve">Cryptography-related errors that can be returned from some nm-utils methods,
and some #NMSetting8021x operations.</doc>
      <member name="failed"
              value="0"
              c:identifier="NM_CRYPTO_ERROR_FAILED"
              glib:nick="failed">
        <doc xml:space="preserve">generic failure</doc>
      </member>
      <member name="invalid_data"
              value="1"
              c:identifier="NM_CRYPTO_ERROR_INVALID_DATA"
              glib:nick="invalid-data">
        <doc xml:space="preserve">the certificate or key data provided
  was invalid</doc>
      </member>
      <member name="invalid_password"
              value="2"
              c:identifier="NM_CRYPTO_ERROR_INVALID_PASSWORD"
              glib:nick="invalid-password">
        <doc xml:space="preserve">the password was invalid</doc>
      </member>
      <member name="unknown_cipher"
              value="3"
              c:identifier="NM_CRYPTO_ERROR_UNKNOWN_CIPHER"
              glib:nick="unknown-cipher">
        <doc xml:space="preserve">the data uses an unknown cipher</doc>
      </member>
      <member name="decryption_failed"
              value="4"
              c:identifier="NM_CRYPTO_ERROR_DECRYPTION_FAILED"
              glib:nick="decryption-failed">
        <doc xml:space="preserve">decryption failed</doc>
      </member>
      <member name="encryption_failed"
              value="5"
              c:identifier="NM_CRYPTO_ERROR_ENCRYPTION_FAILED"
              glib:nick="encryption-failed">
        <doc xml:space="preserve">encryption failed</doc>
      </member>
      <function name="quark" c:identifier="nm_crypto_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <constant name="DBUS_INTERFACE"
              value="org.freedesktop.NetworkManager"
              c:type="NM_DBUS_INTERFACE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_INTERFACE_DNS_MANAGER"
              value="org.freedesktop.NetworkManager.DnsManager"
              c:type="NM_DBUS_INTERFACE_DNS_MANAGER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_INTERFACE_SETTINGS"
              value="org.freedesktop.NetworkManager.Settings"
              c:type="NM_DBUS_INTERFACE_SETTINGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_INTERFACE_SETTINGS_CONNECTION"
              value="org.freedesktop.NetworkManager.Settings.Connection"
              c:type="NM_DBUS_INTERFACE_SETTINGS_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_INTERFACE_SETTINGS_CONNECTION_SECRETS"
              value="org.freedesktop.NetworkManager.Settings.Connection.Secrets"
              c:type="NM_DBUS_INTERFACE_SETTINGS_CONNECTION_SECRETS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_INTERFACE_VPN"
              value="org.freedesktop.NetworkManager.VPN.Manager"
              c:type="NM_DBUS_INTERFACE_VPN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_INTERFACE_VPN_CONNECTION"
              value="org.freedesktop.NetworkManager.VPN.Connection"
              c:type="NM_DBUS_INTERFACE_VPN_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_INVALID_VPN_CONNECTION"
              value="org.freedesktop.NetworkManager.VPNConnections.InvalidVPNConnection"
              c:type="NM_DBUS_INVALID_VPN_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_NO_ACTIVE_VPN_CONNECTION"
              value="org.freedesktop.NetworkManager.VPNConnections.NoActiveVPNConnection"
              c:type="NM_DBUS_NO_ACTIVE_VPN_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_NO_VPN_CONNECTIONS"
              value="org.freedesktop.NetworkManager.VPNConnections.NoVPNConnections"
              c:type="NM_DBUS_NO_VPN_CONNECTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_PATH"
              value="/org/freedesktop/NetworkManager"
              c:type="NM_DBUS_PATH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_PATH_AGENT_MANAGER"
              value="/org/freedesktop/NetworkManager/AgentManager"
              c:type="NM_DBUS_PATH_AGENT_MANAGER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_PATH_DNS_MANAGER"
              value="/org/freedesktop/NetworkManager/DnsManager"
              c:type="NM_DBUS_PATH_DNS_MANAGER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_PATH_SECRET_AGENT"
              value="/org/freedesktop/NetworkManager/SecretAgent"
              c:type="NM_DBUS_PATH_SECRET_AGENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_PATH_SETTINGS"
              value="/org/freedesktop/NetworkManager/Settings"
              c:type="NM_DBUS_PATH_SETTINGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_PATH_SETTINGS_CONNECTION"
              value="/org/freedesktop/NetworkManager/Settings/Connection"
              c:type="NM_DBUS_PATH_SETTINGS_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_PATH_VPN"
              value="/org/freedesktop/NetworkManager/VPN/Manager"
              c:type="NM_DBUS_PATH_VPN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_PATH_VPN_CONNECTION"
              value="/org/freedesktop/NetworkManager/VPN/Connection"
              c:type="NM_DBUS_PATH_VPN_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_SERVICE"
              value="org.freedesktop.NetworkManager"
              c:type="NM_DBUS_SERVICE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_ALREADY_STARTED"
              value="AlreadyStarted"
              c:type="NM_DBUS_VPN_ALREADY_STARTED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_ALREADY_STOPPED"
              value="AlreadyStopped"
              c:type="NM_DBUS_VPN_ALREADY_STOPPED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_BAD_ARGUMENTS"
              value="BadArguments"
              c:type="NM_DBUS_VPN_BAD_ARGUMENTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_ERROR_PREFIX"
              value="org.freedesktop.NetworkManager.VPN.Error"
              c:type="NM_DBUS_VPN_ERROR_PREFIX">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_INTERACTIVE_NOT_SUPPORTED"
              value="InteractiveNotSupported"
              c:type="NM_DBUS_VPN_INTERACTIVE_NOT_SUPPORTED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_SIGNAL_CONNECT_FAILED"
              value="ConnectFailed"
              c:type="NM_DBUS_VPN_SIGNAL_CONNECT_FAILED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_SIGNAL_IP4_CONFIG"
              value="IP4Config"
              c:type="NM_DBUS_VPN_SIGNAL_IP4_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_SIGNAL_IP_CONFIG_BAD"
              value="IPConfigBad"
              c:type="NM_DBUS_VPN_SIGNAL_IP_CONFIG_BAD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_SIGNAL_LAUNCH_FAILED"
              value="LaunchFailed"
              c:type="NM_DBUS_VPN_SIGNAL_LAUNCH_FAILED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_SIGNAL_LOGIN_BANNER"
              value="LoginBanner"
              c:type="NM_DBUS_VPN_SIGNAL_LOGIN_BANNER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_SIGNAL_LOGIN_FAILED"
              value="LoginFailed"
              c:type="NM_DBUS_VPN_SIGNAL_LOGIN_FAILED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_SIGNAL_STATE_CHANGE"
              value="StateChange"
              c:type="NM_DBUS_VPN_SIGNAL_STATE_CHANGE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_SIGNAL_VPN_CONFIG_BAD"
              value="VPNConfigBad"
              c:type="NM_DBUS_VPN_SIGNAL_VPN_CONFIG_BAD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_STARTING_IN_PROGRESS"
              value="StartingInProgress"
              c:type="NM_DBUS_VPN_STARTING_IN_PROGRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_STOPPING_IN_PROGRESS"
              value="StoppingInProgress"
              c:type="NM_DBUS_VPN_STOPPING_IN_PROGRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_WRONG_STATE"
              value="WrongState"
              c:type="NM_DBUS_VPN_WRONG_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_ACTIVE_CONNECTION"
              value="active-connection"
              c:type="NM_DEVICE_ACTIVE_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_ADSL_CARRIER"
              value="carrier"
              c:type="NM_DEVICE_ADSL_CARRIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_AUTOCONNECT"
              value="autoconnect"
              c:type="NM_DEVICE_AUTOCONNECT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_AVAILABLE_CONNECTIONS"
              value="available-connections"
              c:type="NM_DEVICE_AVAILABLE_CONNECTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BOND_CARRIER"
              value="carrier"
              c:type="NM_DEVICE_BOND_CARRIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BOND_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_BOND_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BOND_SLAVES"
              value="slaves"
              c:type="NM_DEVICE_BOND_SLAVES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BRIDGE_CARRIER"
              value="carrier"
              c:type="NM_DEVICE_BRIDGE_CARRIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BRIDGE_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_BRIDGE_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BRIDGE_SLAVES"
              value="slaves"
              c:type="NM_DEVICE_BRIDGE_SLAVES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BT_CAPABILITIES"
              value="bt-capabilities"
              c:type="NM_DEVICE_BT_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BT_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_BT_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BT_NAME" value="name" c:type="NM_DEVICE_BT_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_CAPABILITIES"
              value="capabilities"
              c:type="NM_DEVICE_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_DEVICE_TYPE"
              value="device-type"
              c:type="NM_DEVICE_DEVICE_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_DHCP4_CONFIG"
              value="dhcp4-config"
              c:type="NM_DEVICE_DHCP4_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_DHCP6_CONFIG"
              value="dhcp6-config"
              c:type="NM_DEVICE_DHCP6_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_DRIVER" value="driver" c:type="NM_DEVICE_DRIVER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_DRIVER_VERSION"
              value="driver-version"
              c:type="NM_DEVICE_DRIVER_VERSION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_ETHERNET_CARRIER"
              value="carrier"
              c:type="NM_DEVICE_ETHERNET_CARRIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_ETHERNET_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_ETHERNET_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_ETHERNET_PERMANENT_HW_ADDRESS"
              value="perm-hw-address"
              c:type="NM_DEVICE_ETHERNET_PERMANENT_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_ETHERNET_S390_SUBCHANNELS"
              value="s390-subchannels"
              c:type="NM_DEVICE_ETHERNET_S390_SUBCHANNELS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_ETHERNET_SPEED"
              value="speed"
              c:type="NM_DEVICE_ETHERNET_SPEED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_FIRMWARE_MISSING"
              value="firmware-missing"
              c:type="NM_DEVICE_FIRMWARE_MISSING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_FIRMWARE_VERSION"
              value="firmware-version"
              c:type="NM_DEVICE_FIRMWARE_VERSION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_GENERIC_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_GENERIC_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_GENERIC_TYPE_DESCRIPTION"
              value="type-description"
              c:type="NM_DEVICE_GENERIC_TYPE_DESCRIPTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_INFINIBAND_CARRIER"
              value="carrier"
              c:type="NM_DEVICE_INFINIBAND_CARRIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_INFINIBAND_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_INFINIBAND_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_INTERFACE"
              value="interface"
              c:type="NM_DEVICE_INTERFACE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_IP4_CONFIG"
              value="ip4-config"
              c:type="NM_DEVICE_IP4_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_IP6_CONFIG"
              value="ip6-config"
              c:type="NM_DEVICE_IP6_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_IP_INTERFACE"
              value="ip-interface"
              c:type="NM_DEVICE_IP_INTERFACE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_IP_TUNNEL_ENCAPSULATION_LIMIT"
              value="encapsulation-limit"
              c:type="NM_DEVICE_IP_TUNNEL_ENCAPSULATION_LIMIT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_IP_TUNNEL_FLOW_LABEL"
              value="flow-label"
              c:type="NM_DEVICE_IP_TUNNEL_FLOW_LABEL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_IP_TUNNEL_INPUT_KEY"
              value="input-key"
              c:type="NM_DEVICE_IP_TUNNEL_INPUT_KEY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_IP_TUNNEL_LOCAL"
              value="local"
              c:type="NM_DEVICE_IP_TUNNEL_LOCAL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_IP_TUNNEL_MODE"
              value="mode"
              c:type="NM_DEVICE_IP_TUNNEL_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_IP_TUNNEL_OUTPUT_KEY"
              value="output-key"
              c:type="NM_DEVICE_IP_TUNNEL_OUTPUT_KEY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_IP_TUNNEL_PARENT"
              value="parent"
              c:type="NM_DEVICE_IP_TUNNEL_PARENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_IP_TUNNEL_PATH_MTU_DISCOVERY"
              value="path-mtu-discovery"
              c:type="NM_DEVICE_IP_TUNNEL_PATH_MTU_DISCOVERY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_IP_TUNNEL_REMOTE"
              value="remote"
              c:type="NM_DEVICE_IP_TUNNEL_REMOTE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_IP_TUNNEL_TOS"
              value="tos"
              c:type="NM_DEVICE_IP_TUNNEL_TOS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_IP_TUNNEL_TTL"
              value="ttl"
              c:type="NM_DEVICE_IP_TUNNEL_TTL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_LLDP_NEIGHBORS"
              value="lldp-neighbors"
              c:type="NM_DEVICE_LLDP_NEIGHBORS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MACSEC_CIPHER_SUITE"
              value="cipher-suite"
              c:type="NM_DEVICE_MACSEC_CIPHER_SUITE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MACSEC_ENCODING_SA"
              value="encoding-sa"
              c:type="NM_DEVICE_MACSEC_ENCODING_SA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MACSEC_ENCRYPT"
              value="encrypt"
              c:type="NM_DEVICE_MACSEC_ENCRYPT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MACSEC_ES" value="es" c:type="NM_DEVICE_MACSEC_ES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MACSEC_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_MACSEC_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MACSEC_ICV_LENGTH"
              value="icv-length"
              c:type="NM_DEVICE_MACSEC_ICV_LENGTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MACSEC_INCLUDE_SCI"
              value="include-sci"
              c:type="NM_DEVICE_MACSEC_INCLUDE_SCI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MACSEC_PARENT"
              value="parent"
              c:type="NM_DEVICE_MACSEC_PARENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MACSEC_PROTECT"
              value="protect"
              c:type="NM_DEVICE_MACSEC_PROTECT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MACSEC_REPLAY_PROTECT"
              value="replay-protect"
              c:type="NM_DEVICE_MACSEC_REPLAY_PROTECT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MACSEC_SCB"
              value="scb"
              c:type="NM_DEVICE_MACSEC_SCB">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MACSEC_SCI"
              value="sci"
              c:type="NM_DEVICE_MACSEC_SCI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MACSEC_VALIDATION"
              value="validation"
              c:type="NM_DEVICE_MACSEC_VALIDATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MACSEC_WINDOW"
              value="window"
              c:type="NM_DEVICE_MACSEC_WINDOW">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MACVLAN_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_MACVLAN_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MACVLAN_MODE"
              value="mode"
              c:type="NM_DEVICE_MACVLAN_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MACVLAN_NO_PROMISC"
              value="no-promisc"
              c:type="NM_DEVICE_MACVLAN_NO_PROMISC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MACVLAN_PARENT"
              value="parent"
              c:type="NM_DEVICE_MACVLAN_PARENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MACVLAN_TAP"
              value="tap"
              c:type="NM_DEVICE_MACVLAN_TAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MANAGED" value="managed" c:type="NM_DEVICE_MANAGED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_METERED" value="metered" c:type="NM_DEVICE_METERED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MODEM_CURRENT_CAPABILITIES"
              value="current-capabilities"
              c:type="NM_DEVICE_MODEM_CURRENT_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MODEM_MODEM_CAPABILITIES"
              value="modem-capabilities"
              c:type="NM_DEVICE_MODEM_MODEM_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MTU" value="mtu" c:type="NM_DEVICE_MTU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_NM_PLUGIN_MISSING"
              value="nm-plugin-missing"
              c:type="NM_DEVICE_NM_PLUGIN_MISSING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_OLPC_MESH_ACTIVE_CHANNEL"
              value="active-channel"
              c:type="NM_DEVICE_OLPC_MESH_ACTIVE_CHANNEL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_OLPC_MESH_COMPANION"
              value="companion"
              c:type="NM_DEVICE_OLPC_MESH_COMPANION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_OLPC_MESH_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_OLPC_MESH_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_PHYSICAL_PORT_ID"
              value="physical-port-id"
              c:type="NM_DEVICE_PHYSICAL_PORT_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_PRODUCT" value="product" c:type="NM_DEVICE_PRODUCT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_REAL" value="real" c:type="NM_DEVICE_REAL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_STATE" value="state" c:type="NM_DEVICE_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_STATE_REASON"
              value="state-reason"
              c:type="NM_DEVICE_STATE_REASON">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_TEAM_CARRIER"
              value="carrier"
              c:type="NM_DEVICE_TEAM_CARRIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_TEAM_CONFIG"
              value="config"
              c:type="NM_DEVICE_TEAM_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_TEAM_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_TEAM_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_TEAM_SLAVES"
              value="slaves"
              c:type="NM_DEVICE_TEAM_SLAVES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_TUN_GROUP"
              value="group"
              c:type="NM_DEVICE_TUN_GROUP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_TUN_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_TUN_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_TUN_MODE" value="mode" c:type="NM_DEVICE_TUN_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_TUN_MULTI_QUEUE"
              value="multi-queue"
              c:type="NM_DEVICE_TUN_MULTI_QUEUE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_TUN_NO_PI"
              value="no-pi"
              c:type="NM_DEVICE_TUN_NO_PI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_TUN_OWNER"
              value="owner"
              c:type="NM_DEVICE_TUN_OWNER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_TUN_VNET_HDR"
              value="vnet-hdr"
              c:type="NM_DEVICE_TUN_VNET_HDR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_UDI" value="udi" c:type="NM_DEVICE_UDI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VENDOR" value="vendor" c:type="NM_DEVICE_VENDOR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VLAN_CARRIER"
              value="carrier"
              c:type="NM_DEVICE_VLAN_CARRIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VLAN_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_VLAN_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VLAN_PARENT"
              value="parent"
              c:type="NM_DEVICE_VLAN_PARENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VLAN_VLAN_ID"
              value="vlan-id"
              c:type="NM_DEVICE_VLAN_VLAN_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VXLAN_AGEING"
              value="ageing"
              c:type="NM_DEVICE_VXLAN_AGEING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VXLAN_CARRIER"
              value="carrier"
              c:type="NM_DEVICE_VXLAN_CARRIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VXLAN_DST_PORT"
              value="dst-port"
              c:type="NM_DEVICE_VXLAN_DST_PORT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VXLAN_GROUP"
              value="group"
              c:type="NM_DEVICE_VXLAN_GROUP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VXLAN_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_VXLAN_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VXLAN_ID" value="id" c:type="NM_DEVICE_VXLAN_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VXLAN_L2MISS"
              value="l2miss"
              c:type="NM_DEVICE_VXLAN_L2MISS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VXLAN_L3MISS"
              value="l3miss"
              c:type="NM_DEVICE_VXLAN_L3MISS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VXLAN_LEARNING"
              value="learning"
              c:type="NM_DEVICE_VXLAN_LEARNING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VXLAN_LIMIT"
              value="limit"
              c:type="NM_DEVICE_VXLAN_LIMIT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VXLAN_LOCAL"
              value="local"
              c:type="NM_DEVICE_VXLAN_LOCAL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VXLAN_PARENT"
              value="parent"
              c:type="NM_DEVICE_VXLAN_PARENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VXLAN_PROXY"
              value="proxy"
              c:type="NM_DEVICE_VXLAN_PROXY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VXLAN_RSC" value="rsc" c:type="NM_DEVICE_VXLAN_RSC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VXLAN_SRC_PORT_MAX"
              value="src-port-max"
              c:type="NM_DEVICE_VXLAN_SRC_PORT_MAX">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VXLAN_SRC_PORT_MIN"
              value="src-port-min"
              c:type="NM_DEVICE_VXLAN_SRC_PORT_MIN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VXLAN_TOS" value="tos" c:type="NM_DEVICE_VXLAN_TOS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VXLAN_TTL" value="ttl" c:type="NM_DEVICE_VXLAN_TTL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIFI_ACCESS_POINTS"
              value="access-points"
              c:type="NM_DEVICE_WIFI_ACCESS_POINTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIFI_ACTIVE_ACCESS_POINT"
              value="active-access-point"
              c:type="NM_DEVICE_WIFI_ACTIVE_ACCESS_POINT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIFI_BITRATE"
              value="bitrate"
              c:type="NM_DEVICE_WIFI_BITRATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIFI_CAPABILITIES"
              value="wireless-capabilities"
              c:type="NM_DEVICE_WIFI_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIFI_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_WIFI_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIFI_MODE"
              value="mode"
              c:type="NM_DEVICE_WIFI_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIFI_PERMANENT_HW_ADDRESS"
              value="perm-hw-address"
              c:type="NM_DEVICE_WIFI_PERMANENT_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIMAX_ACTIVE_NSP"
              value="active-nsp"
              c:type="NM_DEVICE_WIMAX_ACTIVE_NSP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIMAX_BSID"
              value="bsid"
              c:type="NM_DEVICE_WIMAX_BSID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIMAX_CENTER_FREQUENCY"
              value="center-frequency"
              c:type="NM_DEVICE_WIMAX_CENTER_FREQUENCY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIMAX_CINR"
              value="cinr"
              c:type="NM_DEVICE_WIMAX_CINR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIMAX_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_WIMAX_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIMAX_NSPS"
              value="nsps"
              c:type="NM_DEVICE_WIMAX_NSPS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIMAX_RSSI"
              value="rssi"
              c:type="NM_DEVICE_WIMAX_RSSI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIMAX_TX_POWER"
              value="tx-power"
              c:type="NM_DEVICE_WIMAX_TX_POWER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DHCP_CONFIG_FAMILY"
              value="family"
              c:type="NM_DHCP_CONFIG_FAMILY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DHCP_CONFIG_OPTIONS"
              value="options"
              c:type="NM_DHCP_CONFIG_OPTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Device"
           c:symbol-prefix="device"
           c:type="NMDevice"
           parent="Object"
           abstract="1"
           glib:type-name="NMDevice"
           glib:get-type="nm_device_get_type"
           glib:type-struct="DeviceClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <function name="disambiguate_names"
                c:identifier="nm_device_disambiguate_names">
        <doc xml:space="preserve">Generates a list of short-ish unique presentation names for the
devices in @devices.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the device names</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="devices" transfer-ownership="none">
            <doc xml:space="preserve">an array of #NMDevice</doc>
            <array length="1" zero-terminated="0" c:type="NMDevice**">
              <type name="Device" c:type="NMDevice*"/>
            </array>
          </parameter>
          <parameter name="num_devices" transfer-ownership="none">
            <doc xml:space="preserve">length of @devices</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="connection_compatible"
                      invoker="connection_compatible"
                      throws="1">
        <doc xml:space="preserve">Validates a given connection for a given #NMDevice object and returns
whether the connection may be activated with the device. For example if
@device is a Wi-Fi device that supports only WEP encryption, the connection
will only be valid if it is a Wi-Fi connection which describes a WEP or open
network, and will not be valid if it describes a WPA network, or if it is
an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
device.

This function does the same as nm_device_connection_valid(), i.e. checking
compatibility of the given device and connection. But, in addition, it sets
GError when FALSE is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection may be activated with this device, %FALSE
if is incompatible with the device's capabilities and characteristics.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">an #NMDevice to validate @connection against</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">an #NMConnection to validate against @device</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_hw_address" invoker="get_hw_address">
        <doc xml:space="preserve">Gets the current a hardware address (MAC) for the @device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current MAC of the device, or %NULL.
This is the internal string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_setting_type" invoker="get_setting_type">
        <doc xml:space="preserve">Gets the (primary) #NMSetting subtype associated with connections
that can be used on @device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@device's associated #NMSetting type</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">an #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_type_description"
                      invoker="get_type_description">
        <doc xml:space="preserve">Gets a (non-localized) description of the type of device that
@device is.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type description of the device. This is the internal
string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="state_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="new_state" transfer-ownership="none">
            <type name="DeviceState" c:type="NMDeviceState"/>
          </parameter>
          <parameter name="old_state" transfer-ownership="none">
            <type name="DeviceState" c:type="NMDeviceState"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <type name="DeviceStateReason" c:type="NMDeviceStateReason"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="connection_compatible"
              c:identifier="nm_device_connection_compatible"
              throws="1">
        <doc xml:space="preserve">Validates a given connection for a given #NMDevice object and returns
whether the connection may be activated with the device. For example if
@device is a Wi-Fi device that supports only WEP encryption, the connection
will only be valid if it is a Wi-Fi connection which describes a WEP or open
network, and will not be valid if it describes a WPA network, or if it is
an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
device.

This function does the same as nm_device_connection_valid(), i.e. checking
compatibility of the given device and connection. But, in addition, it sets
GError when FALSE is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection may be activated with this device, %FALSE
if is incompatible with the device's capabilities and characteristics.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">an #NMDevice to validate @connection against</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">an #NMConnection to validate against @device</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connection_valid"
              c:identifier="nm_device_connection_valid">
        <doc xml:space="preserve">Validates a given connection for a given #NMDevice object and returns
whether the connection may be activated with the device. For example if
@device is a Wi-Fi device that supports only WEP encryption, the connection
will only be valid if it is a Wi-Fi connection which describes a WEP or open
network, and will not be valid if it describes a WPA network, or if it is
an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection may be activated with this device, %FALSE
if is incompatible with the device's capabilities and characteristics.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">an #NMDevice to validate @connection against</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">an #NMConnection to validate against @device</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete" c:identifier="nm_device_delete" throws="1">
        <doc xml:space="preserve">Deletes the software device. Hardware devices can't be deleted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error, in which case @error
will be set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete_async" c:identifier="nm_device_delete_async">
        <doc xml:space="preserve">Asynchronously begins deleteing the software device. Hardware devices can't
be deleted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">callback to be called when delete operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">caller-specific data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete_finish"
              c:identifier="nm_device_delete_finish"
              throws="1">
        <doc xml:space="preserve">Gets the result of a call to nm_device_delete_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error, in which case @error
will be set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the #GAsyncReadyCallback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="disconnect" c:identifier="nm_device_disconnect" throws="1">
        <doc xml:space="preserve">Disconnects the device if currently connected, and prevents the device from
automatically connecting to networks until the next manual network connection
request.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error, in which case @error will be set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="disconnect_async"
              c:identifier="nm_device_disconnect_async">
        <doc xml:space="preserve">Asynchronously begins disconnecting the device if currently connected, and
prevents the device from automatically connecting to networks until the next
manual network connection request.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">callback to be called when the disconnect operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">caller-specific data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="disconnect_finish"
              c:identifier="nm_device_disconnect_finish"
              throws="1">
        <doc xml:space="preserve">Gets the result of a call to nm_device_disconnect_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error, in which case @error
will be set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the #GAsyncReadyCallback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="filter_connections"
              c:identifier="nm_device_filter_connections">
        <doc xml:space="preserve">Filters a given array of connections for a given #NMDevice object and returns
connections which may be activated with the device. For example if @device
is a Wi-Fi device that supports only WEP encryption, the returned array will
contain any Wi-Fi connections in @connections that allow connection to
unencrypted or WEP-enabled SSIDs.  The returned array will not contain
Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
incompatible with the device. To get the full list of connections see
nm_client_get_connections().</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">an array of
#NMConnections that could be activated with the given @device.  The array
should be freed with g_ptr_array_unref() when it is no longer required.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="Connection"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">an #NMDevice to filter connections for</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="connections" transfer-ownership="none">
            <doc xml:space="preserve">an array of #NMConnections to filter</doc>
            <array name="GLib.PtrArray" c:type="const GPtrArray*">
              <type name="Connection"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_active_connection"
              c:identifier="nm_device_get_active_connection">
        <doc xml:space="preserve">Gets the #NMActiveConnection object which owns this device during activation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMActiveConnection or %NULL if the device is
not part of an active connection</doc>
          <type name="ActiveConnection" c:type="NMActiveConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_applied_connection"
              c:identifier="nm_device_get_applied_connection"
              version="1.2"
              throws="1">
        <doc xml:space="preserve">Fetch the currently applied connection on the device.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a %NMConnection with the currently applied settings
  or %NULL on error.

The connection is as received from D-Bus and might not validate according
to nm_connection_verify().</doc>
          <type name="Connection" c:type="NMConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">the flags argument. Currently this value must always be zero.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="version_id"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">(allow-none): returns the current version id of
  the applied connection</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_applied_connection_async"
              c:identifier="nm_device_get_applied_connection_async"
              version="1.2">
        <doc xml:space="preserve">Asynchronously begins an get the a currently applied connection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">the flags argument. Currently this value must always be zero.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">callback to be called when the reapply operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">caller-specific data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_applied_connection_finish"
              c:identifier="nm_device_get_applied_connection_finish"
              version="1.2"
              throws="1">
        <doc xml:space="preserve">Gets the result of a call to nm_device_get_applied_connection_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a currently applied %NMConnection or %NULL in case
  of error.

The connection is as received from D-Bus and might not validate according
to nm_connection_verify().</doc>
          <type name="Connection" c:type="NMConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the #GAsyncReadyCallback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="version_id"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">(allow-none): the current version id of the applied
  connection.</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_autoconnect" c:identifier="nm_device_get_autoconnect">
        <doc xml:space="preserve">Whether the #NMDevice can be autoconnected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the device is allowed to be autoconnected</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_available_connections"
              c:identifier="nm_device_get_available_connections">
        <doc xml:space="preserve">Gets the #NMRemoteConnections currently known to the daemon that could
be activated on @device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GPtrArray
containing #NMRemoteConnections. This is the internal copy used by
the connection, and must not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="RemoteConnection"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_capabilities"
              c:identifier="nm_device_get_capabilities">
        <doc xml:space="preserve">Gets the device' capabilities.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the capabilities</doc>
          <type name="DeviceCapabilities" c:type="NMDeviceCapabilities"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_description" c:identifier="nm_device_get_description">
        <doc xml:space="preserve">Gets a description of @device, based on its vendor and product names.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a description of @device. If either the vendor or the
  product name is unknown, this returns the interface name.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">an #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_device_type" c:identifier="nm_device_get_device_type">
        <doc xml:space="preserve">Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the device type</doc>
          <type name="DeviceType" c:type="NMDeviceType"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dhcp4_config"
              c:identifier="nm_device_get_dhcp4_config">
        <doc xml:space="preserve">Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.

You can alternatively use nm_active_connection_get_dhcp4_config(), which also
works with VPN connections.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IPv4 #NMDhcpConfig, or %NULL if the device is
not activated or not using DHCP.</doc>
          <type name="DhcpConfig" c:type="NMDhcpConfig*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dhcp6_config"
              c:identifier="nm_device_get_dhcp6_config">
        <doc xml:space="preserve">Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.

You can alternatively use nm_active_connection_get_dhcp6_config(), which also
works with VPN connections.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IPv6 #NMDhcpConfig, or %NULL if the device is
not activated or not using DHCPv6.</doc>
          <type name="DhcpConfig" c:type="NMDhcpConfig*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_driver" c:identifier="nm_device_get_driver">
        <doc xml:space="preserve">Gets the driver of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the driver of the device. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_driver_version"
              c:identifier="nm_device_get_driver_version">
        <doc xml:space="preserve">Gets the driver version of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the version of the device driver. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_firmware_missing"
              c:identifier="nm_device_get_firmware_missing">
        <doc xml:space="preserve">Indicates that firmware required for the device's operation is likely
to be missing.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if firmware required for the device's operation is likely
to be missing.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_firmware_version"
              c:identifier="nm_device_get_firmware_version">
        <doc xml:space="preserve">Gets the firmware version of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the firmware version of the device. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address" c:identifier="nm_device_get_hw_address">
        <doc xml:space="preserve">Gets the current a hardware address (MAC) for the @device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current MAC of the device, or %NULL.
This is the internal string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_iface" c:identifier="nm_device_get_iface">
        <doc xml:space="preserve">Gets the interface name of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the interface of the device. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ip4_config" c:identifier="nm_device_get_ip4_config">
        <doc xml:space="preserve">Gets the current IPv4 #NMIPConfig associated with the #NMDevice.

You can alternatively use nm_active_connection_get_ip4_config(), which also
works with VPN connections.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IPv4 #NMIPConfig, or %NULL if the device is not
activated.</doc>
          <type name="IPConfig" c:type="NMIPConfig*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ip6_config" c:identifier="nm_device_get_ip6_config">
        <doc xml:space="preserve">Gets the current IPv6 #NMIPConfig associated with the #NMDevice.

You can alternatively use nm_active_connection_get_ip6_config(), which also
works with VPN connections.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IPv6 #NMIPConfig or %NULL if the device is not activated.</doc>
          <type name="IPConfig" c:type="NMIPConfig*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ip_iface" c:identifier="nm_device_get_ip_iface">
        <doc xml:space="preserve">Gets the IP interface name of the #NMDevice over which IP traffic flows
when the device is in the ACTIVATED state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IP traffic interface of the device. This is the internal string
used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_lldp_neighbors"
              c:identifier="nm_device_get_lldp_neighbors"
              version="1.2">
        <doc xml:space="preserve">Gets the list of neighbors discovered through LLDP.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GPtrArray
containing #NMLldpNeighbor&lt;!-- --&gt;s. This is the internal copy used by the
device and must not be modified. The library never modifies the returned
array and thus it is safe for callers to reference and keep using it.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="LldpNeighbor"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_managed" c:identifier="nm_device_get_managed">
        <doc xml:space="preserve">Whether the #NMDevice is managed by NetworkManager.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the device is managed by NetworkManager</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_metered"
              c:identifier="nm_device_get_metered"
              version="1.2">
        <doc xml:space="preserve">Gets the metered setting of a #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the metered setting.</doc>
          <type name="Metered" c:type="NMMetered"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mtu" c:identifier="nm_device_get_mtu">
        <doc xml:space="preserve">Gets the  MTU of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the MTU of the device.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_nm_plugin_missing"
              c:identifier="nm_device_get_nm_plugin_missing"
              version="1.2">
        <doc xml:space="preserve">Indicates that the NetworkManager plugin for the device is not installed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the device plugin not installed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_physical_port_id"
              c:identifier="nm_device_get_physical_port_id">
        <doc xml:space="preserve">Gets the physical port ID of the #NMDevice. If non-%NULL, this is
an opaque string that can be used to recognize when
seemingly-unrelated #NMDevices are actually just different virtual
ports on a single physical port. (Eg, NPAR / SR-IOV.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the physical port ID of the device, or %NULL if the port
  ID is unknown. This is the internal string used by the device and
  must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_product" c:identifier="nm_device_get_product">
        <doc xml:space="preserve">Gets the product string of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the product name of the device. This is the internal string used by the
device, and must not be modified.

The string is backslash escaped (C escaping) for invalid characters. The escaping
can be reverted with g_strcompress(), however the result may not be valid UTF-8.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_type"
              c:identifier="nm_device_get_setting_type">
        <doc xml:space="preserve">Gets the (primary) #NMSetting subtype associated with connections
that can be used on @device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@device's associated #NMSetting type</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">an #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_state" c:identifier="nm_device_get_state">
        <doc xml:space="preserve">Gets the current #NMDevice state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current device state</doc>
          <type name="DeviceState" c:type="NMDeviceState"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_state_reason"
              c:identifier="nm_device_get_state_reason">
        <doc xml:space="preserve">Gets the reason for entering the current #NMDevice state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the reason for entering the current device state</doc>
          <type name="DeviceStateReason" c:type="NMDeviceStateReason"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_type_description"
              c:identifier="nm_device_get_type_description">
        <doc xml:space="preserve">Gets a (non-localized) description of the type of device that
@device is.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type description of the device. This is the internal
string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_udi" c:identifier="nm_device_get_udi">
        <doc xml:space="preserve">Gets the Unique Device Identifier of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the Unique Device Identifier of the device.  This identifier may be
used to gather more information about the device from various operating
system services like udev or sysfs.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vendor" c:identifier="nm_device_get_vendor">
        <doc xml:space="preserve">Gets the vendor string of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the vendor name of the device. This is the internal string used by the
device, and must not be modified.

The string is backslash escaped (C escaping) for invalid characters. The escaping
can be reverted with g_strcompress(), however the result may not be valid UTF-8.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_real" c:identifier="nm_device_is_real" version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the device exists, or %FALSE if it is a placeholder device
that could be automatically created by NetworkManager if one of its
#NMDevice:available-connections was activated.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_software" c:identifier="nm_device_is_software">
        <doc xml:space="preserve">Whether the device is a software device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @device is a software device, %FALSE if it is a hardware device.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reapply"
              c:identifier="nm_device_reapply"
              version="1.2"
              throws="1">
        <doc xml:space="preserve">Attempts to update device with changes to the currently active connection
made since it was last applied.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error, in which case @error will be set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection to replace the applied settings with or %NULL to reuse existing</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="version_id" transfer-ownership="none">
            <doc xml:space="preserve">zero or the expected version id of the applied connection. If specified
  and the version id mismatches, the call fails without modification. This allows to
  catch concurrent accesses.</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">always set this to zero</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reapply_async"
              c:identifier="nm_device_reapply_async"
              version="1.2">
        <doc xml:space="preserve">Asynchronously begins an attempt to update device with changes to the
currently active connection made since it was last applied.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection to replace the applied settings with or %NULL to reuse existing</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="version_id" transfer-ownership="none">
            <doc xml:space="preserve">zero or the expected version id of the applied connection. If specified
  and the version id mismatches, the call fails without modification. This allows to
  catch concurrent accesses.</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">always set this to zero</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve">callback to be called when the reapply operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">caller-specific data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="reapply_finish"
              c:identifier="nm_device_reapply_finish"
              version="1.2"
              throws="1">
        <doc xml:space="preserve">Gets the result of a call to nm_device_reapply_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error, in which case @error
will be set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the #GAsyncReadyCallback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_autoconnect" c:identifier="nm_device_set_autoconnect">
        <doc xml:space="preserve">Enables or disables automatic activation of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="autoconnect" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to enable autoconnecting</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_managed"
              c:identifier="nm_device_set_managed"
              version="1.2">
        <doc xml:space="preserve">Enables or disables management of  #NMDevice by NetworkManager.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="managed" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to make the device managed by NetworkManager.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="active-connection" transfer-ownership="none">
        <doc xml:space="preserve">The #NMActiveConnection object that "owns" this device during activation.</doc>
        <type name="ActiveConnection"/>
      </property>
      <property name="autoconnect" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether the device can auto-activate a connection.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="available-connections" transfer-ownership="none">
        <doc xml:space="preserve">The available connections of the device

Element-type: NMRemoteConnection</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="capabilities" transfer-ownership="none">
        <doc xml:space="preserve">The capabilities of the device.</doc>
        <type name="DeviceCapabilities"/>
      </property>
      <property name="device-type" transfer-ownership="none">
        <doc xml:space="preserve">The numeric type of the device.</doc>
        <type name="DeviceType"/>
      </property>
      <property name="dhcp4-config" transfer-ownership="none">
        <doc xml:space="preserve">The IPv4 #NMDhcpConfig of the device.</doc>
        <type name="DhcpConfig"/>
      </property>
      <property name="dhcp6-config" transfer-ownership="none">
        <doc xml:space="preserve">The IPv6 #NMDhcpConfig of the device.</doc>
        <type name="DhcpConfig"/>
      </property>
      <property name="driver" transfer-ownership="none">
        <doc xml:space="preserve">The driver of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="driver-version" transfer-ownership="none">
        <doc xml:space="preserve">The version of the device driver.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="firmware-missing" transfer-ownership="none">
        <doc xml:space="preserve">When %TRUE indicates the device is likely missing firmware required
for its operation.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="firmware-version" transfer-ownership="none">
        <doc xml:space="preserve">The firmware version of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="interface" transfer-ownership="none">
        <doc xml:space="preserve">The interface of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="ip-interface" transfer-ownership="none">
        <doc xml:space="preserve">The IP interface of the device which should be used for all IP-related
operations like addressing and routing.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="ip4-config" transfer-ownership="none">
        <doc xml:space="preserve">The #NMIP4Config of the device.</doc>
        <type name="IPConfig"/>
      </property>
      <property name="ip6-config" transfer-ownership="none">
        <doc xml:space="preserve">The IPv6 #NMIPConfig of the device.</doc>
        <type name="IPConfig"/>
      </property>
      <property name="lldp-neighbors" transfer-ownership="none">
        <doc xml:space="preserve">The LLDP neighbors.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="managed" transfer-ownership="none">
        <doc xml:space="preserve">Whether the device is managed by NetworkManager.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="metered" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">Whether the device is metered.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="mtu" transfer-ownership="none">
        <doc xml:space="preserve">The MTU of the device.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="nm-plugin-missing"
                version="1.2"
                transfer-ownership="none">
        <doc xml:space="preserve">When %TRUE indicates that the NetworkManager plugin for the device
is not installed.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="physical-port-id" transfer-ownership="none">
        <doc xml:space="preserve">The physical port ID of the device. (See
nm_device_get_physical_port_id().)</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="product" transfer-ownership="none">
        <doc xml:space="preserve">The product string of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="real" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">Whether the device is real or is a placeholder device that could
be created automatically by NetworkManager if one of its
#NMDevice:available-connections was activated.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="state" transfer-ownership="none">
        <doc xml:space="preserve">The state of the device.</doc>
        <type name="DeviceState"/>
      </property>
      <property name="state-reason" transfer-ownership="none">
        <doc xml:space="preserve">The reason for the device state.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="udi" transfer-ownership="none">
        <doc xml:space="preserve">An operating-system specific device hardware identifier; this is not
unique to a specific hardware device across reboots or hotplugs.  It
is an opaque string which for some device types (Bluetooth, Modem)
contains an identifier provided by the underlying hardware service daemon
such as Bluez or ModemManager, and clients can use this property to
request more information about the device from those services.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="vendor" transfer-ownership="none">
        <doc xml:space="preserve">The vendor string of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Object" c:type="NMObject"/>
      </field>
      <glib:signal name="state-changed" when="first">
        <doc xml:space="preserve">Notifies the state change of a #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="new_state" transfer-ownership="none">
            <doc xml:space="preserve">the new state of the device</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="old_state" transfer-ownership="none">
            <doc xml:space="preserve">the previous state of the device</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:space="preserve">the reason describing the state change</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <class name="DeviceAdsl"
           c:symbol-prefix="device_adsl"
           c:type="NMDeviceAdsl"
           parent="Device"
           glib:type-name="NMDeviceAdsl"
           glib:get-type="nm_device_adsl_get_type"
           glib:type-struct="DeviceAdslClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <method name="get_carrier" c:identifier="nm_device_adsl_get_carrier">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the device has carrier</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceAdsl</doc>
            <type name="DeviceAdsl" c:type="NMDeviceAdsl*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="carrier" transfer-ownership="none">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceAdslClass"
            c:type="NMDeviceAdslClass"
            glib:is-gtype-struct-for="DeviceAdsl">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="DeviceBond"
           c:symbol-prefix="device_bond"
           c:type="NMDeviceBond"
           parent="Device"
           glib:type-name="NMDeviceBond"
           glib:get-type="nm_device_bond_get_type"
           glib:type-struct="DeviceBondClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <method name="get_carrier" c:identifier="nm_device_bond_get_carrier">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the device has carrier</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceBond</doc>
            <type name="DeviceBond" c:type="NMDeviceBond*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_bond_get_hw_address">
        <doc xml:space="preserve">Gets the hardware (MAC) address of the #NMDeviceBond</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceBond</doc>
            <type name="DeviceBond" c:type="NMDeviceBond*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_slaves" c:identifier="nm_device_bond_get_slaves">
        <doc xml:space="preserve">Gets the devices currently slaved to @device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GPtrArray containing
#NMDevices that are slaves of @device. This is the internal
copy used by the device, and must not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="Device"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceBond</doc>
            <type name="DeviceBond" c:type="NMDeviceBond*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="carrier" transfer-ownership="none">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:space="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="slaves" transfer-ownership="none">
        <doc xml:space="preserve">The devices slaved to the bond device.

Element-type: NMDevice</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceBondClass"
            c:type="NMDeviceBondClass"
            glib:is-gtype-struct-for="DeviceBond">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="DeviceBridge"
           c:symbol-prefix="device_bridge"
           c:type="NMDeviceBridge"
           parent="Device"
           glib:type-name="NMDeviceBridge"
           glib:get-type="nm_device_bridge_get_type"
           glib:type-struct="DeviceBridgeClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <method name="get_carrier" c:identifier="nm_device_bridge_get_carrier">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the device has carrier</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceBridge</doc>
            <type name="DeviceBridge" c:type="NMDeviceBridge*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_bridge_get_hw_address">
        <doc xml:space="preserve">Gets the hardware (MAC) address of the #NMDeviceBridge</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceBridge</doc>
            <type name="DeviceBridge" c:type="NMDeviceBridge*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_slaves" c:identifier="nm_device_bridge_get_slaves">
        <doc xml:space="preserve">Gets the devices currently slaved to @device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GPtrArray containing
#NMDevices that are slaves of @device. This is the internal
copy used by the device, and must not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="Device"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceBridge</doc>
            <type name="DeviceBridge" c:type="NMDeviceBridge*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="carrier" transfer-ownership="none">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:space="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="slaves" transfer-ownership="none">
        <doc xml:space="preserve">The devices slaved to the bridge device.

Element-type: NMDevice</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceBridgeClass"
            c:type="NMDeviceBridgeClass"
            glib:is-gtype-struct-for="DeviceBridge">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="DeviceBt"
           c:symbol-prefix="device_bt"
           c:type="NMDeviceBt"
           parent="Device"
           glib:type-name="NMDeviceBt"
           glib:get-type="nm_device_bt_get_type"
           glib:type-struct="DeviceBtClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <method name="get_capabilities"
              c:identifier="nm_device_bt_get_capabilities">
        <doc xml:space="preserve">Returns the Bluetooth device's usable capabilities.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a combination of #NMBluetoothCapabilities</doc>
          <type name="BluetoothCapabilities" c:type="NMBluetoothCapabilities"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceBt</doc>
            <type name="DeviceBt" c:type="NMDeviceBt*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address" c:identifier="nm_device_bt_get_hw_address">
        <doc xml:space="preserve">Gets the hardware (MAC) address of the #NMDeviceBt</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceBt</doc>
            <type name="DeviceBt" c:type="NMDeviceBt*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="nm_device_bt_get_name">
        <doc xml:space="preserve">Gets the name of the #NMDeviceBt.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of the device</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceBt</doc>
            <type name="DeviceBt" c:type="NMDeviceBt*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="bt-capabilities" transfer-ownership="none">
        <doc xml:space="preserve">The device's bluetooth capabilities, a combination of #NMBluetoothCapabilities.</doc>
        <type name="BluetoothCapabilities"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:space="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="name" transfer-ownership="none">
        <doc xml:space="preserve">The name of the bluetooth device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceBtClass"
            c:type="NMDeviceBtClass"
            glib:is-gtype-struct-for="DeviceBt">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="DeviceCapabilities"
              glib:type-name="NMDeviceCapabilities"
              glib:get-type="nm_device_capabilities_get_type"
              c:type="NMDeviceCapabilities">
      <doc xml:space="preserve">General device capability flags.</doc>
      <member name="none"
              value="0"
              c:identifier="NM_DEVICE_CAP_NONE"
              glib:nick="none">
        <doc xml:space="preserve">device has no special capabilities</doc>
      </member>
      <member name="nm_supported"
              value="1"
              c:identifier="NM_DEVICE_CAP_NM_SUPPORTED"
              glib:nick="nm-supported">
        <doc xml:space="preserve">NetworkManager supports this device</doc>
      </member>
      <member name="carrier_detect"
              value="2"
              c:identifier="NM_DEVICE_CAP_CARRIER_DETECT"
              glib:nick="carrier-detect">
        <doc xml:space="preserve">this device can indicate carrier status</doc>
      </member>
      <member name="is_software"
              value="4"
              c:identifier="NM_DEVICE_CAP_IS_SOFTWARE"
              glib:nick="is-software">
        <doc xml:space="preserve">this device is a software device</doc>
      </member>
      <member name="sriov"
              value="8"
              c:identifier="NM_DEVICE_CAP_SRIOV"
              glib:nick="sriov">
        <doc xml:space="preserve">this device supports single-root I/O virtualization</doc>
      </member>
    </bitfield>
    <record name="DeviceClass"
            c:type="NMDeviceClass"
            glib:is-gtype-struct-for="Device">
      <field name="parent">
        <type name="ObjectClass" c:type="NMObjectClass"/>
      </field>
      <field name="state_changed">
        <callback name="state_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="device" transfer-ownership="none">
              <type name="Device" c:type="NMDevice*"/>
            </parameter>
            <parameter name="new_state" transfer-ownership="none">
              <type name="DeviceState" c:type="NMDeviceState"/>
            </parameter>
            <parameter name="old_state" transfer-ownership="none">
              <type name="DeviceState" c:type="NMDeviceState"/>
            </parameter>
            <parameter name="reason" transfer-ownership="none">
              <type name="DeviceStateReason" c:type="NMDeviceStateReason"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="connection_compatible">
        <callback name="connection_compatible" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the connection may be activated with this device, %FALSE
if is incompatible with the device's capabilities and characteristics.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="device" transfer-ownership="none">
              <doc xml:space="preserve">an #NMDevice to validate @connection against</doc>
              <type name="Device" c:type="NMDevice*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">an #NMConnection to validate against @device</doc>
              <type name="Connection" c:type="NMConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_type_description">
        <callback name="get_type_description">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the type description of the device. This is the internal
string used by the device, and must not be modified.</doc>
            <type name="utf8" c:type="const char*"/>
          </return-value>
          <parameters>
            <parameter name="device" transfer-ownership="none">
              <doc xml:space="preserve">a #NMDevice</doc>
              <type name="Device" c:type="NMDevice*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_hw_address">
        <callback name="get_hw_address">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the current MAC of the device, or %NULL.
This is the internal string used by the device, and must not be modified.</doc>
            <type name="utf8" c:type="const char*"/>
          </return-value>
          <parameters>
            <parameter name="device" transfer-ownership="none">
              <doc xml:space="preserve">a #NMDevice</doc>
              <type name="Device" c:type="NMDevice*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_setting_type">
        <callback name="get_setting_type">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">@device's associated #NMSetting type</doc>
            <type name="GType" c:type="GType"/>
          </return-value>
          <parameters>
            <parameter name="device" transfer-ownership="none">
              <doc xml:space="preserve">an #NMDevice</doc>
              <type name="Device" c:type="NMDevice*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="DeviceDummy"
           c:symbol-prefix="device_dummy"
           c:type="NMDeviceDummy"
           parent="Device"
           glib:type-name="NMDeviceDummy"
           glib:get-type="nm_device_dummy_get_type"
           glib:type-struct="DeviceDummyClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceDummyClass"
            c:type="NMDeviceDummyClass"
            glib:is-gtype-struct-for="DeviceDummy">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="DeviceError"
                 glib:type-name="NMDeviceError"
                 glib:get-type="nm_device_error_get_type"
                 c:type="NMDeviceError"
                 glib:error-domain="nm-device-error-quark">
      <doc xml:space="preserve">Device-related errors.

These errors may be returned directly from #NMDevice methods, or may be
returned from D-Bus operations (where they correspond to errors in the
"org.freedesktop.NetworkManager.Device" namespace).</doc>
      <member name="Failed"
              value="0"
              c:identifier="NM_DEVICE_ERROR_FAILED"
              glib:nick="Failed">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="CreationFailed"
              value="1"
              c:identifier="NM_DEVICE_ERROR_CREATION_FAILED"
              glib:nick="CreationFailed">
        <doc xml:space="preserve">NetworkManager failed to create the device</doc>
      </member>
      <member name="InvalidConnection"
              value="2"
              c:identifier="NM_DEVICE_ERROR_INVALID_CONNECTION"
              glib:nick="InvalidConnection">
        <doc xml:space="preserve">the specified connection is not valid</doc>
      </member>
      <member name="IncompatibleConnection"
              value="3"
              c:identifier="NM_DEVICE_ERROR_INCOMPATIBLE_CONNECTION"
              glib:nick="IncompatibleConnection">
        <doc xml:space="preserve">the specified connection is not
  compatible with this device.</doc>
      </member>
      <member name="NotActive"
              value="4"
              c:identifier="NM_DEVICE_ERROR_NOT_ACTIVE"
              glib:nick="NotActive">
        <doc xml:space="preserve">the device does not have an active connection</doc>
      </member>
      <member name="NotSoftware"
              value="5"
              c:identifier="NM_DEVICE_ERROR_NOT_SOFTWARE"
              glib:nick="NotSoftware">
        <doc xml:space="preserve">the requested operation is only valid on
  software devices.</doc>
      </member>
      <member name="NotAllowed"
              value="6"
              c:identifier="NM_DEVICE_ERROR_NOT_ALLOWED"
              glib:nick="NotAllowed">
        <doc xml:space="preserve">the requested operation is not allowed at
  this time.</doc>
      </member>
      <member name="SpecificObjectNotFound"
              value="7"
              c:identifier="NM_DEVICE_ERROR_SPECIFIC_OBJECT_NOT_FOUND"
              glib:nick="SpecificObjectNotFound">
        <doc xml:space="preserve">the "specific object" in the
  activation request (eg, the #NMAccessPoint or #NMWimaxNsp) was not
  found.</doc>
      </member>
      <member name="VersionIdMismatch"
              value="8"
              c:identifier="NM_DEVICE_ERROR_VERSION_ID_MISMATCH"
              glib:nick="VersionIdMismatch">
        <doc xml:space="preserve">the version id did not match.</doc>
      </member>
      <function name="quark" c:identifier="nm_device_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="DeviceEthernet"
           c:symbol-prefix="device_ethernet"
           c:type="NMDeviceEthernet"
           parent="Device"
           glib:type-name="NMDeviceEthernet"
           glib:get-type="nm_device_ethernet_get_type"
           glib:type-struct="DeviceEthernetClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <method name="get_carrier" c:identifier="nm_device_ethernet_get_carrier">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the device has carrier</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceEthernet</doc>
            <type name="DeviceEthernet" c:type="NMDeviceEthernet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_ethernet_get_hw_address">
        <doc xml:space="preserve">Gets the active hardware (MAC) address of the #NMDeviceEthernet</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the active hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceEthernet</doc>
            <type name="DeviceEthernet" c:type="NMDeviceEthernet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_permanent_hw_address"
              c:identifier="nm_device_ethernet_get_permanent_hw_address">
        <doc xml:space="preserve">Gets the permanent hardware (MAC) address of the #NMDeviceEthernet</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the permanent hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceEthernet</doc>
            <type name="DeviceEthernet" c:type="NMDeviceEthernet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_s390_subchannels"
              c:identifier="nm_device_ethernet_get_s390_subchannels"
              version="1.2">
        <doc xml:space="preserve">Return the list of s390 subchannels if the device supports them.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">array of strings, each specifying
  one subchannel the s390 device uses to communicate to the host.</doc>
          <array c:type="const char* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceEthernet</doc>
            <type name="DeviceEthernet" c:type="NMDeviceEthernet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_speed" c:identifier="nm_device_ethernet_get_speed">
        <doc xml:space="preserve">Gets the speed of the #NMDeviceEthernet.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the speed of the device</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceEthernet</doc>
            <type name="DeviceEthernet" c:type="NMDeviceEthernet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="carrier" transfer-ownership="none">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:space="preserve">The active hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="perm-hw-address" transfer-ownership="none">
        <doc xml:space="preserve">The permanent hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="s390-subchannels"
                version="1.2"
                transfer-ownership="none">
        <doc xml:space="preserve">Identifies subchannels of this network device used for
communication with z/VM or s390 host.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="speed" transfer-ownership="none">
        <doc xml:space="preserve">The speed of the device.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceEthernetClass"
            c:type="NMDeviceEthernetClass"
            glib:is-gtype-struct-for="DeviceEthernet">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="DeviceGeneric"
           c:symbol-prefix="device_generic"
           c:type="NMDeviceGeneric"
           parent="Device"
           glib:type-name="NMDeviceGeneric"
           glib:get-type="nm_device_generic_get_type"
           glib:type-struct="DeviceGenericClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <method name="get_hw_address"
              c:identifier="nm_device_generic_get_hw_address">
        <doc xml:space="preserve">Gets the hardware address of the #NMDeviceGeneric</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceGeneric</doc>
            <type name="DeviceGeneric" c:type="NMDeviceGeneric*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:space="preserve">The hardware address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="type-description" transfer-ownership="none">
        <doc xml:space="preserve">A description of the specific type of device this is, or %NULL
if not known.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceGenericClass"
            c:type="NMDeviceGenericClass"
            glib:is-gtype-struct-for="DeviceGeneric">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="DeviceIPTunnel"
           c:symbol-prefix="device_ip_tunnel"
           c:type="NMDeviceIPTunnel"
           parent="Device"
           glib:type-name="NMDeviceIPTunnel"
           glib:get-type="nm_device_ip_tunnel_get_type"
           glib:type-struct="DeviceIPTunnelClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <method name="get_encapsulation_limit"
              c:identifier="nm_device_ip_tunnel_get_encapsulation_limit"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the maximum permitted encapsulation level</doc>
          <type name="guint8" c:type="guint8"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceIPTunnel</doc>
            <type name="DeviceIPTunnel" c:type="NMDeviceIPTunnel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flow_label"
              c:identifier="nm_device_ip_tunnel_get_flow_label"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the flow label assigned to tunnel packets</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceIPTunnel</doc>
            <type name="DeviceIPTunnel" c:type="NMDeviceIPTunnel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_input_key"
              c:identifier="nm_device_ip_tunnel_get_input_key"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the key used for incoming packets</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceIPTunnel</doc>
            <type name="DeviceIPTunnel" c:type="NMDeviceIPTunnel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_local"
              c:identifier="nm_device_ip_tunnel_get_local"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the local endpoint of the tunnel</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceIPTunnel</doc>
            <type name="DeviceIPTunnel" c:type="NMDeviceIPTunnel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mode"
              c:identifier="nm_device_ip_tunnel_get_mode"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the tunneling mode</doc>
          <type name="IPTunnelMode" c:type="NMIPTunnelMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceIPTunnel</doc>
            <type name="DeviceIPTunnel" c:type="NMDeviceIPTunnel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_output_key"
              c:identifier="nm_device_ip_tunnel_get_output_key"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the key used for outgoing packets</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceIPTunnel</doc>
            <type name="DeviceIPTunnel" c:type="NMDeviceIPTunnel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parent"
              c:identifier="nm_device_ip_tunnel_get_parent"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the device's parent device</doc>
          <type name="Device" c:type="NMDevice*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceIPTunnel</doc>
            <type name="DeviceIPTunnel" c:type="NMDeviceIPTunnel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_path_mtu_discovery"
              c:identifier="nm_device_ip_tunnel_get_path_mtu_discovery"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether path MTU discovery is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceIPTunnel</doc>
            <type name="DeviceIPTunnel" c:type="NMDeviceIPTunnel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_remote"
              c:identifier="nm_device_ip_tunnel_get_remote"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the remote endpoint of the tunnel</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceIPTunnel</doc>
            <type name="DeviceIPTunnel" c:type="NMDeviceIPTunnel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tos"
              c:identifier="nm_device_ip_tunnel_get_tos"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">type of service (IPv4) or traffic class (IPv6) assigned
to tunneled packets.</doc>
          <type name="guint8" c:type="guint8"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceIPTunnel</doc>
            <type name="DeviceIPTunnel" c:type="NMDeviceIPTunnel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ttl"
              c:identifier="nm_device_ip_tunnel_get_ttl"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the TTL assigned to tunneled packets</doc>
          <type name="guint8" c:type="guint8"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceIPTunnel</doc>
            <type name="DeviceIPTunnel" c:type="NMDeviceIPTunnel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="encapsulation-limit"
                version="1.2"
                transfer-ownership="none">
        <doc xml:space="preserve">How many additional levels of encapsulation are permitted to
be prepended to packets. This property applies only to IPv6
tunnels.</doc>
        <type name="guint8" c:type="guint8"/>
      </property>
      <property name="flow-label" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The flow label to assign to tunnel packets. This property
applies only to IPv6 tunnels.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="input-key" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The key used for tunneled input packets, if applicable.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="local" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The local endpoint of the tunnel.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="mode" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The tunneling mode of the device.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="output-key" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The key used for tunneled output packets, if applicable.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="parent" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The devices's parent device.</doc>
        <type name="Device"/>
      </property>
      <property name="path-mtu-discovery"
                version="1.2"
                transfer-ownership="none">
        <doc xml:space="preserve">Whether path MTU discovery is enabled on this tunnel.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="remote" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The remote endpoint of the tunnel.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="tos" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The type of service (IPv4) or traffic class (IPv6) assigned to
tunneled packets.</doc>
        <type name="guint8" c:type="guint8"/>
      </property>
      <property name="ttl" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The TTL assigned to tunneled packets. 0 is a special value
 meaning that packets inherit the TTL value</doc>
        <type name="guint8" c:type="guint8"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceIPTunnelClass"
            c:type="NMDeviceIPTunnelClass"
            glib:is-gtype-struct-for="DeviceIPTunnel">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="DeviceInfiniband"
           c:symbol-prefix="device_infiniband"
           c:type="NMDeviceInfiniband"
           parent="Device"
           glib:type-name="NMDeviceInfiniband"
           glib:get-type="nm_device_infiniband_get_type"
           glib:type-struct="DeviceInfinibandClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <method name="get_carrier"
              c:identifier="nm_device_infiniband_get_carrier">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the device has carrier</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceInfiniband</doc>
            <type name="DeviceInfiniband" c:type="NMDeviceInfiniband*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_infiniband_get_hw_address">
        <doc xml:space="preserve">Gets the hardware (MAC) address of the #NMDeviceInfiniband</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceInfiniband</doc>
            <type name="DeviceInfiniband" c:type="NMDeviceInfiniband*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="carrier" transfer-ownership="none">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:space="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceInfinibandClass"
            c:type="NMDeviceInfinibandClass"
            glib:is-gtype-struct-for="DeviceInfiniband">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="DeviceMacsec"
           c:symbol-prefix="device_macsec"
           c:type="NMDeviceMacsec"
           parent="Device"
           glib:type-name="NMDeviceMacsec"
           glib:get-type="nm_device_macsec_get_type"
           glib:type-struct="DeviceMacsecClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <method name="get_cipher_suite"
              c:identifier="nm_device_macsec_get_cipher_suite"
              version="1.6">
        <doc xml:space="preserve">Gets the set of cryptographic algorithms in use</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the set of cryptographic algorithms in use</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceMacsec</doc>
            <type name="DeviceMacsec" c:type="NMDeviceMacsec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_encoding_sa"
              c:identifier="nm_device_macsec_get_encoding_sa"
              version="1.6">
        <doc xml:space="preserve">Gets the value of the Association Number (0..3) for the Security
Association in use.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current Security Association</doc>
          <type name="guint8" c:type="guint8"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceMacsec</doc>
            <type name="DeviceMacsec" c:type="NMDeviceMacsec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_encrypt"
              c:identifier="nm_device_macsec_get_encrypt"
              version="1.6">
        <doc xml:space="preserve">Gets whether encryption of transmitted frames is enabled</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether encryption is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceMacsec</doc>
            <type name="DeviceMacsec" c:type="NMDeviceMacsec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_es"
              c:identifier="nm_device_macsec_get_es"
              version="1.6">
        <doc xml:space="preserve">Gets whether the ES (End station) bit is enabled in SecTAG for
transmitted frames</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the ES (End station) bit is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceMacsec</doc>
            <type name="DeviceMacsec" c:type="NMDeviceMacsec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_macsec_get_hw_address"
              version="1.6">
        <doc xml:space="preserve">Gets the hardware (MAC) address of the #NMDeviceMacsec</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceMacsec</doc>
            <type name="DeviceMacsec" c:type="NMDeviceMacsec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_icv_length"
              c:identifier="nm_device_macsec_get_icv_length"
              version="1.6">
        <doc xml:space="preserve">Gets the length of ICV (Integrity Check Value)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the length of ICV</doc>
          <type name="guint8" c:type="guint8"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceMacsec</doc>
            <type name="DeviceMacsec" c:type="NMDeviceMacsec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_include_sci"
              c:identifier="nm_device_macsec_get_include_sci"
              version="1.6">
        <doc xml:space="preserve">Gets whether the SCI is always included in SecTAG for transmitted
frames</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the SCI is always included</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceMacsec</doc>
            <type name="DeviceMacsec" c:type="NMDeviceMacsec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parent"
              c:identifier="nm_device_macsec_get_parent"
              version="1.6">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the device's parent device</doc>
          <type name="Device" c:type="NMDevice*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceMacsec</doc>
            <type name="DeviceMacsec" c:type="NMDeviceMacsec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_protect"
              c:identifier="nm_device_macsec_get_protect"
              version="1.6">
        <doc xml:space="preserve">Gets whether protection of transmitted frames is enabled</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether protection is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceMacsec</doc>
            <type name="DeviceMacsec" c:type="NMDeviceMacsec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_replay_protect"
              c:identifier="nm_device_macsec_get_replay_protect"
              version="1.6">
        <doc xml:space="preserve">Gets whether replay protection is enabled</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether replay protection is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceMacsec</doc>
            <type name="DeviceMacsec" c:type="NMDeviceMacsec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_scb"
              c:identifier="nm_device_macsec_get_scb"
              version="1.6">
        <doc xml:space="preserve">Gets whether the SCB (Single Copy Broadcast) bit is enabled in
SecTAG for transmitted frames</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the SCB (Single Copy Broadcast) bit is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceMacsec</doc>
            <type name="DeviceMacsec" c:type="NMDeviceMacsec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sci"
              c:identifier="nm_device_macsec_get_sci"
              version="1.6">
        <doc xml:space="preserve">Gets the Secure Channel Identifier in use</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the SCI</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceMacsec</doc>
            <type name="DeviceMacsec" c:type="NMDeviceMacsec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_validation"
              c:identifier="nm_device_macsec_get_validation"
              version="1.6">
        <doc xml:space="preserve">Gets the validation mode for incoming packets (strict, check,
disabled)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the validation mode</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceMacsec</doc>
            <type name="DeviceMacsec" c:type="NMDeviceMacsec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_window"
              c:identifier="nm_device_macsec_get_window"
              version="1.6">
        <doc xml:space="preserve">Gets the size of the replay window</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">size of the replay window</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceMacsec</doc>
            <type name="DeviceMacsec" c:type="NMDeviceMacsec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="cipher-suite" version="1.6" transfer-ownership="none">
        <doc xml:space="preserve">The set of cryptographic algorithms in use.</doc>
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="encoding-sa" version="1.6" transfer-ownership="none">
        <doc xml:space="preserve">The value of the Association Number (0..3) for the Security
Association in use.</doc>
        <type name="guint8" c:type="guint8"/>
      </property>
      <property name="encrypt" version="1.6" transfer-ownership="none">
        <doc xml:space="preserve">Whether encryption of transmitted frames is enabled.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="es" version="1.6" transfer-ownership="none">
        <doc xml:space="preserve">Whether the ES (End station) bit is enabled in SecTAG for
transmitted frames.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="hw-address" version="1.6" transfer-ownership="none">
        <doc xml:space="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="icv-length" version="1.6" transfer-ownership="none">
        <doc xml:space="preserve">The length of ICV (Integrity Check Value).</doc>
        <type name="guint8" c:type="guint8"/>
      </property>
      <property name="include-sci" version="1.6" transfer-ownership="none">
        <doc xml:space="preserve">Whether the SCI is always included in SecTAG for transmitted
frames.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="parent" version="1.6" transfer-ownership="none">
        <doc xml:space="preserve">The devices's parent device.</doc>
        <type name="Device"/>
      </property>
      <property name="protect" version="1.6" transfer-ownership="none">
        <doc xml:space="preserve">Whether protection of transmitted frames is enabled.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="replay-protect" version="1.6" transfer-ownership="none">
        <doc xml:space="preserve">Whether replay protection is enabled.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="scb" version="1.6" transfer-ownership="none">
        <doc xml:space="preserve">Whether the SCB (Single Copy Broadcast) bit is enabled in
SecTAG for transmitted frames.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="sci" version="1.6" transfer-ownership="none">
        <doc xml:space="preserve">The Secure Channel Identifier in use.</doc>
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="validation" version="1.6" transfer-ownership="none">
        <doc xml:space="preserve">The validation mode for incoming packets (strict, check,
disabled).</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="window" version="1.6" transfer-ownership="none">
        <doc xml:space="preserve">The size of the replay window.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceMacsecClass"
            c:type="NMDeviceMacsecClass"
            glib:is-gtype-struct-for="DeviceMacsec">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="DeviceMacvlan"
           c:symbol-prefix="device_macvlan"
           c:type="NMDeviceMacvlan"
           parent="Device"
           glib:type-name="NMDeviceMacvlan"
           glib:get-type="nm_device_macvlan_get_type"
           glib:type-struct="DeviceMacvlanClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <method name="get_hw_address"
              c:identifier="nm_device_macvlan_get_hw_address"
              version="1.2">
        <doc xml:space="preserve">Gets the hardware (MAC) address of the #NMDeviceMacvlan</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceMacvlan</doc>
            <type name="DeviceMacvlan" c:type="NMDeviceMacvlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mode"
              c:identifier="nm_device_macvlan_get_mode"
              version="1.2">
        <doc xml:space="preserve">Gets the MACVLAN mode of the device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the MACVLAN mode. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceMacvlan</doc>
            <type name="DeviceMacvlan" c:type="NMDeviceMacvlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_no_promisc"
              c:identifier="nm_device_macvlan_get_no_promisc"
              version="1.2">
        <doc xml:space="preserve">Gets the no-promiscuous flag of the device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the no-promiscuous flag of the device.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceMacvlan</doc>
            <type name="DeviceMacvlan" c:type="NMDeviceMacvlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parent"
              c:identifier="nm_device_macvlan_get_parent"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the device's parent device</doc>
          <type name="Device" c:type="NMDevice*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceMacvlan</doc>
            <type name="DeviceMacvlan" c:type="NMDeviceMacvlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tap"
              c:identifier="nm_device_macvlan_get_tap"
              version="1.2">
        <doc xml:space="preserve">Gets the device type (MACVLAN or MACVTAP).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the device is a MACVTAP, %FALSE if it is a MACVLAN.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceMacvlan</doc>
            <type name="DeviceMacvlan" c:type="NMDeviceMacvlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="hw-address" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="mode" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The MACVLAN mode.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="no-promisc" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">Whether the device has the no-promiscuos flag.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="parent" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The devices's parent device.</doc>
        <type name="Device"/>
      </property>
      <property name="tap" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">Whether the device is a MACVTAP.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceMacvlanClass"
            c:type="NMDeviceMacvlanClass"
            glib:is-gtype-struct-for="DeviceMacvlan">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="DeviceModem"
           c:symbol-prefix="device_modem"
           c:type="NMDeviceModem"
           parent="Device"
           glib:type-name="NMDeviceModem"
           glib:get-type="nm_device_modem_get_type"
           glib:type-struct="DeviceModemClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <method name="get_current_capabilities"
              c:identifier="nm_device_modem_get_current_capabilities">
        <doc xml:space="preserve">Returns a bitfield of the generic access technology families the modem
supports without a firmware reload or reinitialization.  This value
represents the network types the modem can immediately connect to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the generic access technology families the modem supports without
a firmware reload or other reinitialization</doc>
          <type name="DeviceModemCapabilities"
                c:type="NMDeviceModemCapabilities"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceModem</doc>
            <type name="DeviceModem" c:type="NMDeviceModem*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_modem_capabilities"
              c:identifier="nm_device_modem_get_modem_capabilities">
        <doc xml:space="preserve">Returns a bitfield of the generic access technology families the modem
supports.  Not all capabilities are available concurrently however; some
may require a firmware reload or reinitialization.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the generic access technology families the modem supports</doc>
          <type name="DeviceModemCapabilities"
                c:type="NMDeviceModemCapabilities"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceModem</doc>
            <type name="DeviceModem" c:type="NMDeviceModem*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="current-capabilities" transfer-ownership="none">
        <doc xml:space="preserve">The generic family of access technologies the modem currently supports
without a firmware reload or reinitialization.</doc>
        <type name="DeviceModemCapabilities"/>
      </property>
      <property name="modem-capabilities" transfer-ownership="none">
        <doc xml:space="preserve">The generic family of access technologies the modem supports.  Not all
capabilities are available at the same time however; some modems require
a firmware reload or other reinitialization to switch between eg
CDMA/EVDO and GSM/UMTS.</doc>
        <type name="DeviceModemCapabilities"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <bitfield name="DeviceModemCapabilities"
              glib:type-name="NMDeviceModemCapabilities"
              glib:get-type="nm_device_modem_capabilities_get_type"
              c:type="NMDeviceModemCapabilities">
      <doc xml:space="preserve">#NMDeviceModemCapabilities values indicate the generic radio access
technology families a modem device supports.  For more information on the
specific access technologies the device supports use the ModemManager D-Bus
API.</doc>
      <member name="none"
              value="0"
              c:identifier="NM_DEVICE_MODEM_CAPABILITY_NONE"
              glib:nick="none">
        <doc xml:space="preserve">modem has no usable capabilities</doc>
      </member>
      <member name="pots"
              value="1"
              c:identifier="NM_DEVICE_MODEM_CAPABILITY_POTS"
              glib:nick="pots">
        <doc xml:space="preserve">modem uses the analog wired telephone
network and is not a wireless/cellular device</doc>
      </member>
      <member name="cdma_evdo"
              value="2"
              c:identifier="NM_DEVICE_MODEM_CAPABILITY_CDMA_EVDO"
              glib:nick="cdma-evdo">
        <doc xml:space="preserve">modem supports at least one of CDMA
1xRTT, EVDO revision 0, EVDO revision A, or EVDO revision B</doc>
      </member>
      <member name="gsm_umts"
              value="4"
              c:identifier="NM_DEVICE_MODEM_CAPABILITY_GSM_UMTS"
              glib:nick="gsm-umts">
        <doc xml:space="preserve">modem supports at least one of GSM,
GPRS, EDGE, UMTS, HSDPA, HSUPA, or HSPA+ packet switched data capability</doc>
      </member>
      <member name="lte"
              value="8"
              c:identifier="NM_DEVICE_MODEM_CAPABILITY_LTE"
              glib:nick="lte">
        <doc xml:space="preserve">modem has LTE data capability</doc>
      </member>
    </bitfield>
    <record name="DeviceModemClass"
            c:type="NMDeviceModemClass"
            glib:is-gtype-struct-for="DeviceModem">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="DeviceOlpcMesh"
           c:symbol-prefix="device_olpc_mesh"
           c:type="NMDeviceOlpcMesh"
           parent="Device"
           glib:type-name="NMDeviceOlpcMesh"
           glib:get-type="nm_device_olpc_mesh_get_type"
           glib:type-struct="DeviceOlpcMeshClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <method name="get_active_channel"
              c:identifier="nm_device_olpc_mesh_get_active_channel">
        <doc xml:space="preserve">Returns the active channel of the #NMDeviceOlpcMesh device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">active channel of the device</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceOlpcMesh</doc>
            <type name="DeviceOlpcMesh" c:type="NMDeviceOlpcMesh*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_companion"
              c:identifier="nm_device_olpc_mesh_get_companion">
        <doc xml:space="preserve">Gets the companion device of the #NMDeviceOlpcMesh.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the companion of the device of %NULL</doc>
          <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceOlpcMesh</doc>
            <type name="DeviceOlpcMesh" c:type="NMDeviceOlpcMesh*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_olpc_mesh_get_hw_address">
        <doc xml:space="preserve">Gets the hardware (MAC) address of the #NMDeviceOlpcMesh</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceOlpcMesh</doc>
            <type name="DeviceOlpcMesh" c:type="NMDeviceOlpcMesh*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="active-channel" transfer-ownership="none">
        <doc xml:space="preserve">The device's active channel.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="companion" transfer-ownership="none">
        <doc xml:space="preserve">The companion device.</doc>
        <type name="DeviceWifi"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:space="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceOlpcMeshClass"
            c:type="NMDeviceOlpcMeshClass"
            glib:is-gtype-struct-for="DeviceOlpcMesh">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="DeviceState"
                 glib:type-name="NMDeviceState"
                 glib:get-type="nm_device_state_get_type"
                 c:type="NMDeviceState">
      <member name="unknown"
              value="0"
              c:identifier="NM_DEVICE_STATE_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">the device's state is unknown</doc>
      </member>
      <member name="unmanaged"
              value="10"
              c:identifier="NM_DEVICE_STATE_UNMANAGED"
              glib:nick="unmanaged">
        <doc xml:space="preserve">the device is recognized, but not managed by
  NetworkManager</doc>
      </member>
      <member name="unavailable"
              value="20"
              c:identifier="NM_DEVICE_STATE_UNAVAILABLE"
              glib:nick="unavailable">
        <doc xml:space="preserve">the device is managed by NetworkManager, but
  is not available for use.  Reasons may include the wireless switched off,
  missing firmware, no ethernet carrier, missing supplicant or modem manager,
  etc.</doc>
      </member>
      <member name="disconnected"
              value="30"
              c:identifier="NM_DEVICE_STATE_DISCONNECTED"
              glib:nick="disconnected">
        <doc xml:space="preserve">the device can be activated, but is currently
  idle and not connected to a network.</doc>
      </member>
      <member name="prepare"
              value="40"
              c:identifier="NM_DEVICE_STATE_PREPARE"
              glib:nick="prepare">
        <doc xml:space="preserve">the device is preparing the connection to the
  network.  This may include operations like changing the MAC address,
  setting physical link properties, and anything else required to connect
  to the requested network.</doc>
      </member>
      <member name="config"
              value="50"
              c:identifier="NM_DEVICE_STATE_CONFIG"
              glib:nick="config">
        <doc xml:space="preserve">the device is connecting to the requested network.
  This may include operations like associating with the WiFi AP, dialing
  the modem, connecting to the remote Bluetooth device, etc.</doc>
      </member>
      <member name="need_auth"
              value="60"
              c:identifier="NM_DEVICE_STATE_NEED_AUTH"
              glib:nick="need-auth">
        <doc xml:space="preserve">the device requires more information to continue
  connecting to the requested network.  This includes secrets like WiFi
  passphrases, login passwords, PIN codes, etc.</doc>
      </member>
      <member name="ip_config"
              value="70"
              c:identifier="NM_DEVICE_STATE_IP_CONFIG"
              glib:nick="ip-config">
        <doc xml:space="preserve">the device is requesting IPv4 and/or IPv6
  addresses and routing information from the network.</doc>
      </member>
      <member name="ip_check"
              value="80"
              c:identifier="NM_DEVICE_STATE_IP_CHECK"
              glib:nick="ip-check">
        <doc xml:space="preserve">the device is checking whether further action is
  required for the requested network connection.  This may include checking
  whether only local network access is available, whether a captive portal
  is blocking access to the Internet, etc.</doc>
      </member>
      <member name="secondaries"
              value="90"
              c:identifier="NM_DEVICE_STATE_SECONDARIES"
              glib:nick="secondaries">
        <doc xml:space="preserve">the device is waiting for a secondary
  connection (like a VPN) which must activated before the device can be
  activated</doc>
      </member>
      <member name="activated"
              value="100"
              c:identifier="NM_DEVICE_STATE_ACTIVATED"
              glib:nick="activated">
        <doc xml:space="preserve">the device has a network connection, either local
  or global.</doc>
      </member>
      <member name="deactivating"
              value="110"
              c:identifier="NM_DEVICE_STATE_DEACTIVATING"
              glib:nick="deactivating">
        <doc xml:space="preserve">a disconnection from the current network
  connection was requested, and the device is cleaning up resources used for
  that connection.  The network connection may still be valid.</doc>
      </member>
      <member name="failed"
              value="120"
              c:identifier="NM_DEVICE_STATE_FAILED"
              glib:nick="failed">
        <doc xml:space="preserve">the device failed to connect to the requested
  network and is cleaning up the connection request</doc>
      </member>
    </enumeration>
    <enumeration name="DeviceStateReason"
                 glib:type-name="NMDeviceStateReason"
                 glib:get-type="nm_device_state_reason_get_type"
                 c:type="NMDeviceStateReason">
      <doc xml:space="preserve">Device state change reason codes</doc>
      <member name="none"
              value="0"
              c:identifier="NM_DEVICE_STATE_REASON_NONE"
              glib:nick="none">
        <doc xml:space="preserve">No reason given</doc>
      </member>
      <member name="unknown"
              value="1"
              c:identifier="NM_DEVICE_STATE_REASON_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">Unknown error</doc>
      </member>
      <member name="now_managed"
              value="2"
              c:identifier="NM_DEVICE_STATE_REASON_NOW_MANAGED"
              glib:nick="now-managed">
        <doc xml:space="preserve">Device is now managed</doc>
      </member>
      <member name="now_unmanaged"
              value="3"
              c:identifier="NM_DEVICE_STATE_REASON_NOW_UNMANAGED"
              glib:nick="now-unmanaged">
        <doc xml:space="preserve">Device is now unmanaged</doc>
      </member>
      <member name="config_failed"
              value="4"
              c:identifier="NM_DEVICE_STATE_REASON_CONFIG_FAILED"
              glib:nick="config-failed">
        <doc xml:space="preserve">The device could not be readied for configuration</doc>
      </member>
      <member name="ip_config_unavailable"
              value="5"
              c:identifier="NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE"
              glib:nick="ip-config-unavailable">
        <doc xml:space="preserve">IP configuration could not be reserved (no available address, timeout, etc)</doc>
      </member>
      <member name="ip_config_expired"
              value="6"
              c:identifier="NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED"
              glib:nick="ip-config-expired">
        <doc xml:space="preserve">The IP config is no longer valid</doc>
      </member>
      <member name="no_secrets"
              value="7"
              c:identifier="NM_DEVICE_STATE_REASON_NO_SECRETS"
              glib:nick="no-secrets">
        <doc xml:space="preserve">Secrets were required, but not provided</doc>
      </member>
      <member name="supplicant_disconnect"
              value="8"
              c:identifier="NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT"
              glib:nick="supplicant-disconnect">
        <doc xml:space="preserve">802.1x supplicant disconnected</doc>
      </member>
      <member name="supplicant_config_failed"
              value="9"
              c:identifier="NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED"
              glib:nick="supplicant-config-failed">
        <doc xml:space="preserve">802.1x supplicant configuration failed</doc>
      </member>
      <member name="supplicant_failed"
              value="10"
              c:identifier="NM_DEVICE_STATE_REASON_SUPPLICANT_FAILED"
              glib:nick="supplicant-failed">
        <doc xml:space="preserve">802.1x supplicant failed</doc>
      </member>
      <member name="supplicant_timeout"
              value="11"
              c:identifier="NM_DEVICE_STATE_REASON_SUPPLICANT_TIMEOUT"
              glib:nick="supplicant-timeout">
        <doc xml:space="preserve">802.1x supplicant took too long to authenticate</doc>
      </member>
      <member name="ppp_start_failed"
              value="12"
              c:identifier="NM_DEVICE_STATE_REASON_PPP_START_FAILED"
              glib:nick="ppp-start-failed">
        <doc xml:space="preserve">PPP service failed to start</doc>
      </member>
      <member name="ppp_disconnect"
              value="13"
              c:identifier="NM_DEVICE_STATE_REASON_PPP_DISCONNECT"
              glib:nick="ppp-disconnect">
        <doc xml:space="preserve">PPP service disconnected</doc>
      </member>
      <member name="ppp_failed"
              value="14"
              c:identifier="NM_DEVICE_STATE_REASON_PPP_FAILED"
              glib:nick="ppp-failed">
        <doc xml:space="preserve">PPP failed</doc>
      </member>
      <member name="dhcp_start_failed"
              value="15"
              c:identifier="NM_DEVICE_STATE_REASON_DHCP_START_FAILED"
              glib:nick="dhcp-start-failed">
        <doc xml:space="preserve">DHCP client failed to start</doc>
      </member>
      <member name="dhcp_error"
              value="16"
              c:identifier="NM_DEVICE_STATE_REASON_DHCP_ERROR"
              glib:nick="dhcp-error">
        <doc xml:space="preserve">DHCP client error</doc>
      </member>
      <member name="dhcp_failed"
              value="17"
              c:identifier="NM_DEVICE_STATE_REASON_DHCP_FAILED"
              glib:nick="dhcp-failed">
        <doc xml:space="preserve">DHCP client failed</doc>
      </member>
      <member name="shared_start_failed"
              value="18"
              c:identifier="NM_DEVICE_STATE_REASON_SHARED_START_FAILED"
              glib:nick="shared-start-failed">
        <doc xml:space="preserve">Shared connection service failed to start</doc>
      </member>
      <member name="shared_failed"
              value="19"
              c:identifier="NM_DEVICE_STATE_REASON_SHARED_FAILED"
              glib:nick="shared-failed">
        <doc xml:space="preserve">Shared connection service failed</doc>
      </member>
      <member name="autoip_start_failed"
              value="20"
              c:identifier="NM_DEVICE_STATE_REASON_AUTOIP_START_FAILED"
              glib:nick="autoip-start-failed">
        <doc xml:space="preserve">AutoIP service failed to start</doc>
      </member>
      <member name="autoip_error"
              value="21"
              c:identifier="NM_DEVICE_STATE_REASON_AUTOIP_ERROR"
              glib:nick="autoip-error">
        <doc xml:space="preserve">AutoIP service error</doc>
      </member>
      <member name="autoip_failed"
              value="22"
              c:identifier="NM_DEVICE_STATE_REASON_AUTOIP_FAILED"
              glib:nick="autoip-failed">
        <doc xml:space="preserve">AutoIP service failed</doc>
      </member>
      <member name="modem_busy"
              value="23"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_BUSY"
              glib:nick="modem-busy">
        <doc xml:space="preserve">The line is busy</doc>
      </member>
      <member name="modem_no_dial_tone"
              value="24"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_NO_DIAL_TONE"
              glib:nick="modem-no-dial-tone">
        <doc xml:space="preserve">No dial tone</doc>
      </member>
      <member name="modem_no_carrier"
              value="25"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_NO_CARRIER"
              glib:nick="modem-no-carrier">
        <doc xml:space="preserve">No carrier could be established</doc>
      </member>
      <member name="modem_dial_timeout"
              value="26"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_DIAL_TIMEOUT"
              glib:nick="modem-dial-timeout">
        <doc xml:space="preserve">The dialing request timed out</doc>
      </member>
      <member name="modem_dial_failed"
              value="27"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_DIAL_FAILED"
              glib:nick="modem-dial-failed">
        <doc xml:space="preserve">The dialing attempt failed</doc>
      </member>
      <member name="modem_init_failed"
              value="28"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED"
              glib:nick="modem-init-failed">
        <doc xml:space="preserve">Modem initialization failed</doc>
      </member>
      <member name="gsm_apn_failed"
              value="29"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_APN_FAILED"
              glib:nick="gsm-apn-failed">
        <doc xml:space="preserve">Failed to select the specified APN</doc>
      </member>
      <member name="gsm_registration_not_searching"
              value="30"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_REGISTRATION_NOT_SEARCHING"
              glib:nick="gsm-registration-not-searching">
        <doc xml:space="preserve">Not searching for networks</doc>
      </member>
      <member name="gsm_registration_denied"
              value="31"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_REGISTRATION_DENIED"
              glib:nick="gsm-registration-denied">
        <doc xml:space="preserve">Network registration denied</doc>
      </member>
      <member name="gsm_registration_timeout"
              value="32"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_REGISTRATION_TIMEOUT"
              glib:nick="gsm-registration-timeout">
        <doc xml:space="preserve">Network registration timed out</doc>
      </member>
      <member name="gsm_registration_failed"
              value="33"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_REGISTRATION_FAILED"
              glib:nick="gsm-registration-failed">
        <doc xml:space="preserve">Failed to register with the requested network</doc>
      </member>
      <member name="gsm_pin_check_failed"
              value="34"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_PIN_CHECK_FAILED"
              glib:nick="gsm-pin-check-failed">
        <doc xml:space="preserve">PIN check failed</doc>
      </member>
      <member name="firmware_missing"
              value="35"
              c:identifier="NM_DEVICE_STATE_REASON_FIRMWARE_MISSING"
              glib:nick="firmware-missing">
        <doc xml:space="preserve">Necessary firmware for the device may be missing</doc>
      </member>
      <member name="removed"
              value="36"
              c:identifier="NM_DEVICE_STATE_REASON_REMOVED"
              glib:nick="removed">
        <doc xml:space="preserve">The device was removed</doc>
      </member>
      <member name="sleeping"
              value="37"
              c:identifier="NM_DEVICE_STATE_REASON_SLEEPING"
              glib:nick="sleeping">
        <doc xml:space="preserve">NetworkManager went to sleep</doc>
      </member>
      <member name="connection_removed"
              value="38"
              c:identifier="NM_DEVICE_STATE_REASON_CONNECTION_REMOVED"
              glib:nick="connection-removed">
        <doc xml:space="preserve">The device's active connection disappeared</doc>
      </member>
      <member name="user_requested"
              value="39"
              c:identifier="NM_DEVICE_STATE_REASON_USER_REQUESTED"
              glib:nick="user-requested">
        <doc xml:space="preserve">Device disconnected by user or client</doc>
      </member>
      <member name="carrier"
              value="40"
              c:identifier="NM_DEVICE_STATE_REASON_CARRIER"
              glib:nick="carrier">
        <doc xml:space="preserve">Carrier/link changed</doc>
      </member>
      <member name="connection_assumed"
              value="41"
              c:identifier="NM_DEVICE_STATE_REASON_CONNECTION_ASSUMED"
              glib:nick="connection-assumed">
        <doc xml:space="preserve">The device's existing connection was assumed</doc>
      </member>
      <member name="supplicant_available"
              value="42"
              c:identifier="NM_DEVICE_STATE_REASON_SUPPLICANT_AVAILABLE"
              glib:nick="supplicant-available">
        <doc xml:space="preserve">The supplicant is now available</doc>
      </member>
      <member name="modem_not_found"
              value="43"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_NOT_FOUND"
              glib:nick="modem-not-found">
        <doc xml:space="preserve">The modem could not be found</doc>
      </member>
      <member name="bt_failed"
              value="44"
              c:identifier="NM_DEVICE_STATE_REASON_BT_FAILED"
              glib:nick="bt-failed">
        <doc xml:space="preserve">The Bluetooth connection failed or timed out</doc>
      </member>
      <member name="gsm_sim_not_inserted"
              value="45"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_SIM_NOT_INSERTED"
              glib:nick="gsm-sim-not-inserted">
        <doc xml:space="preserve">GSM Modem's SIM Card not inserted</doc>
      </member>
      <member name="gsm_sim_pin_required"
              value="46"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_SIM_PIN_REQUIRED"
              glib:nick="gsm-sim-pin-required">
        <doc xml:space="preserve">GSM Modem's SIM Pin required</doc>
      </member>
      <member name="gsm_sim_puk_required"
              value="47"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_SIM_PUK_REQUIRED"
              glib:nick="gsm-sim-puk-required">
        <doc xml:space="preserve">GSM Modem's SIM Puk required</doc>
      </member>
      <member name="gsm_sim_wrong"
              value="48"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_SIM_WRONG"
              glib:nick="gsm-sim-wrong">
        <doc xml:space="preserve">GSM Modem's SIM wrong</doc>
      </member>
      <member name="infiniband_mode"
              value="49"
              c:identifier="NM_DEVICE_STATE_REASON_INFINIBAND_MODE"
              glib:nick="infiniband-mode">
        <doc xml:space="preserve">InfiniBand device does not support connected mode</doc>
      </member>
      <member name="dependency_failed"
              value="50"
              c:identifier="NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED"
              glib:nick="dependency-failed">
        <doc xml:space="preserve">A dependency of the connection failed</doc>
      </member>
      <member name="br2684_failed"
              value="51"
              c:identifier="NM_DEVICE_STATE_REASON_BR2684_FAILED"
              glib:nick="br2684-failed">
        <doc xml:space="preserve">Problem with the RFC 2684 Ethernet over ADSL bridge</doc>
      </member>
      <member name="modem_manager_unavailable"
              value="52"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_MANAGER_UNAVAILABLE"
              glib:nick="modem-manager-unavailable">
        <doc xml:space="preserve">ModemManager not running</doc>
      </member>
      <member name="ssid_not_found"
              value="53"
              c:identifier="NM_DEVICE_STATE_REASON_SSID_NOT_FOUND"
              glib:nick="ssid-not-found">
        <doc xml:space="preserve">The WiFi network could not be found</doc>
      </member>
      <member name="secondary_connection_failed"
              value="54"
              c:identifier="NM_DEVICE_STATE_REASON_SECONDARY_CONNECTION_FAILED"
              glib:nick="secondary-connection-failed">
        <doc xml:space="preserve">A secondary connection of the base connection failed</doc>
      </member>
      <member name="dcb_fcoe_failed"
              value="55"
              c:identifier="NM_DEVICE_STATE_REASON_DCB_FCOE_FAILED"
              glib:nick="dcb-fcoe-failed">
        <doc xml:space="preserve">DCB or FCoE setup failed</doc>
      </member>
      <member name="teamd_control_failed"
              value="56"
              c:identifier="NM_DEVICE_STATE_REASON_TEAMD_CONTROL_FAILED"
              glib:nick="teamd-control-failed">
        <doc xml:space="preserve">teamd control failed</doc>
      </member>
      <member name="modem_failed"
              value="57"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_FAILED"
              glib:nick="modem-failed">
        <doc xml:space="preserve">Modem failed or no longer available</doc>
      </member>
      <member name="modem_available"
              value="58"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_AVAILABLE"
              glib:nick="modem-available">
        <doc xml:space="preserve">Modem now ready and available</doc>
      </member>
      <member name="sim_pin_incorrect"
              value="59"
              c:identifier="NM_DEVICE_STATE_REASON_SIM_PIN_INCORRECT"
              glib:nick="sim-pin-incorrect">
        <doc xml:space="preserve">SIM PIN was incorrect</doc>
      </member>
      <member name="new_activation"
              value="60"
              c:identifier="NM_DEVICE_STATE_REASON_NEW_ACTIVATION"
              glib:nick="new-activation">
        <doc xml:space="preserve">New connection activation was enqueued</doc>
      </member>
      <member name="parent_changed"
              value="61"
              c:identifier="NM_DEVICE_STATE_REASON_PARENT_CHANGED"
              glib:nick="parent-changed">
        <doc xml:space="preserve">the device's parent changed</doc>
      </member>
      <member name="parent_managed_changed"
              value="62"
              c:identifier="NM_DEVICE_STATE_REASON_PARENT_MANAGED_CHANGED"
              glib:nick="parent-managed-changed">
        <doc xml:space="preserve">the device parent's management changed</doc>
      </member>
    </enumeration>
    <class name="DeviceTeam"
           c:symbol-prefix="device_team"
           c:type="NMDeviceTeam"
           parent="Device"
           glib:type-name="NMDeviceTeam"
           glib:get-type="nm_device_team_get_type"
           glib:type-struct="DeviceTeamClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <method name="get_carrier" c:identifier="nm_device_team_get_carrier">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the device has carrier</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceTeam</doc>
            <type name="DeviceTeam" c:type="NMDeviceTeam*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_config"
              c:identifier="nm_device_team_get_config"
              version="1.4">
        <doc xml:space="preserve">Gets the current JSON configuration of the #NMDeviceTeam</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current configuration. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceTeam</doc>
            <type name="DeviceTeam" c:type="NMDeviceTeam*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_team_get_hw_address">
        <doc xml:space="preserve">Gets the hardware (MAC) address of the #NMDeviceTeam</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceTeam</doc>
            <type name="DeviceTeam" c:type="NMDeviceTeam*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_slaves" c:identifier="nm_device_team_get_slaves">
        <doc xml:space="preserve">Gets the devices currently enslaved to @device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GPtrArray containing
#NMDevices that are slaves of @device. This is the internal
copy used by the device, and must not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="Device"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceTeam</doc>
            <type name="DeviceTeam" c:type="NMDeviceTeam*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="carrier" transfer-ownership="none">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="config" version="1.4" transfer-ownership="none">
        <doc xml:space="preserve">The current JSON configuration of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:space="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="slaves" transfer-ownership="none">
        <doc xml:space="preserve">The devices enslaved to the team device.

Element-type: NMDevice</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceTeamClass"
            c:type="NMDeviceTeamClass"
            glib:is-gtype-struct-for="DeviceTeam">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="DeviceTun"
           c:symbol-prefix="device_tun"
           c:type="NMDeviceTun"
           parent="Device"
           glib:type-name="NMDeviceTun"
           glib:get-type="nm_device_tun_get_type"
           glib:type-struct="DeviceTunClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <method name="get_group"
              c:identifier="nm_device_tun_get_group"
              version="1.2">
        <doc xml:space="preserve">Gets the tunnel group.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the gid of the tunnel group, or -1 if it has no owner.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceTun</doc>
            <type name="DeviceTun" c:type="NMDeviceTun*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_tun_get_hw_address"
              version="1.2">
        <doc xml:space="preserve">Gets the hardware (MAC) address of the #NMDeviceTun</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceTun</doc>
            <type name="DeviceTun" c:type="NMDeviceTun*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mode"
              c:identifier="nm_device_tun_get_mode"
              version="1.2">
        <doc xml:space="preserve">Returns the TUN/TAP mode for the device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">'tun' or 'tap'</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceTun</doc>
            <type name="DeviceTun" c:type="NMDeviceTun*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_multi_queue"
              c:identifier="nm_device_tun_get_multi_queue"
              version="1.2">
        <doc xml:space="preserve">Returns whether the #NMDeviceTun has the IFF_MULTI_QUEUE flag.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the device doesn't have the flag, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceTun</doc>
            <type name="DeviceTun" c:type="NMDeviceTun*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_no_pi" c:identifier="nm_device_tun_get_no_pi">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <type name="DeviceTun" c:type="NMDeviceTun*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_owner"
              c:identifier="nm_device_tun_get_owner"
              version="1.2">
        <doc xml:space="preserve">Gets the tunnel owner.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the uid of the tunnel owner, or -1 if it has no owner.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceTun</doc>
            <type name="DeviceTun" c:type="NMDeviceTun*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vnet_hdr"
              c:identifier="nm_device_tun_get_vnet_hdr"
              version="1.2">
        <doc xml:space="preserve">Returns whether the #NMDeviceTun has the IFF_VNET_HDR flag.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the device has the flag, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceTun</doc>
            <type name="DeviceTun" c:type="NMDeviceTun*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="group" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The gid of the tunnel group, or -1 if it has no owner.</doc>
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="hw-address" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="mode" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The tunnel mode, either "tun" or "tap".</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="multi-queue" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The tunnel's "TUN_TAP_MQ" flag; true if callers can connect to
the tap device multiple times, for multiple send/receive
queues.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="no-pi" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The tunnel's "TUN_NO_PI" flag; true if no protocol info is
prepended to the tunnel packets.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="owner" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The uid of the tunnel owner, or -1 if it has no owner.</doc>
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="vnet-hdr" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The tunnel's "TUN_VNET_HDR" flag; true if the tunnel packets
include a virtio network header.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceTunClass"
            c:type="NMDeviceTunClass"
            glib:is-gtype-struct-for="DeviceTun">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="DeviceType"
                 glib:type-name="NMDeviceType"
                 glib:get-type="nm_device_type_get_type"
                 c:type="NMDeviceType">
      <doc xml:space="preserve">#NMDeviceType values indicate the type of hardware represented by a
device object.</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_DEVICE_TYPE_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">unknown device</doc>
      </member>
      <member name="ethernet"
              value="1"
              c:identifier="NM_DEVICE_TYPE_ETHERNET"
              glib:nick="ethernet">
        <doc xml:space="preserve">a wired ethernet device</doc>
      </member>
      <member name="wifi"
              value="2"
              c:identifier="NM_DEVICE_TYPE_WIFI"
              glib:nick="wifi">
        <doc xml:space="preserve">an 802.11 WiFi device</doc>
      </member>
      <member name="unused1"
              value="3"
              c:identifier="NM_DEVICE_TYPE_UNUSED1"
              glib:nick="unused1">
        <doc xml:space="preserve">not used</doc>
      </member>
      <member name="unused2"
              value="4"
              c:identifier="NM_DEVICE_TYPE_UNUSED2"
              glib:nick="unused2">
        <doc xml:space="preserve">not used</doc>
      </member>
      <member name="bt"
              value="5"
              c:identifier="NM_DEVICE_TYPE_BT"
              glib:nick="bt">
        <doc xml:space="preserve">a Bluetooth device supporting PAN or DUN access protocols</doc>
      </member>
      <member name="olpc_mesh"
              value="6"
              c:identifier="NM_DEVICE_TYPE_OLPC_MESH"
              glib:nick="olpc-mesh">
        <doc xml:space="preserve">an OLPC XO mesh networking device</doc>
      </member>
      <member name="wimax"
              value="7"
              c:identifier="NM_DEVICE_TYPE_WIMAX"
              glib:nick="wimax">
        <doc xml:space="preserve">an 802.16e Mobile WiMAX broadband device</doc>
      </member>
      <member name="modem"
              value="8"
              c:identifier="NM_DEVICE_TYPE_MODEM"
              glib:nick="modem">
        <doc xml:space="preserve">a modem supporting analog telephone, CDMA/EVDO,
GSM/UMTS, or LTE network access protocols</doc>
      </member>
      <member name="infiniband"
              value="9"
              c:identifier="NM_DEVICE_TYPE_INFINIBAND"
              glib:nick="infiniband">
        <doc xml:space="preserve">an IP-over-InfiniBand device</doc>
      </member>
      <member name="bond"
              value="10"
              c:identifier="NM_DEVICE_TYPE_BOND"
              glib:nick="bond">
        <doc xml:space="preserve">a bond master interface</doc>
      </member>
      <member name="vlan"
              value="11"
              c:identifier="NM_DEVICE_TYPE_VLAN"
              glib:nick="vlan">
        <doc xml:space="preserve">an 802.1Q VLAN interface</doc>
      </member>
      <member name="adsl"
              value="12"
              c:identifier="NM_DEVICE_TYPE_ADSL"
              glib:nick="adsl">
        <doc xml:space="preserve">ADSL modem</doc>
      </member>
      <member name="bridge"
              value="13"
              c:identifier="NM_DEVICE_TYPE_BRIDGE"
              glib:nick="bridge">
        <doc xml:space="preserve">a bridge master interface</doc>
      </member>
      <member name="generic"
              value="14"
              c:identifier="NM_DEVICE_TYPE_GENERIC"
              glib:nick="generic">
        <doc xml:space="preserve">generic support for unrecognized device types</doc>
      </member>
      <member name="team"
              value="15"
              c:identifier="NM_DEVICE_TYPE_TEAM"
              glib:nick="team">
        <doc xml:space="preserve">a team master interface</doc>
      </member>
      <member name="tun"
              value="16"
              c:identifier="NM_DEVICE_TYPE_TUN"
              glib:nick="tun">
        <doc xml:space="preserve">a TUN or TAP interface</doc>
      </member>
      <member name="ip_tunnel"
              value="17"
              c:identifier="NM_DEVICE_TYPE_IP_TUNNEL"
              glib:nick="ip-tunnel">
        <doc xml:space="preserve">a IP tunnel interface</doc>
      </member>
      <member name="macvlan"
              value="18"
              c:identifier="NM_DEVICE_TYPE_MACVLAN"
              glib:nick="macvlan">
        <doc xml:space="preserve">a MACVLAN interface</doc>
      </member>
      <member name="vxlan"
              value="19"
              c:identifier="NM_DEVICE_TYPE_VXLAN"
              glib:nick="vxlan">
        <doc xml:space="preserve">a VXLAN interface</doc>
      </member>
      <member name="veth"
              value="20"
              c:identifier="NM_DEVICE_TYPE_VETH"
              glib:nick="veth">
        <doc xml:space="preserve">a VETH interface</doc>
      </member>
      <member name="macsec"
              value="21"
              c:identifier="NM_DEVICE_TYPE_MACSEC"
              glib:nick="macsec">
        <doc xml:space="preserve">a MACsec interface</doc>
      </member>
      <member name="dummy"
              value="22"
              c:identifier="NM_DEVICE_TYPE_DUMMY"
              glib:nick="dummy">
        <doc xml:space="preserve">a dummy interface</doc>
      </member>
    </enumeration>
    <class name="DeviceVlan"
           c:symbol-prefix="device_vlan"
           c:type="NMDeviceVlan"
           parent="Device"
           glib:type-name="NMDeviceVlan"
           glib:get-type="nm_device_vlan_get_type"
           glib:type-struct="DeviceVlanClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <method name="get_carrier" c:identifier="nm_device_vlan_get_carrier">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the device has carrier</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVlan</doc>
            <type name="DeviceVlan" c:type="NMDeviceVlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_vlan_get_hw_address">
        <doc xml:space="preserve">Gets the hardware (MAC) address of the #NMDeviceVlan</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVlan</doc>
            <type name="DeviceVlan" c:type="NMDeviceVlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parent" c:identifier="nm_device_vlan_get_parent">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the device's parent device</doc>
          <type name="Device" c:type="NMDevice*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVlan</doc>
            <type name="DeviceVlan" c:type="NMDeviceVlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vlan_id" c:identifier="nm_device_vlan_get_vlan_id">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the device's VLAN ID</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVlan</doc>
            <type name="DeviceVlan" c:type="NMDeviceVlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="carrier" transfer-ownership="none">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:space="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="parent" transfer-ownership="none">
        <doc xml:space="preserve">The devices's parent device.</doc>
        <type name="Device"/>
      </property>
      <property name="vlan-id" transfer-ownership="none">
        <doc xml:space="preserve">The device's VLAN ID.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceVlanClass"
            c:type="NMDeviceVlanClass"
            glib:is-gtype-struct-for="DeviceVlan">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="DeviceVxlan"
           c:symbol-prefix="device_vxlan"
           c:type="NMDeviceVxlan"
           parent="Device"
           glib:type-name="NMDeviceVxlan"
           glib:get-type="nm_device_vxlan_get_type"
           glib:type-struct="DeviceVxlanClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <method name="get_ageing"
              c:identifier="nm_device_vxlan_get_ageing"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the lifetime in seconds of FDB entries learnt by the kernel</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVxlan</doc>
            <type name="DeviceVxlan" c:type="NMDeviceVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_carrier"
              c:identifier="nm_device_vxlan_get_carrier"
              version="1.2">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the device has carrier.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVxlan</doc>
            <type name="DeviceVxlan" c:type="NMDeviceVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dst_port"
              c:identifier="nm_device_vxlan_get_dst_port"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the UDP destination port</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVxlan</doc>
            <type name="DeviceVxlan" c:type="NMDeviceVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_group"
              c:identifier="nm_device_vxlan_get_group"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The unicast destination IP address or the multicast
IP address joined</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVxlan</doc>
            <type name="DeviceVxlan" c:type="NMDeviceVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_vxlan_get_hw_address"
              version="1.2">
        <doc xml:space="preserve">Gets the hardware (MAC) address of the #NMDeviceVxlan</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVxlan</doc>
            <type name="DeviceVxlan" c:type="NMDeviceVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_id"
              c:identifier="nm_device_vxlan_get_id"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the device's VXLAN ID.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVxlan</doc>
            <type name="DeviceVxlan" c:type="NMDeviceVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_l2miss"
              c:identifier="nm_device_vxlan_get_l2miss"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether netlink LL ADDR miss notifications are generated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVxlan</doc>
            <type name="DeviceVxlan" c:type="NMDeviceVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_l3miss"
              c:identifier="nm_device_vxlan_get_l3miss"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">wether netlink IP ADDR miss notifications are generated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVxlan</doc>
            <type name="DeviceVxlan" c:type="NMDeviceVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_learning"
              c:identifier="nm_device_vxlan_get_learning"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether address learning is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVxlan</doc>
            <type name="DeviceVxlan" c:type="NMDeviceVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_limit"
              c:identifier="nm_device_vxlan_get_limit"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the maximum number of entries that can be added to the
forwarding table</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVxlan</doc>
            <type name="DeviceVxlan" c:type="NMDeviceVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_local"
              c:identifier="nm_device_vxlan_get_local"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the source IP address to use in outgoing packets</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVxlan</doc>
            <type name="DeviceVxlan" c:type="NMDeviceVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parent"
              c:identifier="nm_device_vxlan_get_parent"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the device's parent device</doc>
          <type name="Device" c:type="NMDevice*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVxlan</doc>
            <type name="DeviceVxlan" c:type="NMDeviceVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_proxy"
              c:identifier="nm_device_vxlan_get_proxy"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether ARP proxy is turned on</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVxlan</doc>
            <type name="DeviceVxlan" c:type="NMDeviceVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_rsc"
              c:identifier="nm_device_vxlan_get_rsc"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether route short circuit is turned on</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVxlan</doc>
            <type name="DeviceVxlan" c:type="NMDeviceVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_src_port_max"
              c:identifier="nm_device_vxlan_get_src_port_max"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the maximum UDP source port</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVxlan</doc>
            <type name="DeviceVxlan" c:type="NMDeviceVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_src_port_min"
              c:identifier="nm_device_vxlan_get_src_port_min"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the minimum UDP source port</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVxlan</doc>
            <type name="DeviceVxlan" c:type="NMDeviceVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tos"
              c:identifier="nm_device_vxlan_get_tos"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the TOS value to use in outgoing packets</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVxlan</doc>
            <type name="DeviceVxlan" c:type="NMDeviceVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ttl"
              c:identifier="nm_device_vxlan_get_ttl"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the time-to-live value to use in outgoing packets</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVxlan</doc>
            <type name="DeviceVxlan" c:type="NMDeviceVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="ageing" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The lifetime in seconds of FDB entries learnt by the kernel.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="carrier" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="dst-port" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The UDP destination port used to communicate with the remote VXLAN tunnel
endpoint.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="group" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The unicast destination IP address used in outgoing packets when the
destination link layer address is not known in the VXLAN device
forwarding database or the multicast IP address joined.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="hw-address" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="id" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The device's VXLAN ID.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="l2miss" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">Whether netlink LL ADDR miss notifications are generated.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="l3miss" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">Whether netlink IP ADDR miss notifications are generated.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="learning" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">Whether unknown source link layer addresses and IP addresses are entered
into the VXLAN device forwarding database.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="limit" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The maximum number of entries that can be added to the forwarding table.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="local" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The source IP address to use in outgoing packets.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="parent" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The devices's parent device.</doc>
        <type name="Device"/>
      </property>
      <property name="proxy" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">Whether ARP proxy is turned on.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="rsc" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">Whether route short circuit is turned on.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="src-port-max" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The maximum UDP source port used to communicate with the remote VXLAN
tunnel endpoint.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="src-port-min" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The minimum UDP source port used to communicate with the remote VXLAN
tunnel endpoint.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="tos" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The TOS value to use in outgoing packets.</doc>
        <type name="guint8" c:type="guint8"/>
      </property>
      <property name="ttl" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The time-to-live value to use in outgoing packets.</doc>
        <type name="guint8" c:type="guint8"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceVxlanClass"
            c:type="NMDeviceVxlanClass"
            glib:is-gtype-struct-for="DeviceVxlan">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="DeviceWifi"
           c:symbol-prefix="device_wifi"
           c:type="NMDeviceWifi"
           parent="Device"
           glib:type-name="NMDeviceWifi"
           glib:get-type="nm_device_wifi_get_type"
           glib:type-struct="DeviceWifiClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <virtual-method name="access_point_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
          <parameter name="ap" transfer-ownership="none">
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="access_point_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
          <parameter name="ap" transfer-ownership="none">
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_access_point_by_path"
              c:identifier="nm_device_wifi_get_access_point_by_path">
        <doc xml:space="preserve">Gets a #NMAccessPoint by path.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the access point or %NULL if none is found.</doc>
          <type name="AccessPoint" c:type="NMAccessPoint*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the object path of the access point</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_access_points"
              c:identifier="nm_device_wifi_get_access_points">
        <doc xml:space="preserve">Gets all the scanned access points of the #NMDeviceWifi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GPtrArray containing all the
scanned #NMAccessPoints.
The returned array is owned by the client and should not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="AccessPoint"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_active_access_point"
              c:identifier="nm_device_wifi_get_active_access_point">
        <doc xml:space="preserve">Gets the active #NMAccessPoint.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the access point or %NULL if none is active</doc>
          <type name="AccessPoint" c:type="NMAccessPoint*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bitrate" c:identifier="nm_device_wifi_get_bitrate">
        <doc xml:space="preserve">Gets the bit rate of the #NMDeviceWifi in kbit/s.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the bit rate (kbit/s)</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_capabilities"
              c:identifier="nm_device_wifi_get_capabilities">
        <doc xml:space="preserve">Gets the Wi-Fi capabilities of the #NMDeviceWifi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the capabilities</doc>
          <type name="DeviceWifiCapabilities"
                c:type="NMDeviceWifiCapabilities"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_wifi_get_hw_address">
        <doc xml:space="preserve">Gets the actual hardware (MAC) address of the #NMDeviceWifi</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the actual hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mode" c:identifier="nm_device_wifi_get_mode">
        <doc xml:space="preserve">Gets the #NMDeviceWifi mode.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the mode</doc>
          <type name="80211Mode" c:type="NM80211Mode"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_permanent_hw_address"
              c:identifier="nm_device_wifi_get_permanent_hw_address">
        <doc xml:space="preserve">Gets the permanent hardware (MAC) address of the #NMDeviceWifi</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the permanent hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="request_scan"
              c:identifier="nm_device_wifi_request_scan"
              throws="1">
        <doc xml:space="preserve">Request NM to scan for access points on @device. Note that the function
returns immediately after requesting the scan, and it may take some time
after that for the scan to complete.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error, in which case @error will be
set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_scan_async"
              c:identifier="nm_device_wifi_request_scan_async">
        <doc xml:space="preserve">Request NM to scan for access points on @device. Note that @callback will be
called immediately after requesting the scan, and it may take some time after
that for the scan to complete.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">callback to be called when the scan has been requested</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">caller-specific data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_scan_finish"
              c:identifier="nm_device_wifi_request_scan_finish"
              throws="1">
        <doc xml:space="preserve">Gets the result of a call to nm_device_wifi_request_scan_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error, in which case @error will be
set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the #GAsyncReadyCallback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_scan_options"
              c:identifier="nm_device_wifi_request_scan_options"
              version="1.2"
              throws="1">
        <doc xml:space="preserve">Request NM to scan for access points on @device. Note that the function
returns immediately after requesting the scan, and it may take some time
after that for the scan to complete.
This is the same as @nm_device_wifi_request_scan except it accepts @options
for the scanning. The argument is the dictionary passed to RequestScan()
D-Bus call. Valid otions inside the dictionary are:
'ssids' =&gt; array of SSIDs (saay)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error, in which case @error will be
set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve">dictionary with options for RequestScan(), or %NULL</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_scan_options_async"
              c:identifier="nm_device_wifi_request_scan_options_async"
              version="1.2">
        <doc xml:space="preserve">Request NM to scan for access points on @device. Note that @callback will be
called immediately after requesting the scan, and it may take some time after
that for the scan to complete.
This is the same as @nm_device_wifi_request_scan_async except it accepts @options
for the scanning. The argument is the dictionary passed to RequestScan()
D-Bus call. Valid otions inside the dictionary are:
'ssids' =&gt; array of SSIDs (saay)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve">dictionary with options for RequestScan(), or %NULL</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">callback to be called when the scan has been requested</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">caller-specific data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <property name="access-points" transfer-ownership="none">
        <doc xml:space="preserve">List of all Wi-Fi access points the device can see.

Element-type: NMAccessPoint</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="active-access-point" transfer-ownership="none">
        <doc xml:space="preserve">The active #NMAccessPoint of the device.</doc>
        <type name="AccessPoint"/>
      </property>
      <property name="bitrate" transfer-ownership="none">
        <doc xml:space="preserve">The bit rate of the device in kbit/s.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:space="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="mode" transfer-ownership="none">
        <doc xml:space="preserve">The mode of the device.</doc>
        <type name="80211Mode"/>
      </property>
      <property name="perm-hw-address" transfer-ownership="none">
        <doc xml:space="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="wireless-capabilities" transfer-ownership="none">
        <doc xml:space="preserve">The wireless capabilities of the device.</doc>
        <type name="DeviceWifiCapabilities"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
      <glib:signal name="access-point-added" when="first">
        <doc xml:space="preserve">Notifies that a #NMAccessPoint is added to the Wi-Fi device.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">the new access point</doc>
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="access-point-removed" when="first">
        <doc xml:space="preserve">Notifies that a #NMAccessPoint is removed from the Wi-Fi device.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">the removed access point</doc>
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <bitfield name="DeviceWifiCapabilities"
              glib:type-name="NMDeviceWifiCapabilities"
              glib:get-type="nm_device_wifi_capabilities_get_type"
              c:type="NMDeviceWifiCapabilities">
      <doc xml:space="preserve">802.11 specific device encryption and authentication capabilities.</doc>
      <member name="none"
              value="0"
              c:identifier="NM_WIFI_DEVICE_CAP_NONE"
              glib:nick="none">
        <doc xml:space="preserve">device has no encryption/authentication capabilities</doc>
      </member>
      <member name="cipher_wep40"
              value="1"
              c:identifier="NM_WIFI_DEVICE_CAP_CIPHER_WEP40"
              glib:nick="cipher-wep40">
        <doc xml:space="preserve">device supports 40/64-bit WEP encryption</doc>
      </member>
      <member name="cipher_wep104"
              value="2"
              c:identifier="NM_WIFI_DEVICE_CAP_CIPHER_WEP104"
              glib:nick="cipher-wep104">
        <doc xml:space="preserve">device supports 104/128-bit WEP encryption</doc>
      </member>
      <member name="cipher_tkip"
              value="4"
              c:identifier="NM_WIFI_DEVICE_CAP_CIPHER_TKIP"
              glib:nick="cipher-tkip">
        <doc xml:space="preserve">device supports TKIP encryption</doc>
      </member>
      <member name="cipher_ccmp"
              value="8"
              c:identifier="NM_WIFI_DEVICE_CAP_CIPHER_CCMP"
              glib:nick="cipher-ccmp">
        <doc xml:space="preserve">device supports AES/CCMP encryption</doc>
      </member>
      <member name="wpa"
              value="16"
              c:identifier="NM_WIFI_DEVICE_CAP_WPA"
              glib:nick="wpa">
        <doc xml:space="preserve">device supports WPA1 authentication</doc>
      </member>
      <member name="rsn"
              value="32"
              c:identifier="NM_WIFI_DEVICE_CAP_RSN"
              glib:nick="rsn">
        <doc xml:space="preserve">device supports WPA2/RSN authentication</doc>
      </member>
      <member name="ap"
              value="64"
              c:identifier="NM_WIFI_DEVICE_CAP_AP"
              glib:nick="ap">
        <doc xml:space="preserve">device supports Access Point mode</doc>
      </member>
      <member name="adhoc"
              value="128"
              c:identifier="NM_WIFI_DEVICE_CAP_ADHOC"
              glib:nick="adhoc">
        <doc xml:space="preserve">device supports Ad-Hoc mode</doc>
      </member>
      <member name="freq_valid"
              value="256"
              c:identifier="NM_WIFI_DEVICE_CAP_FREQ_VALID"
              glib:nick="freq-valid">
        <doc xml:space="preserve">device reports frequency capabilities</doc>
      </member>
      <member name="freq_2ghz"
              value="512"
              c:identifier="NM_WIFI_DEVICE_CAP_FREQ_2GHZ"
              glib:nick="freq-2ghz">
        <doc xml:space="preserve">device supports 2.4GHz frequencies</doc>
      </member>
      <member name="freq_5ghz"
              value="1024"
              c:identifier="NM_WIFI_DEVICE_CAP_FREQ_5GHZ"
              glib:nick="freq-5ghz">
        <doc xml:space="preserve">device supports 5GHz frequencies</doc>
      </member>
    </bitfield>
    <record name="DeviceWifiClass"
            c:type="NMDeviceWifiClass"
            glib:is-gtype-struct-for="DeviceWifi">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="access_point_added">
        <callback name="access_point_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="device" transfer-ownership="none">
              <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
            </parameter>
            <parameter name="ap" transfer-ownership="none">
              <type name="AccessPoint" c:type="NMAccessPoint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="access_point_removed">
        <callback name="access_point_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="device" transfer-ownership="none">
              <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
            </parameter>
            <parameter name="ap" transfer-ownership="none">
              <type name="AccessPoint" c:type="NMAccessPoint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="DeviceWimax"
           c:symbol-prefix="device_wimax"
           c:type="NMDeviceWimax"
           parent="Device"
           glib:type-name="NMDeviceWimax"
           glib:get-type="nm_device_wimax_get_type"
           glib:type-struct="DeviceWimaxClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <virtual-method name="nsp_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
          <parameter name="nsp" transfer-ownership="none">
            <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="nsp_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
          <parameter name="nsp" transfer-ownership="none">
            <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_active_nsp"
              c:identifier="nm_device_wimax_get_active_nsp"
              deprecated="1"
              deprecated-version="1.2">
        <doc xml:space="preserve">Gets the active #NMWimaxNsp.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the access point or %NULL if none is active</doc>
          <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
        </return-value>
        <parameters>
          <instance-parameter name="wimax" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bsid"
              c:identifier="nm_device_wimax_get_bsid"
              deprecated="1"
              deprecated-version="1.2">
        <doc xml:space="preserve">Gets the ID of the serving Base Station when the device is connected.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the ID of the serving Base Station, or %NULL</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_center_frequency"
              c:identifier="nm_device_wimax_get_center_frequency"
              deprecated="1"
              deprecated-version="1.2">
        <doc xml:space="preserve">Gets the center frequency (in KHz) of the radio channel the device is using
to communicate with the network when connected.  Has no meaning when the
device is not connected.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the center frequency in KHz, or 0</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_cinr"
              c:identifier="nm_device_wimax_get_cinr"
              deprecated="1"
              deprecated-version="1.2">
        <doc xml:space="preserve">Gets the CINR (Carrier to Interference + Noise Ratio) of the current radio
link in dB.  CINR is a more accurate measure of radio link quality.  Has no
meaning when the device is not connected.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the CINR in dB, or 0</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_wimax_get_hw_address"
              deprecated="1"
              deprecated-version="1.2">
        <doc xml:space="preserve">Gets the hardware (MAC) address of the #NMDeviceWimax</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hardware address. This is the internal string used by the
         device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="wimax" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_nsp_by_path"
              c:identifier="nm_device_wimax_get_nsp_by_path"
              deprecated="1"
              deprecated-version="1.2">
        <doc xml:space="preserve">Gets a #NMWimaxNsp by path.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the access point or %NULL if none is found.</doc>
          <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
        </return-value>
        <parameters>
          <instance-parameter name="wimax" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the object path of the NSP</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_nsps"
              c:identifier="nm_device_wimax_get_nsps"
              deprecated="1"
              deprecated-version="1.2">
        <doc xml:space="preserve">Gets all the scanned NSPs of the #NMDeviceWimax.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GPtrArray containing
         all the scanned #NMWimaxNsps.
The returned array is owned by the client and should not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="WimaxNsp"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="wimax" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_rssi"
              c:identifier="nm_device_wimax_get_rssi"
              deprecated="1"
              deprecated-version="1.2">
        <doc xml:space="preserve">Gets the RSSI of the current radio link in dBm.  This value indicates how
strong the raw received RF signal from the base station is, but does not
indicate the overall quality of the radio link.  Has no meaning when the
device is not connected.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the RSSI in dBm, or 0</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tx_power"
              c:identifier="nm_device_wimax_get_tx_power"
              deprecated="1"
              deprecated-version="1.2">
        <doc xml:space="preserve">Average power of the last burst transmitted by the device, in units of
0.5 dBm.  i.e. a TxPower of -11 represents an actual device TX power of
-5.5 dBm.  Has no meaning when the device is not connected.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the TX power in dBm, or 0</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="active-nsp"
                deprecated="1"
                deprecated-version="1.2"
                transfer-ownership="none">
        <doc xml:space="preserve">The active #NMWimaxNsp of the device.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <type name="WimaxNsp"/>
      </property>
      <property name="bsid"
                deprecated="1"
                deprecated-version="1.2"
                transfer-ownership="none">
        <doc xml:space="preserve">The ID of the serving base station as received from the network.  Has
no meaning when the device is not connected.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="center-frequency"
                deprecated="1"
                deprecated-version="1.2"
                transfer-ownership="none">
        <doc xml:space="preserve">The center frequency (in KHz) of the radio channel the device is using to
communicate with the network when connected.  Has no meaning when the
device is not connected.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="cinr"
                deprecated="1"
                deprecated-version="1.2"
                transfer-ownership="none">
        <doc xml:space="preserve">CINR (Carrier to Interference + Noise Ratio) of the current radio link
in dB.  CINR is a more accurate measure of radio link quality.  Has no
meaning when the device is not connected.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="hw-address"
                deprecated="1"
                deprecated-version="1.2"
                transfer-ownership="none">
        <doc xml:space="preserve">The hardware (MAC) address of the device.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="nsps" transfer-ownership="none">
        <doc xml:space="preserve">List of all WiMAX Network Service Providers the device can see.

Element-type: NMWimaxNsp</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="rssi"
                deprecated="1"
                deprecated-version="1.2"
                transfer-ownership="none">
        <doc xml:space="preserve">RSSI of the current radio link in dBm.  This value indicates how strong
the raw received RF signal from the base station is, but does not
indicate the overall quality of the radio link.  Has no meaning when the
device is not connected.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="tx-power"
                deprecated="1"
                deprecated-version="1.2"
                transfer-ownership="none">
        <doc xml:space="preserve">Average power of the last burst transmitted by the device, in units of
0.5 dBm.  i.e. a TxPower of -11 represents an actual device TX power of
-5.5 dBm.  Has no meaning when the device is not connected.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <type name="gint" c:type="gint"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
      <glib:signal name="nsp-added"
                   when="first"
                   deprecated="1"
                   deprecated-version="1.2">
        <doc xml:space="preserve">Notifies that a #NMWimaxNsp is added to the wimax device.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="nsp" transfer-ownership="none">
            <doc xml:space="preserve">the new NSP</doc>
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="nsp-removed"
                   when="first"
                   deprecated="1"
                   deprecated-version="1.2">
        <doc xml:space="preserve">Notifies that a #NMWimaxNsp is removed from the wimax device.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="nsp" transfer-ownership="none">
            <doc xml:space="preserve">the removed NSP</doc>
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="DeviceWimaxClass"
            c:type="NMDeviceWimaxClass"
            glib:is-gtype-struct-for="DeviceWimax">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="nsp_added">
        <callback name="nsp_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
            </parameter>
            <parameter name="nsp" transfer-ownership="none">
              <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="nsp_removed">
        <callback name="nsp_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
            </parameter>
            <parameter name="nsp" transfer-ownership="none">
              <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="DhcpConfig"
           c:symbol-prefix="dhcp_config"
           c:type="NMDhcpConfig"
           parent="Object"
           abstract="1"
           glib:type-name="NMDhcpConfig"
           glib:get-type="nm_dhcp_config_get_type"
           glib:type-struct="DhcpConfigClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <method name="get_family" c:identifier="nm_dhcp_config_get_family">
        <doc xml:space="preserve">Gets the IP address family of the configuration</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IP address family; either &lt;literal&gt;AF_INET&lt;/literal&gt; or
  &lt;literal&gt;AF_INET6&lt;/literal&gt;</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDhcpConfig</doc>
            <type name="DhcpConfig" c:type="NMDhcpConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_one_option"
              c:identifier="nm_dhcp_config_get_one_option">
        <doc xml:space="preserve">Gets one option by option name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the configuration option's value. This is the internal string used by the
configuration, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDhcpConfig</doc>
            <type name="DhcpConfig" c:type="NMDhcpConfig*"/>
          </instance-parameter>
          <parameter name="option" transfer-ownership="none">
            <doc xml:space="preserve">the option to retrieve</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_options" c:identifier="nm_dhcp_config_get_options">
        <doc xml:space="preserve">Gets all the options contained in the configuration.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GHashTable containing
strings for keys and values.  This is the internal copy used by the
configuration, and must not be modified.</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDhcpConfig</doc>
            <type name="DhcpConfig" c:type="NMDhcpConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="family" transfer-ownership="none">
        <doc xml:space="preserve">The IP address family of the configuration; either
&lt;literal&gt;AF_INET&lt;/literal&gt; or &lt;literal&gt;AF_INET6&lt;/literal&gt;.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="options" transfer-ownership="none">
        <doc xml:space="preserve">The #GHashTable containing options of the configuration.</doc>
        <type name="GLib.HashTable">
          <type name="utf8"/>
          <type name="utf8"/>
        </type>
      </property>
      <field name="parent">
        <type name="Object" c:type="NMObject"/>
      </field>
    </class>
    <record name="DhcpConfigClass"
            c:type="NMDhcpConfigClass"
            glib:is-gtype-struct-for="DhcpConfig">
      <field name="parent">
        <type name="ObjectClass" c:type="NMObjectClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="DnsEntry"
            c:type="NMDnsEntry"
            glib:type-name="NMDnsEntry"
            glib:get-type="nm_dns_entry_get_type"
            c:symbol-prefix="dns_entry">
      <method name="get_domains"
              c:identifier="nm_dns_entry_get_domains"
              version="1.6">
        <doc xml:space="preserve">Gets the list of DNS domains.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the list of DNS domains</doc>
          <array c:type="const char* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve">the #NMDnsEntry</doc>
            <type name="DnsEntry" c:type="NMDnsEntry*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_interface"
              c:identifier="nm_dns_entry_get_interface"
              version="1.6">
        <doc xml:space="preserve">Gets the interface on which name servers are contacted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the interface name</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve">the #NMDnsEntry</doc>
            <type name="DnsEntry" c:type="NMDnsEntry*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_nameservers"
              c:identifier="nm_dns_entry_get_nameservers"
              version="1.6">
        <doc xml:space="preserve">Gets the list of name servers for this entry.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the list of name servers</doc>
          <array c:type="const char* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve">the #NMDnsEntry</doc>
            <type name="DnsEntry" c:type="NMDnsEntry*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_priority"
              c:identifier="nm_dns_entry_get_priority"
              version="1.6">
        <doc xml:space="preserve">Gets the priority of the entry</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the priority of the entry</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve">the #NMDnsEntry</doc>
            <type name="DnsEntry" c:type="NMDnsEntry*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vpn" c:identifier="nm_dns_entry_get_vpn" version="1.6">
        <doc xml:space="preserve">Gets whether the entry refers to VPN name servers.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the entry refers to VPN name servers</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve">the #NMDnsEntry</doc>
            <type name="DnsEntry" c:type="NMDnsEntry*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="nm_dns_entry_unref" version="1.6">
        <doc xml:space="preserve">Decreases the reference count of the object.  If the reference count
reaches zero, the object will be destroyed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve">the #NMDnsEntry</doc>
            <type name="DnsEntry" c:type="NMDnsEntry*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="IPAddress"
            c:type="NMIPAddress"
            glib:type-name="NMIPAddress"
            glib:get-type="nm_ip_address_get_type"
            c:symbol-prefix="ip_address">
      <constructor name="new" c:identifier="nm_ip_address_new" throws="1">
        <doc xml:space="preserve">Creates a new #NMIPAddress object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #NMIPAddress object, or %NULL on error</doc>
          <type name="IPAddress" c:type="NMIPAddress*"/>
        </return-value>
        <parameters>
          <parameter name="family" transfer-ownership="none">
            <doc xml:space="preserve">the IP address family (&lt;literal&gt;AF_INET&lt;/literal&gt; or
  &lt;literal&gt;AF_INET6&lt;/literal&gt;)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">the IP address</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="prefix" transfer-ownership="none">
            <doc xml:space="preserve">the address prefix length</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_binary"
                   c:identifier="nm_ip_address_new_binary"
                   throws="1">
        <doc xml:space="preserve">Creates a new #NMIPAddress object. @addr must point to a buffer of the
correct size for @family.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #NMIPAddress object, or %NULL on error</doc>
          <type name="IPAddress" c:type="NMIPAddress*"/>
        </return-value>
        <parameters>
          <parameter name="family" transfer-ownership="none">
            <doc xml:space="preserve">the IP address family (&lt;literal&gt;AF_INET&lt;/literal&gt; or
  &lt;literal&gt;AF_INET6&lt;/literal&gt;)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="addr"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the IP address</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="prefix" transfer-ownership="none">
            <doc xml:space="preserve">the address prefix length</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="dup" c:identifier="nm_ip_address_dup">
        <doc xml:space="preserve">Creates a copy of @address</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a copy of @address</doc>
          <type name="IPAddress" c:type="NMIPAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPAddress</doc>
            <type name="IPAddress" c:type="NMIPAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="nm_ip_address_equal">
        <doc xml:space="preserve">Determines if two #NMIPAddress objects contain the same address and prefix
(attributes are not compared).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the objects contain the same values, %FALSE if they do not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPAddress</doc>
            <type name="IPAddress" c:type="NMIPAddress*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPAddress to compare @address to.</doc>
            <type name="IPAddress" c:type="NMIPAddress*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_address" c:identifier="nm_ip_address_get_address">
        <doc xml:space="preserve">Gets the IP address property of this address object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IP address</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPAddress</doc>
            <type name="IPAddress" c:type="NMIPAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_address_binary"
              c:identifier="nm_ip_address_get_address_binary"
              introspectable="0">
        <doc xml:space="preserve">Gets the IP address property of this address object.

@addr must point to a buffer that is the correct size for @address's family.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPAddress</doc>
            <type name="IPAddress" c:type="NMIPAddress*"/>
          </instance-parameter>
          <parameter name="addr"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a buffer in which to store the address in binary format.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute" c:identifier="nm_ip_address_get_attribute">
        <doc xml:space="preserve">Gets the value of the attribute with name @name on @address</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the attribute with name @name on
  @address, or %NULL if @address has no such attribute.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPAddress</doc>
            <type name="IPAddress" c:type="NMIPAddress*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of an address attribute</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_names"
              c:identifier="nm_ip_address_get_attribute_names">
        <doc xml:space="preserve">Gets an array of attribute names defined on @address.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a %NULL-terminated array of attribute names,</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPAddress</doc>
            <type name="IPAddress" c:type="NMIPAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_family" c:identifier="nm_ip_address_get_family">
        <doc xml:space="preserve">Gets the IP address family (eg, AF_INET) property of this address
object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IP address family</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPAddress</doc>
            <type name="IPAddress" c:type="NMIPAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_prefix" c:identifier="nm_ip_address_get_prefix">
        <doc xml:space="preserve">Gets the IP address prefix (ie "24" or "30" etc) property of this address
object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IP address prefix</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPAddress</doc>
            <type name="IPAddress" c:type="NMIPAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="nm_ip_address_ref">
        <doc xml:space="preserve">Increases the reference count of the object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPAddress</doc>
            <type name="IPAddress" c:type="NMIPAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_address" c:identifier="nm_ip_address_set_address">
        <doc xml:space="preserve">Sets the IP address property of this address object.

@addr must be a valid address of @address's family. If you aren't sure you
have a valid address, use nm_utils_ipaddr_valid() to check it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPAddress</doc>
            <type name="IPAddress" c:type="NMIPAddress*"/>
          </instance-parameter>
          <parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">the IP address, as a string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_address_binary"
              c:identifier="nm_ip_address_set_address_binary"
              introspectable="0">
        <doc xml:space="preserve">Sets the IP address property of this address object.

@addr must point to a buffer that is the correct size for @address's family.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPAddress</doc>
            <type name="IPAddress" c:type="NMIPAddress*"/>
          </instance-parameter>
          <parameter name="addr"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the address, in binary format</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute" c:identifier="nm_ip_address_set_attribute">
        <doc xml:space="preserve">Sets or clears the named attribute on @address to the given value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPAddress</doc>
            <type name="IPAddress" c:type="NMIPAddress*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of an address attribute</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the value</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_prefix" c:identifier="nm_ip_address_set_prefix">
        <doc xml:space="preserve">Sets the IP address prefix property of this address object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPAddress</doc>
            <type name="IPAddress" c:type="NMIPAddress*"/>
          </instance-parameter>
          <parameter name="prefix" transfer-ownership="none">
            <doc xml:space="preserve">the IP address prefix</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="nm_ip_address_unref">
        <doc xml:space="preserve">Decreases the reference count of the object.  If the reference count
reaches zero, the object will be destroyed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPAddress</doc>
            <type name="IPAddress" c:type="NMIPAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <class name="IPConfig"
           c:symbol-prefix="ip_config"
           c:type="NMIPConfig"
           parent="Object"
           abstract="1"
           glib:type-name="NMIPConfig"
           glib:get-type="nm_ip_config_get_type"
           glib:type-struct="IPConfigClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <method name="get_addresses" c:identifier="nm_ip_config_get_addresses">
        <doc xml:space="preserve">Gets the IP addresses (containing the address, prefix, and gateway).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GPtrArray
containing #NMIPAddress&lt;!-- --&gt;es.  This is the internal copy used by the
configuration and must not be modified. The library never modifies the
returned array and thus it is safe for callers to reference and keep using it.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="IPAddress"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMIPConfig</doc>
            <type name="IPConfig" c:type="NMIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_domains" c:identifier="nm_ip_config_get_domains">
        <doc xml:space="preserve">Gets the domain names.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the array of domains.
(This is never %NULL, though it may be 0-length).</doc>
          <array c:type="const char* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMIPConfig</doc>
            <type name="IPConfig" c:type="NMIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_family" c:identifier="nm_ip_config_get_family">
        <doc xml:space="preserve">Gets the IP address family</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IP address family; either &lt;literal&gt;AF_INET&lt;/literal&gt; or
&lt;literal&gt;AF_INET6&lt;/literal&gt;</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMIPConfig</doc>
            <type name="IPConfig" c:type="NMIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_gateway" c:identifier="nm_ip_config_get_gateway">
        <doc xml:space="preserve">Gets the IP gateway address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IP address of the gateway.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMIPConfig</doc>
            <type name="IPConfig" c:type="NMIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_nameservers"
              c:identifier="nm_ip_config_get_nameservers">
        <doc xml:space="preserve">Gets the domain name servers (DNS).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the array of nameserver IP addresses</doc>
          <array c:type="const char* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMIPConfig</doc>
            <type name="IPConfig" c:type="NMIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_routes" c:identifier="nm_ip_config_get_routes">
        <doc xml:space="preserve">Gets the routes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GPtrArray containing
#NMIPRoutes. This is the internal copy used by the configuration, and must
not be modified. The library never modifies the returned array and thus it is
safe for callers to reference and keep using it.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="IPRoute"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMIPConfig</doc>
            <type name="IPConfig" c:type="NMIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_searches" c:identifier="nm_ip_config_get_searches">
        <doc xml:space="preserve">Gets the DNS searches.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the array of DNS search strings.
(This is never %NULL, though it may be 0-length).</doc>
          <array c:type="const char* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMIPConfig</doc>
            <type name="IPConfig" c:type="NMIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_wins_servers"
              c:identifier="nm_ip_config_get_wins_servers">
        <doc xml:space="preserve">Gets the Windows Internet Name Service servers (WINS).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the arry of WINS server IP address strings.
(This is never %NULL, though it may be 0-length.)</doc>
          <array c:type="const char* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMIPConfig</doc>
            <type name="IPConfig" c:type="NMIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="addresses" transfer-ownership="none">
        <doc xml:space="preserve">A #GPtrArray containing the addresses (#NMIPAddress) of the configuration.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="domains" transfer-ownership="none">
        <doc xml:space="preserve">The array containing domain strings of the configuration.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="family" transfer-ownership="none">
        <doc xml:space="preserve">The IP address family of the configuration; either
&lt;literal&gt;AF_INET&lt;/literal&gt; or &lt;literal&gt;AF_INET6&lt;/literal&gt;.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="gateway" transfer-ownership="none">
        <doc xml:space="preserve">The IP gateway address of the configuration as string.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="nameservers" transfer-ownership="none">
        <doc xml:space="preserve">The array containing name server IP addresses of the configuration.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="routes" transfer-ownership="none">
        <doc xml:space="preserve">A #GPtrArray containing the routes (#NMIPRoute) of the configuration.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="searches" transfer-ownership="none">
        <doc xml:space="preserve">The array containing DNS search strings of the configuration.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="wins-servers" transfer-ownership="none">
        <doc xml:space="preserve">The array containing WINS server IP addresses of the configuration.
(This will always be empty for IPv6 configurations.)</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <field name="parent">
        <type name="Object" c:type="NMObject"/>
      </field>
    </class>
    <record name="IPConfigClass"
            c:type="NMIPConfigClass"
            glib:is-gtype-struct-for="IPConfig">
      <field name="parent">
        <type name="ObjectClass" c:type="NMObjectClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="IPRoute"
            c:type="NMIPRoute"
            glib:type-name="NMIPRoute"
            glib:get-type="nm_ip_route_get_type"
            c:symbol-prefix="ip_route">
      <constructor name="new" c:identifier="nm_ip_route_new" throws="1">
        <doc xml:space="preserve">Creates a new #NMIPRoute object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #NMIPRoute object, or %NULL on error</doc>
          <type name="IPRoute" c:type="NMIPRoute*"/>
        </return-value>
        <parameters>
          <parameter name="family" transfer-ownership="none">
            <doc xml:space="preserve">the IP address family (&lt;literal&gt;AF_INET&lt;/literal&gt; or
  &lt;literal&gt;AF_INET6&lt;/literal&gt;)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve">the IP address of the route's destination</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="prefix" transfer-ownership="none">
            <doc xml:space="preserve">the address prefix length</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="next_hop"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the IP address of the next hop (or %NULL)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="metric" transfer-ownership="none">
            <doc xml:space="preserve">the route metric (or -1 for "default")</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_binary"
                   c:identifier="nm_ip_route_new_binary"
                   throws="1">
        <doc xml:space="preserve">Creates a new #NMIPRoute object. @dest and @next_hop (if non-%NULL) must
point to buffers of the correct size for @family.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #NMIPRoute object, or %NULL on error</doc>
          <type name="IPRoute" c:type="NMIPRoute*"/>
        </return-value>
        <parameters>
          <parameter name="family" transfer-ownership="none">
            <doc xml:space="preserve">the IP address family (&lt;literal&gt;AF_INET&lt;/literal&gt; or
  &lt;literal&gt;AF_INET6&lt;/literal&gt;)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dest"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the IP address of the route's destination</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="prefix" transfer-ownership="none">
            <doc xml:space="preserve">the address prefix length</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="next_hop"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the IP address of the next hop (or %NULL)</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="metric" transfer-ownership="none">
            <doc xml:space="preserve">the route metric (or -1 for "default")</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="dup" c:identifier="nm_ip_route_dup">
        <doc xml:space="preserve">Creates a copy of @route</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a copy of @route</doc>
          <type name="IPRoute" c:type="NMIPRoute*"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPRoute</doc>
            <type name="IPRoute" c:type="NMIPRoute*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="nm_ip_route_equal">
        <doc xml:space="preserve">Determines if two #NMIPRoute objects contain the same destination, prefix,
next hop, and metric. (Attributes are not compared.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the objects contain the same values, %FALSE if they do not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPRoute</doc>
            <type name="IPRoute" c:type="NMIPRoute*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPRoute to compare @route to.</doc>
            <type name="IPRoute" c:type="NMIPRoute*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute" c:identifier="nm_ip_route_get_attribute">
        <doc xml:space="preserve">Gets the value of the attribute with name @name on @route</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the attribute with name @name on
  @route, or %NULL if @route has no such attribute.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPRoute</doc>
            <type name="IPRoute" c:type="NMIPRoute*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of an route attribute</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_names"
              c:identifier="nm_ip_route_get_attribute_names">
        <doc xml:space="preserve">Gets an array of attribute names defined on @route.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a %NULL-terminated array of attribute names</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPRoute</doc>
            <type name="IPRoute" c:type="NMIPRoute*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dest" c:identifier="nm_ip_route_get_dest">
        <doc xml:space="preserve">Gets the IP destination address property of this route object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IP address of the route's destination</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPRoute</doc>
            <type name="IPRoute" c:type="NMIPRoute*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dest_binary"
              c:identifier="nm_ip_route_get_dest_binary"
              introspectable="0">
        <doc xml:space="preserve">Gets the destination property of this route object.

@dest must point to a buffer that is the correct size for @route's family.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPRoute</doc>
            <type name="IPRoute" c:type="NMIPRoute*"/>
          </instance-parameter>
          <parameter name="dest"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a buffer in which to store the destination in binary format.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_family" c:identifier="nm_ip_route_get_family">
        <doc xml:space="preserve">Gets the IP address family (eg, AF_INET) property of this route
object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IP address family</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPRoute</doc>
            <type name="IPRoute" c:type="NMIPRoute*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_metric" c:identifier="nm_ip_route_get_metric">
        <doc xml:space="preserve">Gets the route metric property of this route object; lower values
indicate "better" or more preferred routes; -1 indicates "default"
(meaning NetworkManager will set it appropriately).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the route metric</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPRoute</doc>
            <type name="IPRoute" c:type="NMIPRoute*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_next_hop" c:identifier="nm_ip_route_get_next_hop">
        <doc xml:space="preserve">Gets the IP address of the next hop of this route; this will be %NULL if the
route has no next hop.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IP address of the next hop, or %NULL if this is a device route.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPRoute</doc>
            <type name="IPRoute" c:type="NMIPRoute*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_next_hop_binary"
              c:identifier="nm_ip_route_get_next_hop_binary"
              introspectable="0">
        <doc xml:space="preserve">Gets the next hop property of this route object.

@next_hop must point to a buffer that is the correct size for @route's family.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @route has a next hop, %FALSE if not (in which case
@next_hop will be zeroed out)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPRoute</doc>
            <type name="IPRoute" c:type="NMIPRoute*"/>
          </instance-parameter>
          <parameter name="next_hop"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a buffer in which to store the next hop in binary format.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_prefix" c:identifier="nm_ip_route_get_prefix">
        <doc xml:space="preserve">Gets the IP prefix (ie "24" or "30" etc) of this route.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IP prefix</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPRoute</doc>
            <type name="IPRoute" c:type="NMIPRoute*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="nm_ip_route_ref">
        <doc xml:space="preserve">Increases the reference count of the object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPRoute</doc>
            <type name="IPRoute" c:type="NMIPRoute*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_attribute" c:identifier="nm_ip_route_set_attribute">
        <doc xml:space="preserve">Sets the named attribute on @route to the given value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPRoute</doc>
            <type name="IPRoute" c:type="NMIPRoute*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of a route attribute</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the value</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_dest" c:identifier="nm_ip_route_set_dest">
        <doc xml:space="preserve">Sets the destination property of this route object.

@dest must be a valid address of @route's family. If you aren't sure you
have a valid address, use nm_utils_ipaddr_valid() to check it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPRoute</doc>
            <type name="IPRoute" c:type="NMIPRoute*"/>
          </instance-parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve">the route's destination, as a string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_dest_binary"
              c:identifier="nm_ip_route_set_dest_binary"
              introspectable="0">
        <doc xml:space="preserve">Sets the destination property of this route object.

@dest must point to a buffer that is the correct size for @route's family.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPRoute</doc>
            <type name="IPRoute" c:type="NMIPRoute*"/>
          </instance-parameter>
          <parameter name="dest"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the route's destination, in binary format</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_metric" c:identifier="nm_ip_route_set_metric">
        <doc xml:space="preserve">Sets the metric property of this route object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPRoute</doc>
            <type name="IPRoute" c:type="NMIPRoute*"/>
          </instance-parameter>
          <parameter name="metric" transfer-ownership="none">
            <doc xml:space="preserve">the route metric (or -1 for "default")</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_next_hop" c:identifier="nm_ip_route_set_next_hop">
        <doc xml:space="preserve">Sets the next-hop property of this route object.

@next_hop (if non-%NULL) must be a valid address of @route's family. If you
aren't sure you have a valid address, use nm_utils_ipaddr_valid() to check
it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPRoute</doc>
            <type name="IPRoute" c:type="NMIPRoute*"/>
          </instance-parameter>
          <parameter name="next_hop"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the route's next hop, as a string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_next_hop_binary"
              c:identifier="nm_ip_route_set_next_hop_binary"
              introspectable="0">
        <doc xml:space="preserve">Sets the destination property of this route object.

@next_hop (if non-%NULL) must point to a buffer that is the correct size for
@route's family.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPRoute</doc>
            <type name="IPRoute" c:type="NMIPRoute*"/>
          </instance-parameter>
          <parameter name="next_hop"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the route's next hop, in binary format</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_prefix" c:identifier="nm_ip_route_set_prefix">
        <doc xml:space="preserve">Sets the prefix property of this route object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPRoute</doc>
            <type name="IPRoute" c:type="NMIPRoute*"/>
          </instance-parameter>
          <parameter name="prefix" transfer-ownership="none">
            <doc xml:space="preserve">the route prefix</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="nm_ip_route_unref">
        <doc xml:space="preserve">Decreases the reference count of the object.  If the reference count
reaches zero, the object will be destroyed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIPRoute</doc>
            <type name="IPRoute" c:type="NMIPRoute*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="attribute_validate"
                c:identifier="nm_ip_route_attribute_validate"
                version="1.8"
                throws="1">
        <doc xml:space="preserve">Validates a route attribute, i.e. checks that the attribute is a known one
and the value is of the correct type and well-formed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the attribute is valid, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the attribute name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the attribute value</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="family" transfer-ownership="none">
            <doc xml:space="preserve">IP address family of the route</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="known"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">on return, whether the attribute name is a known one</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_variant_attribute_spec"
                c:identifier="nm_ip_route_get_variant_attribute_spec"
                version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the specifiers for route attributes</doc>
          <type name="VariantAttributeSpec"
                c:type="const NMVariantAttributeSpec* const*"/>
        </return-value>
      </function>
    </record>
    <enumeration name="IPTunnelMode"
                 version="1.2"
                 glib:type-name="NMIPTunnelMode"
                 glib:get-type="nm_ip_tunnel_mode_get_type"
                 c:type="NMIPTunnelMode">
      <doc xml:space="preserve">The tunneling mode.</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_IP_TUNNEL_MODE_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">Unknown/unset tunnel mode</doc>
      </member>
      <member name="ipip"
              value="1"
              c:identifier="NM_IP_TUNNEL_MODE_IPIP"
              glib:nick="ipip">
        <doc xml:space="preserve">IP in IP tunnel</doc>
      </member>
      <member name="gre"
              value="2"
              c:identifier="NM_IP_TUNNEL_MODE_GRE"
              glib:nick="gre">
        <doc xml:space="preserve">GRE tunnel</doc>
      </member>
      <member name="sit"
              value="3"
              c:identifier="NM_IP_TUNNEL_MODE_SIT"
              glib:nick="sit">
        <doc xml:space="preserve">SIT tunnel</doc>
      </member>
      <member name="isatap"
              value="4"
              c:identifier="NM_IP_TUNNEL_MODE_ISATAP"
              glib:nick="isatap">
        <doc xml:space="preserve">ISATAP tunnel</doc>
      </member>
      <member name="vti"
              value="5"
              c:identifier="NM_IP_TUNNEL_MODE_VTI"
              glib:nick="vti">
        <doc xml:space="preserve">VTI tunnel</doc>
      </member>
      <member name="ip6ip6"
              value="6"
              c:identifier="NM_IP_TUNNEL_MODE_IP6IP6"
              glib:nick="ip6ip6">
        <doc xml:space="preserve">IPv6 in IPv6 tunnel</doc>
      </member>
      <member name="ipip6"
              value="7"
              c:identifier="NM_IP_TUNNEL_MODE_IPIP6"
              glib:nick="ipip6">
        <doc xml:space="preserve">IPv4 in IPv6 tunnel</doc>
      </member>
      <member name="ip6gre"
              value="8"
              c:identifier="NM_IP_TUNNEL_MODE_IP6GRE"
              glib:nick="ip6gre">
        <doc xml:space="preserve">IPv6 GRE tunnel</doc>
      </member>
      <member name="vti6"
              value="9"
              c:identifier="NM_IP_TUNNEL_MODE_VTI6"
              glib:nick="vti6">
        <doc xml:space="preserve">IPv6 VTI tunnel</doc>
      </member>
    </enumeration>
    <constant name="IP_CONFIG_ADDRESSES"
              value="addresses"
              c:type="NM_IP_CONFIG_ADDRESSES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP_CONFIG_DOMAINS"
              value="domains"
              c:type="NM_IP_CONFIG_DOMAINS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP_CONFIG_FAMILY"
              value="family"
              c:type="NM_IP_CONFIG_FAMILY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP_CONFIG_GATEWAY"
              value="gateway"
              c:type="NM_IP_CONFIG_GATEWAY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP_CONFIG_NAMESERVERS"
              value="nameservers"
              c:type="NM_IP_CONFIG_NAMESERVERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP_CONFIG_ROUTES"
              value="routes"
              c:type="NM_IP_CONFIG_ROUTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP_CONFIG_SEARCHES"
              value="searches"
              c:type="NM_IP_CONFIG_SEARCHES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP_CONFIG_WINS_SERVERS"
              value="wins-servers"
              c:type="NM_IP_CONFIG_WINS_SERVERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP_ROUTE_ATTRIBUTE_CWND"
              value="cwnd"
              c:type="NM_IP_ROUTE_ATTRIBUTE_CWND">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP_ROUTE_ATTRIBUTE_FROM"
              value="from"
              c:type="NM_IP_ROUTE_ATTRIBUTE_FROM">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP_ROUTE_ATTRIBUTE_INITCWND"
              value="initcwnd"
              c:type="NM_IP_ROUTE_ATTRIBUTE_INITCWND">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP_ROUTE_ATTRIBUTE_INITRWND"
              value="initrwnd"
              c:type="NM_IP_ROUTE_ATTRIBUTE_INITRWND">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP_ROUTE_ATTRIBUTE_LOCK_CWND"
              value="lock-cwnd"
              c:type="NM_IP_ROUTE_ATTRIBUTE_LOCK_CWND">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP_ROUTE_ATTRIBUTE_LOCK_INITCWND"
              value="lock-initcwnd"
              c:type="NM_IP_ROUTE_ATTRIBUTE_LOCK_INITCWND">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP_ROUTE_ATTRIBUTE_LOCK_INITRWND"
              value="lock-initrwnd"
              c:type="NM_IP_ROUTE_ATTRIBUTE_LOCK_INITRWND">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP_ROUTE_ATTRIBUTE_LOCK_MTU"
              value="lock-mtu"
              c:type="NM_IP_ROUTE_ATTRIBUTE_LOCK_MTU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP_ROUTE_ATTRIBUTE_LOCK_WINDOW"
              value="lock-window"
              c:type="NM_IP_ROUTE_ATTRIBUTE_LOCK_WINDOW">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP_ROUTE_ATTRIBUTE_MTU"
              value="mtu"
              c:type="NM_IP_ROUTE_ATTRIBUTE_MTU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP_ROUTE_ATTRIBUTE_SRC"
              value="src"
              c:type="NM_IP_ROUTE_ATTRIBUTE_SRC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP_ROUTE_ATTRIBUTE_TOS"
              value="tos"
              c:type="NM_IP_ROUTE_ATTRIBUTE_TOS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP_ROUTE_ATTRIBUTE_WINDOW"
              value="window"
              c:type="NM_IP_ROUTE_ATTRIBUTE_WINDOW">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="LLDP_ATTR_CHASSIS_ID"
              value="chassis-id"
              c:type="NM_LLDP_ATTR_CHASSIS_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="LLDP_ATTR_CHASSIS_ID_TYPE"
              value="chassis-id-type"
              c:type="NM_LLDP_ATTR_CHASSIS_ID_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="LLDP_ATTR_DESTINATION"
              value="destination"
              c:type="NM_LLDP_ATTR_DESTINATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="LLDP_ATTR_IEEE_802_1_PPVID"
              value="ieee-802-1-ppvid"
              c:type="NM_LLDP_ATTR_IEEE_802_1_PPVID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="LLDP_ATTR_IEEE_802_1_PPVID_FLAGS"
              value="ieee-802-1-ppvid-flags"
              c:type="NM_LLDP_ATTR_IEEE_802_1_PPVID_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="LLDP_ATTR_IEEE_802_1_PVID"
              value="ieee-802-1-pvid"
              c:type="NM_LLDP_ATTR_IEEE_802_1_PVID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="LLDP_ATTR_IEEE_802_1_VID"
              value="ieee-802-1-vid"
              c:type="NM_LLDP_ATTR_IEEE_802_1_VID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="LLDP_ATTR_IEEE_802_1_VLAN_NAME"
              value="ieee-802-1-vlan-name"
              c:type="NM_LLDP_ATTR_IEEE_802_1_VLAN_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="LLDP_ATTR_PORT_DESCRIPTION"
              value="port-description"
              c:type="NM_LLDP_ATTR_PORT_DESCRIPTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="LLDP_ATTR_PORT_ID"
              value="port-id"
              c:type="NM_LLDP_ATTR_PORT_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="LLDP_ATTR_PORT_ID_TYPE"
              value="port-id-type"
              c:type="NM_LLDP_ATTR_PORT_ID_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="LLDP_ATTR_SYSTEM_CAPABILITIES"
              value="system-capabilities"
              c:type="NM_LLDP_ATTR_SYSTEM_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="LLDP_ATTR_SYSTEM_DESCRIPTION"
              value="system-description"
              c:type="NM_LLDP_ATTR_SYSTEM_DESCRIPTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="LLDP_ATTR_SYSTEM_NAME"
              value="system-name"
              c:type="NM_LLDP_ATTR_SYSTEM_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="LLDP_DEST_NEAREST_BRIDGE"
              value="nearest-bridge"
              c:type="NM_LLDP_DEST_NEAREST_BRIDGE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="LLDP_DEST_NEAREST_CUSTOMER_BRIDGE"
              value="nearest-customer-bridge"
              c:type="NM_LLDP_DEST_NEAREST_CUSTOMER_BRIDGE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="LLDP_DEST_NEAREST_NON_TPMR_BRIDGE"
              value="nearest-non-tpmr-bridge"
              c:type="NM_LLDP_DEST_NEAREST_NON_TPMR_BRIDGE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <record name="LldpNeighbor"
            c:type="NMLldpNeighbor"
            glib:type-name="NMLldpNeighbor"
            glib:get-type="nm_lldp_neighbor_get_type"
            c:symbol-prefix="lldp_neighbor">
      <constructor name="new"
                   c:identifier="nm_lldp_neighbor_new"
                   version="1.2">
        <doc xml:space="preserve">Creates a new #NMLldpNeighbor object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #NMLldpNeighbor object.</doc>
          <type name="LldpNeighbor" c:type="NMLldpNeighbor*"/>
        </return-value>
      </constructor>
      <method name="get_attr_names"
              c:identifier="nm_lldp_neighbor_get_attr_names"
              version="1.2">
        <doc xml:space="preserve">Gets an array of attribute names available for @neighbor.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a %NULL-terminated array of attribute names.</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="neighbor" transfer-ownership="none">
            <doc xml:space="preserve">the #NMLldpNeighbor</doc>
            <type name="LldpNeighbor" c:type="NMLldpNeighbor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_attr_string_value"
              c:identifier="nm_lldp_neighbor_get_attr_string_value"
              version="1.2">
        <doc xml:space="preserve">Gets the string value of attribute with name @name on @neighbor</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a string attribute with name @name was found, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="neighbor" transfer-ownership="none">
            <doc xml:space="preserve">the #NMLldpNeighbor</doc>
            <type name="LldpNeighbor" c:type="NMLldpNeighbor*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the attribute name</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="out_value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">on return, the attribute value</doc>
            <type name="utf8" c:type="const char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attr_type"
              c:identifier="nm_lldp_neighbor_get_attr_type"
              version="1.2">
        <doc xml:space="preserve">Get the type of an attribute.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GVariantType of the attribute with name @name</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="neighbor" transfer-ownership="none">
            <doc xml:space="preserve">the #NMLldpNeighbor</doc>
            <type name="LldpNeighbor" c:type="NMLldpNeighbor*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the attribute name</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attr_uint_value"
              c:identifier="nm_lldp_neighbor_get_attr_uint_value"
              version="1.2">
        <doc xml:space="preserve">Gets the uint value of attribute with name @name on @neighbor</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a uint attribute with name @name was found, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="neighbor" transfer-ownership="none">
            <doc xml:space="preserve">the #NMLldpNeighbor</doc>
            <type name="LldpNeighbor" c:type="NMLldpNeighbor*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the attribute name</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="out_value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">on return, the attribute value</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="nm_lldp_neighbor_ref" version="1.2">
        <doc xml:space="preserve">Increases the reference count of the object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="neighbor" transfer-ownership="none">
            <doc xml:space="preserve">the #NMLldpNeighbor</doc>
            <type name="LldpNeighbor" c:type="NMLldpNeighbor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="nm_lldp_neighbor_unref" version="1.2">
        <doc xml:space="preserve">Decreases the reference count of the object.  If the reference count
reaches zero, the object will be destroyed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="neighbor" transfer-ownership="none">
            <doc xml:space="preserve">the #NMLldpNeighbor</doc>
            <type name="LldpNeighbor" c:type="NMLldpNeighbor*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <constant name="MAJOR_VERSION" value="1" c:type="NM_MAJOR_VERSION">
      <doc xml:space="preserve">Evaluates to the major version number of NetworkManager which this source
is compiled against.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MICRO_VERSION" value="2" c:type="NM_MICRO_VERSION">
      <doc xml:space="preserve">Evaluates to the micro version number of NetworkManager which this source
compiled against.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MINOR_VERSION" value="8" c:type="NM_MINOR_VERSION">
      <doc xml:space="preserve">Evaluates to the minor version number of NetworkManager which this source
is compiled against.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="ManagerError"
                 glib:type-name="NMManagerError"
                 glib:get-type="nm_manager_error_get_type"
                 c:type="NMManagerError"
                 glib:error-domain="nm-manager-error-quark">
      <doc xml:space="preserve">Errors related to the main "network management" interface of NetworkManager.
These may be returned from #NMClient methods that invoke D-Bus operations on
the "org.freedesktop.NetworkManager" interface, and correspond to D-Bus
errors in that namespace.</doc>
      <member name="Failed"
              value="0"
              c:identifier="NM_MANAGER_ERROR_FAILED"
              glib:nick="Failed">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="PermissionDenied"
              value="1"
              c:identifier="NM_MANAGER_ERROR_PERMISSION_DENIED"
              glib:nick="PermissionDenied">
        <doc xml:space="preserve">Permission denied.</doc>
      </member>
      <member name="UnknownConnection"
              value="2"
              c:identifier="NM_MANAGER_ERROR_UNKNOWN_CONNECTION"
              glib:nick="UnknownConnection">
        <doc xml:space="preserve">The requested connection is not known.</doc>
      </member>
      <member name="UnknownDevice"
              value="3"
              c:identifier="NM_MANAGER_ERROR_UNKNOWN_DEVICE"
              glib:nick="UnknownDevice">
        <doc xml:space="preserve">The requested device is not known.</doc>
      </member>
      <member name="ConnectionNotAvailable"
              value="4"
              c:identifier="NM_MANAGER_ERROR_CONNECTION_NOT_AVAILABLE"
              glib:nick="ConnectionNotAvailable">
        <doc xml:space="preserve">The requested connection cannot be
  activated at this time.</doc>
      </member>
      <member name="ConnectionNotActive"
              value="5"
              c:identifier="NM_MANAGER_ERROR_CONNECTION_NOT_ACTIVE"
              glib:nick="ConnectionNotActive">
        <doc xml:space="preserve">The request could not be completed
  because a required connection is not active.</doc>
      </member>
      <member name="ConnectionAlreadyActive"
              value="6"
              c:identifier="NM_MANAGER_ERROR_CONNECTION_ALREADY_ACTIVE"
              glib:nick="ConnectionAlreadyActive">
        <doc xml:space="preserve">The connection to be activated was
  already active on another device.</doc>
      </member>
      <member name="DependencyFailed"
              value="7"
              c:identifier="NM_MANAGER_ERROR_DEPENDENCY_FAILED"
              glib:nick="DependencyFailed">
        <doc xml:space="preserve">An activation request failed due to a
  dependency being unavailable.</doc>
      </member>
      <member name="AlreadyAsleepOrAwake"
              value="8"
              c:identifier="NM_MANAGER_ERROR_ALREADY_ASLEEP_OR_AWAKE"
              glib:nick="AlreadyAsleepOrAwake">
        <doc xml:space="preserve">The manager is already in the requested
  sleep/wake state.</doc>
      </member>
      <member name="AlreadyEnabledOrDisabled"
              value="9"
              c:identifier="NM_MANAGER_ERROR_ALREADY_ENABLED_OR_DISABLED"
              glib:nick="AlreadyEnabledOrDisabled">
        <doc xml:space="preserve">The network is already
  enabled/disabled.</doc>
      </member>
      <member name="UnknownLogLevel"
              value="10"
              c:identifier="NM_MANAGER_ERROR_UNKNOWN_LOG_LEVEL"
              glib:nick="UnknownLogLevel">
        <doc xml:space="preserve">Unknown log level in SetLogging</doc>
      </member>
      <member name="UnknownLogDomain"
              value="11"
              c:identifier="NM_MANAGER_ERROR_UNKNOWN_LOG_DOMAIN"
              glib:nick="UnknownLogDomain">
        <doc xml:space="preserve">Unknown log domain in SetLogging</doc>
      </member>
      <member name="InvalidArguments"
              value="12"
              c:identifier="NM_MANAGER_ERROR_INVALID_ARGUMENTS"
              glib:nick="InvalidArguments">
        <doc xml:space="preserve">Invalid arguments for D-Bus request</doc>
      </member>
      <member name="MissingPlugin"
              value="13"
              c:identifier="NM_MANAGER_ERROR_MISSING_PLUGIN"
              glib:nick="MissingPlugin">
        <doc xml:space="preserve">A plug-in was needed to complete the
  activation but is not available.</doc>
      </member>
      <function name="quark" c:identifier="nm_manager_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <enumeration name="Metered"
                 version="1.2"
                 glib:type-name="NMMetered"
                 glib:get-type="nm_metered_get_type"
                 c:type="NMMetered">
      <member name="unknown"
              value="0"
              c:identifier="NM_METERED_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">The metered status is unknown</doc>
      </member>
      <member name="yes"
              value="1"
              c:identifier="NM_METERED_YES"
              glib:nick="yes">
        <doc xml:space="preserve">Metered, the value was statically set</doc>
      </member>
      <member name="no" value="2" c:identifier="NM_METERED_NO" glib:nick="no">
        <doc xml:space="preserve">Not metered, the value was statically set</doc>
      </member>
      <member name="guess_yes"
              value="3"
              c:identifier="NM_METERED_GUESS_YES"
              glib:nick="guess-yes">
        <doc xml:space="preserve">Metered, the value was guessed</doc>
      </member>
      <member name="guess_no"
              value="4"
              c:identifier="NM_METERED_GUESS_NO"
              glib:nick="guess-no">
        <doc xml:space="preserve">Not metered, the value was guessed</doc>
      </member>
    </enumeration>
    <constant name="OBJECT_DBUS_CONNECTION"
              value="dbus-connection"
              c:type="NM_OBJECT_DBUS_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="OBJECT_DBUS_OBJECT"
              value="dbus-object"
              c:type="NM_OBJECT_DBUS_OBJECT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="OBJECT_DBUS_OBJECT_MANAGER"
              value="dbus-object-manager"
              c:type="NM_OBJECT_DBUS_OBJECT_MANAGER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="OBJECT_PATH" value="path" c:type="NM_OBJECT_PATH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Object"
           c:symbol-prefix="object"
           c:type="NMObject"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="NMObject"
           glib:get-type="nm_object_get_type"
           glib:type-struct="ObjectClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <virtual-method name="init_dbus">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="NMObject*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="object_creation_failed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="master_object" transfer-ownership="none">
            <type name="Object" c:type="NMObject*"/>
          </instance-parameter>
          <parameter name="failed_path" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_path" c:identifier="nm_object_get_path">
        <doc xml:space="preserve">Gets the DBus path of the #NMObject.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the object's path. This is the internal string used by the
object, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #NMObject</doc>
            <type name="Object" c:type="NMObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="dbus-connection"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:space="preserve">The #GDBusConnection of the object.</doc>
        <type name="Gio.DBusConnection"/>
      </property>
      <property name="dbus-object"
                introspectable="0"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #GDBusObject of the object.</doc>
        <type name="Gio.DBusObject"/>
      </property>
      <property name="dbus-object-manager"
                introspectable="0"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #GDBusObjectManager of the object.</doc>
        <type name="Gio.DBusObjectManager"/>
      </property>
      <property name="path" introspectable="0" transfer-ownership="none">
        <doc xml:space="preserve">The D-Bus object path.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="ObjectClass"
            c:type="NMObjectClass"
            glib:is-gtype-struct-for="Object">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="init_dbus">
        <callback name="init_dbus">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="NMObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="object_creation_failed">
        <callback name="object_creation_failed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="master_object" transfer-ownership="none">
              <type name="Object" c:type="NMObject*"/>
            </parameter>
            <parameter name="failed_path" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <constant name="REMOTE_CONNECTION_DBUS_CONNECTION"
              value="dbus-connection"
              c:type="NM_REMOTE_CONNECTION_DBUS_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="REMOTE_CONNECTION_PATH"
              value="path"
              c:type="NM_REMOTE_CONNECTION_PATH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="REMOTE_CONNECTION_UNSAVED"
              value="unsaved"
              c:type="NM_REMOTE_CONNECTION_UNSAVED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="REMOTE_CONNECTION_VISIBLE"
              value="visible"
              c:type="NM_REMOTE_CONNECTION_VISIBLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="RemoteConnection"
           c:symbol-prefix="remote_connection"
           c:type="NMRemoteConnection"
           parent="Object"
           glib:type-name="NMRemoteConnection"
           glib:get-type="nm_remote_connection_get_type"
           glib:type-struct="RemoteConnectionClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <implements name="Connection"/>
      <method name="commit_changes"
              c:identifier="nm_remote_connection_commit_changes"
              throws="1">
        <doc xml:space="preserve">Send any local changes to the settings and properties of @connection to
NetworkManager. If @save_to_disk is %TRUE, the updated connection will be saved to
disk; if %FALSE, then only the in-memory representation will be changed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error, in which case @error will be set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMRemoteConnection</doc>
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
          <parameter name="save_to_disk" transfer-ownership="none">
            <doc xml:space="preserve">whether to persist the changes to disk</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="commit_changes_async"
              c:identifier="nm_remote_connection_commit_changes_async">
        <doc xml:space="preserve">Asynchronously sends any local changes to the settings and properties of
@connection to NetworkManager. If @save is %TRUE, the updated connection will
be saved to disk; if %FALSE, then only the in-memory representation will be
changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMRemoteConnection</doc>
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
          <parameter name="save_to_disk" transfer-ownership="none">
            <doc xml:space="preserve">whether to save the changes to persistent storage</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">callback to be called when the commit operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">caller-specific data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="commit_changes_finish"
              c:identifier="nm_remote_connection_commit_changes_finish"
              throws="1">
        <doc xml:space="preserve">Gets the result of a call to nm_remote_connection_commit_changes_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error, in which case @error will be set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMRemoteConnection</doc>
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the #GAsyncReadyCallback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete"
              c:identifier="nm_remote_connection_delete"
              throws="1">
        <doc xml:space="preserve">Deletes the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error, in which case @error will be set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMRemoteConnection</doc>
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete_async"
              c:identifier="nm_remote_connection_delete_async">
        <doc xml:space="preserve">Asynchronously deletes the connection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMRemoteConnection</doc>
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">callback to be called when the delete operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">caller-specific data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete_finish"
              c:identifier="nm_remote_connection_delete_finish"
              throws="1">
        <doc xml:space="preserve">Gets the result of a call to nm_remote_connection_delete_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error, in which case @error will be set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMRemoteConnection</doc>
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the #GAsyncReadyCallback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_secrets"
              c:identifier="nm_remote_connection_get_secrets"
              throws="1">
        <doc xml:space="preserve">Request the connection's secrets. Note that this is a blocking D-Bus call,
not a simple property accessor.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GVariant of type %NM_VARIANT_TYPE_CONNECTION containing
@connection's secrets, or %NULL on error.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMRemoteConnection</doc>
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
          <parameter name="setting_name" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting object name to get secrets for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_secrets_async"
              c:identifier="nm_remote_connection_get_secrets_async">
        <doc xml:space="preserve">Asynchronously requests the connection's secrets.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMRemoteConnection</doc>
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
          <parameter name="setting_name" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting object name to get secrets for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">callback to be called when the secret request completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">caller-specific data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_secrets_finish"
              c:identifier="nm_remote_connection_get_secrets_finish"
              throws="1">
        <doc xml:space="preserve">Gets the result of a call to nm_remote_connection_get_secrets_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GVariant of type %NM_VARIANT_TYPE_CONNECTION
  containing @connection's secrets, or %NULL on error.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMRemoteConnection</doc>
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the #GAsyncReadyCallback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_unsaved"
              c:identifier="nm_remote_connection_get_unsaved">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the remote connection contains changes that have not
been saved to disk, %FALSE if the connection is the same as its on-disk
representation.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMRemoteConnection</doc>
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_visible"
              c:identifier="nm_remote_connection_get_visible">
        <doc xml:space="preserve">Checks if the connection is visible to the current user.  If the
connection is not visible then it is essentially useless; it will
not contain any settings, and operations such as
nm_remote_connection_save() and nm_remote_connection_delete() will
always fail. (#NMRemoteSettings will not normally return
non-visible connections to callers, but it is possible for a
connection's visibility to change after you already have a
reference to it.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the remote connection is visible to the current
user, %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMRemoteConnection</doc>
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="save" c:identifier="nm_remote_connection_save" throws="1">
        <doc xml:space="preserve">Saves the connection to disk if the connection has changes that have not yet
been written to disk, or if the connection has never been saved.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error, in which case @error will be set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMRemoteConnection</doc>
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="save_async" c:identifier="nm_remote_connection_save_async">
        <doc xml:space="preserve">Saves the connection to disk if the connection has changes that have not yet
been written to disk, or if the connection has never been saved.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMRemoteConnection</doc>
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">callback to be called when the save operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">caller-specific data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="save_finish"
              c:identifier="nm_remote_connection_save_finish"
              throws="1">
        <doc xml:space="preserve">Gets the result of a call to nm_remote_connection_save_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error, in which case @error will be set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMRemoteConnection</doc>
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the #GAsyncReadyCallback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="unsaved" transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the remote connection contains changes that have not been saved
to disk, %FALSE if the connection is the same as its on-disk representation.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="visible" transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the remote connection is visible to the current user, %FALSE if
not.  If the connection is not visible then it is essentially useless; it
will not contain any settings, and operations such as
nm_remote_connection_save() and nm_remote_connection_delete() will always
fail. (#NMRemoteSettings will not normally return non-visible connections
to callers, but it is possible for a connection's visibility to change
after you already have a reference to it.)</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="Object" c:type="NMObject"/>
      </field>
    </class>
    <record name="RemoteConnectionClass"
            c:type="NMRemoteConnectionClass"
            glib:is-gtype-struct-for="RemoteConnection">
      <field name="parent_class">
        <type name="ObjectClass" c:type="NMObjectClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="RollbackResult" version="1.4" c:type="NMRollbackResult">
      <doc xml:space="preserve">The result of a checkpoint Rollback() operation for a specific device.</doc>
      <member name="ok" value="0" c:identifier="NM_ROLLBACK_RESULT_OK">
        <doc xml:space="preserve">the rollback succeeded.</doc>
      </member>
      <member name="err_no_device"
              value="1"
              c:identifier="NM_ROLLBACK_RESULT_ERR_NO_DEVICE">
        <doc xml:space="preserve">the device no longer exists.</doc>
      </member>
      <member name="err_device_unmanaged"
              value="2"
              c:identifier="NM_ROLLBACK_RESULT_ERR_DEVICE_UNMANAGED">
        <doc xml:space="preserve">the device is now unmanaged.</doc>
      </member>
      <member name="err_failed"
              value="3"
              c:identifier="NM_ROLLBACK_RESULT_ERR_FAILED">
        <doc xml:space="preserve">other errors during rollback.</doc>
      </member>
    </enumeration>
    <constant name="SECRET_AGENT_OLD_AUTO_REGISTER"
              value="auto-register"
              c:type="NM_SECRET_AGENT_OLD_AUTO_REGISTER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SECRET_AGENT_OLD_CAPABILITIES"
              value="capabilities"
              c:type="NM_SECRET_AGENT_OLD_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SECRET_AGENT_OLD_IDENTIFIER"
              value="identifier"
              c:type="NM_SECRET_AGENT_OLD_IDENTIFIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SECRET_AGENT_OLD_REGISTERED"
              value="registered"
              c:type="NM_SECRET_AGENT_OLD_REGISTERED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_ALTSUBJECT_MATCHES"
              value="altsubject-matches"
              c:type="NM_SETTING_802_1X_ALTSUBJECT_MATCHES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_ANONYMOUS_IDENTITY"
              value="anonymous-identity"
              c:type="NM_SETTING_802_1X_ANONYMOUS_IDENTITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_AUTH_TIMEOUT"
              value="auth-timeout"
              c:type="NM_SETTING_802_1X_AUTH_TIMEOUT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_CA_CERT"
              value="ca-cert"
              c:type="NM_SETTING_802_1X_CA_CERT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_CA_CERT_PASSWORD"
              value="ca-cert-password"
              c:type="NM_SETTING_802_1X_CA_CERT_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_CA_CERT_PASSWORD_FLAGS"
              value="ca-cert-password-flags"
              c:type="NM_SETTING_802_1X_CA_CERT_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_CA_PATH"
              value="ca-path"
              c:type="NM_SETTING_802_1X_CA_PATH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_CERT_SCHEME_PREFIX_PATH"
              value="file://"
              c:type="NM_SETTING_802_1X_CERT_SCHEME_PREFIX_PATH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_CERT_SCHEME_PREFIX_PKCS11"
              value="pkcs11:"
              c:type="NM_SETTING_802_1X_CERT_SCHEME_PREFIX_PKCS11">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_CLIENT_CERT"
              value="client-cert"
              c:type="NM_SETTING_802_1X_CLIENT_CERT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_CLIENT_CERT_PASSWORD"
              value="client-cert-password"
              c:type="NM_SETTING_802_1X_CLIENT_CERT_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_CLIENT_CERT_PASSWORD_FLAGS"
              value="client-cert-password-flags"
              c:type="NM_SETTING_802_1X_CLIENT_CERT_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_DOMAIN_SUFFIX_MATCH"
              value="domain-suffix-match"
              c:type="NM_SETTING_802_1X_DOMAIN_SUFFIX_MATCH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_EAP"
              value="eap"
              c:type="NM_SETTING_802_1X_EAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_IDENTITY"
              value="identity"
              c:type="NM_SETTING_802_1X_IDENTITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PAC_FILE"
              value="pac-file"
              c:type="NM_SETTING_802_1X_PAC_FILE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PASSWORD"
              value="password"
              c:type="NM_SETTING_802_1X_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PASSWORD_FLAGS"
              value="password-flags"
              c:type="NM_SETTING_802_1X_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PASSWORD_RAW"
              value="password-raw"
              c:type="NM_SETTING_802_1X_PASSWORD_RAW">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PASSWORD_RAW_FLAGS"
              value="password-raw-flags"
              c:type="NM_SETTING_802_1X_PASSWORD_RAW_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE1_AUTH_FLAGS"
              value="phase1-auth-flags"
              c:type="NM_SETTING_802_1X_PHASE1_AUTH_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE1_FAST_PROVISIONING"
              value="phase1-fast-provisioning"
              c:type="NM_SETTING_802_1X_PHASE1_FAST_PROVISIONING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE1_PEAPLABEL"
              value="phase1-peaplabel"
              c:type="NM_SETTING_802_1X_PHASE1_PEAPLABEL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE1_PEAPVER"
              value="phase1-peapver"
              c:type="NM_SETTING_802_1X_PHASE1_PEAPVER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_ALTSUBJECT_MATCHES"
              value="phase2-altsubject-matches"
              c:type="NM_SETTING_802_1X_PHASE2_ALTSUBJECT_MATCHES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_AUTH"
              value="phase2-auth"
              c:type="NM_SETTING_802_1X_PHASE2_AUTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_AUTHEAP"
              value="phase2-autheap"
              c:type="NM_SETTING_802_1X_PHASE2_AUTHEAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_CA_CERT"
              value="phase2-ca-cert"
              c:type="NM_SETTING_802_1X_PHASE2_CA_CERT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_CA_CERT_PASSWORD"
              value="phase2-ca-cert-password"
              c:type="NM_SETTING_802_1X_PHASE2_CA_CERT_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_CA_CERT_PASSWORD_FLAGS"
              value="phase2-ca-cert-password-flags"
              c:type="NM_SETTING_802_1X_PHASE2_CA_CERT_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_CA_PATH"
              value="phase2-ca-path"
              c:type="NM_SETTING_802_1X_PHASE2_CA_PATH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_CLIENT_CERT"
              value="phase2-client-cert"
              c:type="NM_SETTING_802_1X_PHASE2_CLIENT_CERT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_CLIENT_CERT_PASSWORD"
              value="phase2-client-cert-password"
              c:type="NM_SETTING_802_1X_PHASE2_CLIENT_CERT_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_CLIENT_CERT_PASSWORD_FLAGS"
              value="phase2-client-cert-password-flags"
              c:type="NM_SETTING_802_1X_PHASE2_CLIENT_CERT_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_DOMAIN_SUFFIX_MATCH"
              value="phase2-domain-suffix-match"
              c:type="NM_SETTING_802_1X_PHASE2_DOMAIN_SUFFIX_MATCH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_PRIVATE_KEY"
              value="phase2-private-key"
              c:type="NM_SETTING_802_1X_PHASE2_PRIVATE_KEY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD"
              value="phase2-private-key-password"
              c:type="NM_SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD_FLAGS"
              value="phase2-private-key-password-flags"
              c:type="NM_SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_SUBJECT_MATCH"
              value="phase2-subject-match"
              c:type="NM_SETTING_802_1X_PHASE2_SUBJECT_MATCH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PIN"
              value="pin"
              c:type="NM_SETTING_802_1X_PIN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PIN_FLAGS"
              value="pin-flags"
              c:type="NM_SETTING_802_1X_PIN_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PRIVATE_KEY"
              value="private-key"
              c:type="NM_SETTING_802_1X_PRIVATE_KEY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PRIVATE_KEY_PASSWORD"
              value="private-key-password"
              c:type="NM_SETTING_802_1X_PRIVATE_KEY_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PRIVATE_KEY_PASSWORD_FLAGS"
              value="private-key-password-flags"
              c:type="NM_SETTING_802_1X_PRIVATE_KEY_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_SETTING_NAME"
              value="802-1x"
              c:type="NM_SETTING_802_1X_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_SUBJECT_MATCH"
              value="subject-match"
              c:type="NM_SETTING_802_1X_SUBJECT_MATCH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_SYSTEM_CA_CERTS"
              value="system-ca-certs"
              c:type="NM_SETTING_802_1X_SYSTEM_CA_CERTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_ENCAPSULATION"
              value="encapsulation"
              c:type="NM_SETTING_ADSL_ENCAPSULATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_ENCAPSULATION_LLC"
              value="llc"
              c:type="NM_SETTING_ADSL_ENCAPSULATION_LLC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_ENCAPSULATION_VCMUX"
              value="vcmux"
              c:type="NM_SETTING_ADSL_ENCAPSULATION_VCMUX">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_PASSWORD"
              value="password"
              c:type="NM_SETTING_ADSL_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_PASSWORD_FLAGS"
              value="password-flags"
              c:type="NM_SETTING_ADSL_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_PROTOCOL"
              value="protocol"
              c:type="NM_SETTING_ADSL_PROTOCOL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_PROTOCOL_IPOATM"
              value="ipoatm"
              c:type="NM_SETTING_ADSL_PROTOCOL_IPOATM">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_PROTOCOL_PPPOA"
              value="pppoa"
              c:type="NM_SETTING_ADSL_PROTOCOL_PPPOA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_PROTOCOL_PPPOE"
              value="pppoe"
              c:type="NM_SETTING_ADSL_PROTOCOL_PPPOE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_SETTING_NAME"
              value="adsl"
              c:type="NM_SETTING_ADSL_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_USERNAME"
              value="username"
              c:type="NM_SETTING_ADSL_USERNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_VCI" value="vci" c:type="NM_SETTING_ADSL_VCI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_VPI" value="vpi" c:type="NM_SETTING_ADSL_VPI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BLUETOOTH_BDADDR"
              value="bdaddr"
              c:type="NM_SETTING_BLUETOOTH_BDADDR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BLUETOOTH_SETTING_NAME"
              value="bluetooth"
              c:type="NM_SETTING_BLUETOOTH_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BLUETOOTH_TYPE"
              value="type"
              c:type="NM_SETTING_BLUETOOTH_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BLUETOOTH_TYPE_DUN"
              value="dun"
              c:type="NM_SETTING_BLUETOOTH_TYPE_DUN">
      <doc xml:space="preserve">Connection type describing a connection to devices that support the Bluetooth
DUN profile.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BLUETOOTH_TYPE_PANU"
              value="panu"
              c:type="NM_SETTING_BLUETOOTH_TYPE_PANU">
      <doc xml:space="preserve">Connection type describing a connection to devices that support the Bluetooth
NAP (Network Access Point) protocol, which accepts connections via PANU.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTIONS"
              value="options"
              c:type="NM_SETTING_BOND_OPTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_ACTIVE_SLAVE"
              value="active_slave"
              c:type="NM_SETTING_BOND_OPTION_ACTIVE_SLAVE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_AD_ACTOR_SYSTEM"
              value="ad_actor_system"
              c:type="NM_SETTING_BOND_OPTION_AD_ACTOR_SYSTEM">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_AD_ACTOR_SYS_PRIO"
              value="ad_actor_sys_prio"
              c:type="NM_SETTING_BOND_OPTION_AD_ACTOR_SYS_PRIO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_AD_SELECT"
              value="ad_select"
              c:type="NM_SETTING_BOND_OPTION_AD_SELECT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_AD_USER_PORT_KEY"
              value="ad_user_port_key"
              c:type="NM_SETTING_BOND_OPTION_AD_USER_PORT_KEY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_ALL_SLAVES_ACTIVE"
              value="all_slaves_active"
              c:type="NM_SETTING_BOND_OPTION_ALL_SLAVES_ACTIVE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_ARP_ALL_TARGETS"
              value="arp_all_targets"
              c:type="NM_SETTING_BOND_OPTION_ARP_ALL_TARGETS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_ARP_INTERVAL"
              value="arp_interval"
              c:type="NM_SETTING_BOND_OPTION_ARP_INTERVAL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_ARP_IP_TARGET"
              value="arp_ip_target"
              c:type="NM_SETTING_BOND_OPTION_ARP_IP_TARGET">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_ARP_VALIDATE"
              value="arp_validate"
              c:type="NM_SETTING_BOND_OPTION_ARP_VALIDATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_DOWNDELAY"
              value="downdelay"
              c:type="NM_SETTING_BOND_OPTION_DOWNDELAY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_FAIL_OVER_MAC"
              value="fail_over_mac"
              c:type="NM_SETTING_BOND_OPTION_FAIL_OVER_MAC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_LACP_RATE"
              value="lacp_rate"
              c:type="NM_SETTING_BOND_OPTION_LACP_RATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_LP_INTERVAL"
              value="lp_interval"
              c:type="NM_SETTING_BOND_OPTION_LP_INTERVAL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_MIIMON"
              value="miimon"
              c:type="NM_SETTING_BOND_OPTION_MIIMON">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_MIN_LINKS"
              value="min_links"
              c:type="NM_SETTING_BOND_OPTION_MIN_LINKS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_MODE"
              value="mode"
              c:type="NM_SETTING_BOND_OPTION_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_NUM_GRAT_ARP"
              value="num_grat_arp"
              c:type="NM_SETTING_BOND_OPTION_NUM_GRAT_ARP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_NUM_UNSOL_NA"
              value="num_unsol_na"
              c:type="NM_SETTING_BOND_OPTION_NUM_UNSOL_NA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_PACKETS_PER_SLAVE"
              value="packets_per_slave"
              c:type="NM_SETTING_BOND_OPTION_PACKETS_PER_SLAVE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_PRIMARY"
              value="primary"
              c:type="NM_SETTING_BOND_OPTION_PRIMARY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_PRIMARY_RESELECT"
              value="primary_reselect"
              c:type="NM_SETTING_BOND_OPTION_PRIMARY_RESELECT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_RESEND_IGMP"
              value="resend_igmp"
              c:type="NM_SETTING_BOND_OPTION_RESEND_IGMP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_TLB_DYNAMIC_LB"
              value="tlb_dynamic_lb"
              c:type="NM_SETTING_BOND_OPTION_TLB_DYNAMIC_LB">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_UPDELAY"
              value="updelay"
              c:type="NM_SETTING_BOND_OPTION_UPDELAY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_USE_CARRIER"
              value="use_carrier"
              c:type="NM_SETTING_BOND_OPTION_USE_CARRIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_XMIT_HASH_POLICY"
              value="xmit_hash_policy"
              c:type="NM_SETTING_BOND_OPTION_XMIT_HASH_POLICY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_SETTING_NAME"
              value="bond"
              c:type="NM_SETTING_BOND_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_AGEING_TIME"
              value="ageing-time"
              c:type="NM_SETTING_BRIDGE_AGEING_TIME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_FORWARD_DELAY"
              value="forward-delay"
              c:type="NM_SETTING_BRIDGE_FORWARD_DELAY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_HELLO_TIME"
              value="hello-time"
              c:type="NM_SETTING_BRIDGE_HELLO_TIME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_MAC_ADDRESS"
              value="mac-address"
              c:type="NM_SETTING_BRIDGE_MAC_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_MAX_AGE"
              value="max-age"
              c:type="NM_SETTING_BRIDGE_MAX_AGE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_MULTICAST_SNOOPING"
              value="multicast-snooping"
              c:type="NM_SETTING_BRIDGE_MULTICAST_SNOOPING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_PORT_HAIRPIN_MODE"
              value="hairpin-mode"
              c:type="NM_SETTING_BRIDGE_PORT_HAIRPIN_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_PORT_PATH_COST"
              value="path-cost"
              c:type="NM_SETTING_BRIDGE_PORT_PATH_COST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_PORT_PRIORITY"
              value="priority"
              c:type="NM_SETTING_BRIDGE_PORT_PRIORITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_PORT_SETTING_NAME"
              value="bridge-port"
              c:type="NM_SETTING_BRIDGE_PORT_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_PRIORITY"
              value="priority"
              c:type="NM_SETTING_BRIDGE_PRIORITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_SETTING_NAME"
              value="bridge"
              c:type="NM_SETTING_BRIDGE_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_STP"
              value="stp"
              c:type="NM_SETTING_BRIDGE_STP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CDMA_MTU" value="mtu" c:type="NM_SETTING_CDMA_MTU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CDMA_NUMBER"
              value="number"
              c:type="NM_SETTING_CDMA_NUMBER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CDMA_PASSWORD"
              value="password"
              c:type="NM_SETTING_CDMA_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CDMA_PASSWORD_FLAGS"
              value="password-flags"
              c:type="NM_SETTING_CDMA_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CDMA_SETTING_NAME"
              value="cdma"
              c:type="NM_SETTING_CDMA_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CDMA_USERNAME"
              value="username"
              c:type="NM_SETTING_CDMA_USERNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_AUTOCONNECT"
              value="autoconnect"
              c:type="NM_SETTING_CONNECTION_AUTOCONNECT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_AUTOCONNECT_PRIORITY"
              value="autoconnect-priority"
              c:type="NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_AUTOCONNECT_PRIORITY_DEFAULT"
              value="0"
              c:type="NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_DEFAULT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SETTING_CONNECTION_AUTOCONNECT_PRIORITY_MAX"
              value="999"
              c:type="NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_MAX">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SETTING_CONNECTION_AUTOCONNECT_PRIORITY_MIN"
              value="-999"
              c:type="NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_MIN">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SETTING_CONNECTION_AUTOCONNECT_RETRIES"
              value="autoconnect-retries"
              c:type="NM_SETTING_CONNECTION_AUTOCONNECT_RETRIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_AUTOCONNECT_SLAVES"
              value="autoconnect-slaves"
              c:type="NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_GATEWAY_PING_TIMEOUT"
              value="gateway-ping-timeout"
              c:type="NM_SETTING_CONNECTION_GATEWAY_PING_TIMEOUT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_ID"
              value="id"
              c:type="NM_SETTING_CONNECTION_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_INTERFACE_NAME"
              value="interface-name"
              c:type="NM_SETTING_CONNECTION_INTERFACE_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_LLDP"
              value="lldp"
              c:type="NM_SETTING_CONNECTION_LLDP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_MASTER"
              value="master"
              c:type="NM_SETTING_CONNECTION_MASTER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_METERED"
              value="metered"
              c:type="NM_SETTING_CONNECTION_METERED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_PERMISSIONS"
              value="permissions"
              c:type="NM_SETTING_CONNECTION_PERMISSIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_READ_ONLY"
              value="read-only"
              c:type="NM_SETTING_CONNECTION_READ_ONLY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_SECONDARIES"
              value="secondaries"
              c:type="NM_SETTING_CONNECTION_SECONDARIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_SETTING_NAME"
              value="connection"
              c:type="NM_SETTING_CONNECTION_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_SLAVE_TYPE"
              value="slave-type"
              c:type="NM_SETTING_CONNECTION_SLAVE_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_STABLE_ID"
              value="stable-id"
              c:type="NM_SETTING_CONNECTION_STABLE_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_TIMESTAMP"
              value="timestamp"
              c:type="NM_SETTING_CONNECTION_TIMESTAMP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_TYPE"
              value="type"
              c:type="NM_SETTING_CONNECTION_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_UUID"
              value="uuid"
              c:type="NM_SETTING_CONNECTION_UUID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_ZONE"
              value="zone"
              c:type="NM_SETTING_CONNECTION_ZONE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_APP_FCOE_FLAGS"
              value="app-fcoe-flags"
              c:type="NM_SETTING_DCB_APP_FCOE_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_APP_FCOE_MODE"
              value="app-fcoe-mode"
              c:type="NM_SETTING_DCB_APP_FCOE_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_APP_FCOE_PRIORITY"
              value="app-fcoe-priority"
              c:type="NM_SETTING_DCB_APP_FCOE_PRIORITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_APP_FIP_FLAGS"
              value="app-fip-flags"
              c:type="NM_SETTING_DCB_APP_FIP_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_APP_FIP_PRIORITY"
              value="app-fip-priority"
              c:type="NM_SETTING_DCB_APP_FIP_PRIORITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_APP_ISCSI_FLAGS"
              value="app-iscsi-flags"
              c:type="NM_SETTING_DCB_APP_ISCSI_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_APP_ISCSI_PRIORITY"
              value="app-iscsi-priority"
              c:type="NM_SETTING_DCB_APP_ISCSI_PRIORITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_FCOE_MODE_FABRIC"
              value="fabric"
              c:type="NM_SETTING_DCB_FCOE_MODE_FABRIC">
      <doc xml:space="preserve">Indicates that the FCoE controller should use "fabric" mode (default)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_FCOE_MODE_VN2VN"
              value="vn2vn"
              c:type="NM_SETTING_DCB_FCOE_MODE_VN2VN">
      <doc xml:space="preserve">Indicates that the FCoE controller should use "VN2VN" mode.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_PRIORITY_BANDWIDTH"
              value="priority-bandwidth"
              c:type="NM_SETTING_DCB_PRIORITY_BANDWIDTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_PRIORITY_FLOW_CONTROL"
              value="priority-flow-control"
              c:type="NM_SETTING_DCB_PRIORITY_FLOW_CONTROL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_PRIORITY_FLOW_CONTROL_FLAGS"
              value="priority-flow-control-flags"
              c:type="NM_SETTING_DCB_PRIORITY_FLOW_CONTROL_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_PRIORITY_GROUP_BANDWIDTH"
              value="priority-group-bandwidth"
              c:type="NM_SETTING_DCB_PRIORITY_GROUP_BANDWIDTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_PRIORITY_GROUP_FLAGS"
              value="priority-group-flags"
              c:type="NM_SETTING_DCB_PRIORITY_GROUP_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_PRIORITY_GROUP_ID"
              value="priority-group-id"
              c:type="NM_SETTING_DCB_PRIORITY_GROUP_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_PRIORITY_STRICT_BANDWIDTH"
              value="priority-strict-bandwidth"
              c:type="NM_SETTING_DCB_PRIORITY_STRICT_BANDWIDTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_PRIORITY_TRAFFIC_CLASS"
              value="priority-traffic-class"
              c:type="NM_SETTING_DCB_PRIORITY_TRAFFIC_CLASS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_SETTING_NAME"
              value="dcb"
              c:type="NM_SETTING_DCB_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DNS_OPTION_ATTEMPTS"
              value="attempts"
              c:type="NM_SETTING_DNS_OPTION_ATTEMPTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DNS_OPTION_DEBUG"
              value="debug"
              c:type="NM_SETTING_DNS_OPTION_DEBUG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DNS_OPTION_EDNS0"
              value="edns0"
              c:type="NM_SETTING_DNS_OPTION_EDNS0">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DNS_OPTION_INET6"
              value="inet6"
              c:type="NM_SETTING_DNS_OPTION_INET6">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DNS_OPTION_IP6_BYTESTRING"
              value="ip6-bytestring"
              c:type="NM_SETTING_DNS_OPTION_IP6_BYTESTRING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DNS_OPTION_IP6_DOTINT"
              value="ip6-dotint"
              c:type="NM_SETTING_DNS_OPTION_IP6_DOTINT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DNS_OPTION_NDOTS"
              value="ndots"
              c:type="NM_SETTING_DNS_OPTION_NDOTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DNS_OPTION_NO_CHECK_NAMES"
              value="no-check-names"
              c:type="NM_SETTING_DNS_OPTION_NO_CHECK_NAMES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DNS_OPTION_NO_IP6_DOTINT"
              value="no-ip6-dotint"
              c:type="NM_SETTING_DNS_OPTION_NO_IP6_DOTINT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DNS_OPTION_NO_TLD_QUERY"
              value="no-tld-query"
              c:type="NM_SETTING_DNS_OPTION_NO_TLD_QUERY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DNS_OPTION_ROTATE"
              value="rotate"
              c:type="NM_SETTING_DNS_OPTION_ROTATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DNS_OPTION_SINGLE_REQUEST"
              value="single-request"
              c:type="NM_SETTING_DNS_OPTION_SINGLE_REQUEST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DNS_OPTION_SINGLE_REQUEST_REOPEN"
              value="single-request-reopen"
              c:type="NM_SETTING_DNS_OPTION_SINGLE_REQUEST_REOPEN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DNS_OPTION_TIMEOUT"
              value="timeout"
              c:type="NM_SETTING_DNS_OPTION_TIMEOUT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DNS_OPTION_USE_VC"
              value="use-vc"
              c:type="NM_SETTING_DNS_OPTION_USE_VC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DUMMY_SETTING_NAME"
              value="dummy"
              c:type="NM_SETTING_DUMMY_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GENERIC_SETTING_NAME"
              value="generic"
              c:type="NM_SETTING_GENERIC_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_APN" value="apn" c:type="NM_SETTING_GSM_APN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_DEVICE_ID"
              value="device-id"
              c:type="NM_SETTING_GSM_DEVICE_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_HOME_ONLY"
              value="home-only"
              c:type="NM_SETTING_GSM_HOME_ONLY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_MTU" value="mtu" c:type="NM_SETTING_GSM_MTU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_NETWORK_ID"
              value="network-id"
              c:type="NM_SETTING_GSM_NETWORK_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_NUMBER"
              value="number"
              c:type="NM_SETTING_GSM_NUMBER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_PASSWORD"
              value="password"
              c:type="NM_SETTING_GSM_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_PASSWORD_FLAGS"
              value="password-flags"
              c:type="NM_SETTING_GSM_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_PIN" value="pin" c:type="NM_SETTING_GSM_PIN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_PIN_FLAGS"
              value="pin-flags"
              c:type="NM_SETTING_GSM_PIN_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_SETTING_NAME"
              value="gsm"
              c:type="NM_SETTING_GSM_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_SIM_ID"
              value="sim-id"
              c:type="NM_SETTING_GSM_SIM_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_SIM_OPERATOR_ID"
              value="sim-operator-id"
              c:type="NM_SETTING_GSM_SIM_OPERATOR_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_USERNAME"
              value="username"
              c:type="NM_SETTING_GSM_USERNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_INFINIBAND_MAC_ADDRESS"
              value="mac-address"
              c:type="NM_SETTING_INFINIBAND_MAC_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_INFINIBAND_MTU"
              value="mtu"
              c:type="NM_SETTING_INFINIBAND_MTU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_INFINIBAND_PARENT"
              value="parent"
              c:type="NM_SETTING_INFINIBAND_PARENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_INFINIBAND_P_KEY"
              value="p-key"
              c:type="NM_SETTING_INFINIBAND_P_KEY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_INFINIBAND_SETTING_NAME"
              value="infiniband"
              c:type="NM_SETTING_INFINIBAND_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_INFINIBAND_TRANSPORT_MODE"
              value="transport-mode"
              c:type="NM_SETTING_INFINIBAND_TRANSPORT_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_DHCP_CLIENT_ID"
              value="dhcp-client-id"
              c:type="NM_SETTING_IP4_CONFIG_DHCP_CLIENT_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_DHCP_FQDN"
              value="dhcp-fqdn"
              c:type="NM_SETTING_IP4_CONFIG_DHCP_FQDN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_METHOD_AUTO"
              value="auto"
              c:type="NM_SETTING_IP4_CONFIG_METHOD_AUTO">
      <doc xml:space="preserve">IPv4 configuration should be automatically determined via a method appropriate
for the hardware interface, ie DHCP or PPP or some other device-specific
manner.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_METHOD_DISABLED"
              value="disabled"
              c:type="NM_SETTING_IP4_CONFIG_METHOD_DISABLED">
      <doc xml:space="preserve">This connection does not use or require IPv4 address and it should be disabled.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_METHOD_LINK_LOCAL"
              value="link-local"
              c:type="NM_SETTING_IP4_CONFIG_METHOD_LINK_LOCAL">
      <doc xml:space="preserve">IPv4 configuration should be automatically configured for link-local-only
operation.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_METHOD_MANUAL"
              value="manual"
              c:type="NM_SETTING_IP4_CONFIG_METHOD_MANUAL">
      <doc xml:space="preserve">All necessary IPv4 configuration (addresses, prefix, DNS, etc) is specified
in the setting's properties.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_METHOD_SHARED"
              value="shared"
              c:type="NM_SETTING_IP4_CONFIG_METHOD_SHARED">
      <doc xml:space="preserve">This connection specifies configuration that allows other computers to
connect through it to the default network (usually the Internet).  The
connection's interface will be assigned a private address, and a DHCP server,
caching DNS server, and Network Address Translation (NAT) functionality will
be started on this connection's interface to allow other devices to connect
through that interface to the default network.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_SETTING_NAME"
              value="ipv4"
              c:type="NM_SETTING_IP4_CONFIG_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_ADDR_GEN_MODE"
              value="addr-gen-mode"
              c:type="NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_IP6_PRIVACY"
              value="ip6-privacy"
              c:type="NM_SETTING_IP6_CONFIG_IP6_PRIVACY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_METHOD_AUTO"
              value="auto"
              c:type="NM_SETTING_IP6_CONFIG_METHOD_AUTO">
      <doc xml:space="preserve">IPv6 configuration should be automatically determined via a method appropriate
for the hardware interface, ie router advertisements, DHCP, or PPP or some
other device-specific manner.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_METHOD_DHCP"
              value="dhcp"
              c:type="NM_SETTING_IP6_CONFIG_METHOD_DHCP">
      <doc xml:space="preserve">IPv6 configuration should be automatically determined via DHCPv6 only and
router advertisements should be ignored.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_METHOD_IGNORE"
              value="ignore"
              c:type="NM_SETTING_IP6_CONFIG_METHOD_IGNORE">
      <doc xml:space="preserve">IPv6 is not required or is handled by some other mechanism, and NetworkManager
should not configure IPv6 for this connection.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_METHOD_LINK_LOCAL"
              value="link-local"
              c:type="NM_SETTING_IP6_CONFIG_METHOD_LINK_LOCAL">
      <doc xml:space="preserve">IPv6 configuration should be automatically configured for link-local-only
operation.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_METHOD_MANUAL"
              value="manual"
              c:type="NM_SETTING_IP6_CONFIG_METHOD_MANUAL">
      <doc xml:space="preserve">All necessary IPv6 configuration (addresses, prefix, DNS, etc) is specified
in the setting's properties.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_METHOD_SHARED"
              value="shared"
              c:type="NM_SETTING_IP6_CONFIG_METHOD_SHARED">
      <doc xml:space="preserve">This connection specifies configuration that allows other computers to
connect through it to the default network (usually the Internet).  The
connection's interface will be assigned a private address, and router
advertisements, a caching DNS server, and Network Address Translation (NAT)
functionality will be started on this connection's interface to allow other
devices to connect through that interface to the default network. (not yet
supported for IPv6)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_SETTING_NAME"
              value="ipv6"
              c:type="NM_SETTING_IP6_CONFIG_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_TOKEN"
              value="token"
              c:type="NM_SETTING_IP6_CONFIG_TOKEN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_CONFIG_ADDRESSES"
              value="addresses"
              c:type="NM_SETTING_IP_CONFIG_ADDRESSES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_CONFIG_DAD_TIMEOUT"
              value="dad-timeout"
              c:type="NM_SETTING_IP_CONFIG_DAD_TIMEOUT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_CONFIG_DAD_TIMEOUT_MAX"
              value="30000"
              c:type="NM_SETTING_IP_CONFIG_DAD_TIMEOUT_MAX">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SETTING_IP_CONFIG_DHCP_HOSTNAME"
              value="dhcp-hostname"
              c:type="NM_SETTING_IP_CONFIG_DHCP_HOSTNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_CONFIG_DHCP_SEND_HOSTNAME"
              value="dhcp-send-hostname"
              c:type="NM_SETTING_IP_CONFIG_DHCP_SEND_HOSTNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_CONFIG_DHCP_TIMEOUT"
              value="dhcp-timeout"
              c:type="NM_SETTING_IP_CONFIG_DHCP_TIMEOUT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_CONFIG_DNS"
              value="dns"
              c:type="NM_SETTING_IP_CONFIG_DNS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_CONFIG_DNS_OPTIONS"
              value="dns-options"
              c:type="NM_SETTING_IP_CONFIG_DNS_OPTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_CONFIG_DNS_PRIORITY"
              value="dns-priority"
              c:type="NM_SETTING_IP_CONFIG_DNS_PRIORITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_CONFIG_DNS_SEARCH"
              value="dns-search"
              c:type="NM_SETTING_IP_CONFIG_DNS_SEARCH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_CONFIG_GATEWAY"
              value="gateway"
              c:type="NM_SETTING_IP_CONFIG_GATEWAY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_CONFIG_IGNORE_AUTO_DNS"
              value="ignore-auto-dns"
              c:type="NM_SETTING_IP_CONFIG_IGNORE_AUTO_DNS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_CONFIG_IGNORE_AUTO_ROUTES"
              value="ignore-auto-routes"
              c:type="NM_SETTING_IP_CONFIG_IGNORE_AUTO_ROUTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_CONFIG_MAY_FAIL"
              value="may-fail"
              c:type="NM_SETTING_IP_CONFIG_MAY_FAIL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_CONFIG_METHOD"
              value="method"
              c:type="NM_SETTING_IP_CONFIG_METHOD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_CONFIG_NEVER_DEFAULT"
              value="never-default"
              c:type="NM_SETTING_IP_CONFIG_NEVER_DEFAULT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_CONFIG_ROUTES"
              value="routes"
              c:type="NM_SETTING_IP_CONFIG_ROUTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_CONFIG_ROUTE_METRIC"
              value="route-metric"
              c:type="NM_SETTING_IP_CONFIG_ROUTE_METRIC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_TUNNEL_ENCAPSULATION_LIMIT"
              value="encapsulation-limit"
              c:type="NM_SETTING_IP_TUNNEL_ENCAPSULATION_LIMIT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_TUNNEL_FLOW_LABEL"
              value="flow-label"
              c:type="NM_SETTING_IP_TUNNEL_FLOW_LABEL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_TUNNEL_INPUT_KEY"
              value="input-key"
              c:type="NM_SETTING_IP_TUNNEL_INPUT_KEY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_TUNNEL_LOCAL"
              value="local"
              c:type="NM_SETTING_IP_TUNNEL_LOCAL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_TUNNEL_MODE"
              value="mode"
              c:type="NM_SETTING_IP_TUNNEL_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_TUNNEL_MTU"
              value="mtu"
              c:type="NM_SETTING_IP_TUNNEL_MTU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_TUNNEL_OUTPUT_KEY"
              value="output-key"
              c:type="NM_SETTING_IP_TUNNEL_OUTPUT_KEY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_TUNNEL_PARENT"
              value="parent"
              c:type="NM_SETTING_IP_TUNNEL_PARENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_TUNNEL_PATH_MTU_DISCOVERY"
              value="path-mtu-discovery"
              c:type="NM_SETTING_IP_TUNNEL_PATH_MTU_DISCOVERY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_TUNNEL_REMOTE"
              value="remote"
              c:type="NM_SETTING_IP_TUNNEL_REMOTE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_TUNNEL_SETTING_NAME"
              value="ip-tunnel"
              c:type="NM_SETTING_IP_TUNNEL_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_TUNNEL_TOS"
              value="tos"
              c:type="NM_SETTING_IP_TUNNEL_TOS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP_TUNNEL_TTL"
              value="ttl"
              c:type="NM_SETTING_IP_TUNNEL_TTL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_MACSEC_ENCRYPT"
              value="encrypt"
              c:type="NM_SETTING_MACSEC_ENCRYPT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_MACSEC_MKA_CAK"
              value="mka-cak"
              c:type="NM_SETTING_MACSEC_MKA_CAK">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_MACSEC_MKA_CAK_FLAGS"
              value="mka-cak-flags"
              c:type="NM_SETTING_MACSEC_MKA_CAK_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_MACSEC_MKA_CAK_LENGTH"
              value="32"
              c:type="NM_SETTING_MACSEC_MKA_CAK_LENGTH">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SETTING_MACSEC_MKA_CKN"
              value="mka-ckn"
              c:type="NM_SETTING_MACSEC_MKA_CKN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_MACSEC_MKA_CKN_LENGTH"
              value="64"
              c:type="NM_SETTING_MACSEC_MKA_CKN_LENGTH">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SETTING_MACSEC_MODE"
              value="mode"
              c:type="NM_SETTING_MACSEC_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_MACSEC_PARENT"
              value="parent"
              c:type="NM_SETTING_MACSEC_PARENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_MACSEC_PORT"
              value="port"
              c:type="NM_SETTING_MACSEC_PORT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_MACSEC_SETTING_NAME"
              value="macsec"
              c:type="NM_SETTING_MACSEC_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_MACSEC_VALIDATION"
              value="validation"
              c:type="NM_SETTING_MACSEC_VALIDATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_MACVLAN_MODE"
              value="mode"
              c:type="NM_SETTING_MACVLAN_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_MACVLAN_PARENT"
              value="parent"
              c:type="NM_SETTING_MACVLAN_PARENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_MACVLAN_PROMISCUOUS"
              value="promiscuous"
              c:type="NM_SETTING_MACVLAN_PROMISCUOUS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_MACVLAN_SETTING_NAME"
              value="macvlan"
              c:type="NM_SETTING_MACVLAN_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_MACVLAN_TAP"
              value="tap"
              c:type="NM_SETTING_MACVLAN_TAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_NAME" value="name" c:type="NM_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_OLPC_MESH_CHANNEL"
              value="channel"
              c:type="NM_SETTING_OLPC_MESH_CHANNEL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_OLPC_MESH_DHCP_ANYCAST_ADDRESS"
              value="dhcp-anycast-address"
              c:type="NM_SETTING_OLPC_MESH_DHCP_ANYCAST_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_OLPC_MESH_SETTING_NAME"
              value="802-11-olpc-mesh"
              c:type="NM_SETTING_OLPC_MESH_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_OLPC_MESH_SSID"
              value="ssid"
              c:type="NM_SETTING_OLPC_MESH_SSID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PARAM_FUZZY_IGNORE"
              value="8"
              c:type="NM_SETTING_PARAM_FUZZY_IGNORE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SETTING_PARAM_REQUIRED"
              value="2"
              c:type="NM_SETTING_PARAM_REQUIRED">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SETTING_PARAM_SECRET"
              value="4"
              c:type="NM_SETTING_PARAM_SECRET">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SETTING_PPPOE_PASSWORD"
              value="password"
              c:type="NM_SETTING_PPPOE_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPPOE_PASSWORD_FLAGS"
              value="password-flags"
              c:type="NM_SETTING_PPPOE_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPPOE_SERVICE"
              value="service"
              c:type="NM_SETTING_PPPOE_SERVICE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPPOE_SETTING_NAME"
              value="pppoe"
              c:type="NM_SETTING_PPPOE_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPPOE_USERNAME"
              value="username"
              c:type="NM_SETTING_PPPOE_USERNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_BAUD"
              value="baud"
              c:type="NM_SETTING_PPP_BAUD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_CRTSCTS"
              value="crtscts"
              c:type="NM_SETTING_PPP_CRTSCTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_LCP_ECHO_FAILURE"
              value="lcp-echo-failure"
              c:type="NM_SETTING_PPP_LCP_ECHO_FAILURE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_LCP_ECHO_INTERVAL"
              value="lcp-echo-interval"
              c:type="NM_SETTING_PPP_LCP_ECHO_INTERVAL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_MPPE_STATEFUL"
              value="mppe-stateful"
              c:type="NM_SETTING_PPP_MPPE_STATEFUL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_MRU" value="mru" c:type="NM_SETTING_PPP_MRU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_MTU" value="mtu" c:type="NM_SETTING_PPP_MTU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_NOAUTH"
              value="noauth"
              c:type="NM_SETTING_PPP_NOAUTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_NOBSDCOMP"
              value="nobsdcomp"
              c:type="NM_SETTING_PPP_NOBSDCOMP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_NODEFLATE"
              value="nodeflate"
              c:type="NM_SETTING_PPP_NODEFLATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_NO_VJ_COMP"
              value="no-vj-comp"
              c:type="NM_SETTING_PPP_NO_VJ_COMP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_REFUSE_CHAP"
              value="refuse-chap"
              c:type="NM_SETTING_PPP_REFUSE_CHAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_REFUSE_EAP"
              value="refuse-eap"
              c:type="NM_SETTING_PPP_REFUSE_EAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_REFUSE_MSCHAP"
              value="refuse-mschap"
              c:type="NM_SETTING_PPP_REFUSE_MSCHAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_REFUSE_MSCHAPV2"
              value="refuse-mschapv2"
              c:type="NM_SETTING_PPP_REFUSE_MSCHAPV2">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_REFUSE_PAP"
              value="refuse-pap"
              c:type="NM_SETTING_PPP_REFUSE_PAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_REQUIRE_MPPE"
              value="require-mppe"
              c:type="NM_SETTING_PPP_REQUIRE_MPPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_REQUIRE_MPPE_128"
              value="require-mppe-128"
              c:type="NM_SETTING_PPP_REQUIRE_MPPE_128">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_SETTING_NAME"
              value="ppp"
              c:type="NM_SETTING_PPP_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PROXY_BROWSER_ONLY"
              value="browser-only"
              c:type="NM_SETTING_PROXY_BROWSER_ONLY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PROXY_METHOD"
              value="method"
              c:type="NM_SETTING_PROXY_METHOD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PROXY_PAC_SCRIPT"
              value="pac-script"
              c:type="NM_SETTING_PROXY_PAC_SCRIPT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PROXY_PAC_URL"
              value="pac-url"
              c:type="NM_SETTING_PROXY_PAC_URL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PROXY_SETTING_NAME"
              value="proxy"
              c:type="NM_SETTING_PROXY_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_SERIAL_BAUD"
              value="baud"
              c:type="NM_SETTING_SERIAL_BAUD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_SERIAL_BITS"
              value="bits"
              c:type="NM_SETTING_SERIAL_BITS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_SERIAL_PARITY"
              value="parity"
              c:type="NM_SETTING_SERIAL_PARITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_SERIAL_SEND_DELAY"
              value="send-delay"
              c:type="NM_SETTING_SERIAL_SEND_DELAY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_SERIAL_SETTING_NAME"
              value="serial"
              c:type="NM_SETTING_SERIAL_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_SERIAL_STOPBITS"
              value="stopbits"
              c:type="NM_SETTING_SERIAL_STOPBITS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_TEAM_CONFIG"
              value="config"
              c:type="NM_SETTING_TEAM_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_TEAM_PORT_CONFIG"
              value="config"
              c:type="NM_SETTING_TEAM_PORT_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_TEAM_PORT_SETTING_NAME"
              value="team-port"
              c:type="NM_SETTING_TEAM_PORT_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_TEAM_SETTING_NAME"
              value="team"
              c:type="NM_SETTING_TEAM_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_TUN_GROUP"
              value="group"
              c:type="NM_SETTING_TUN_GROUP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_TUN_MODE"
              value="mode"
              c:type="NM_SETTING_TUN_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_TUN_MULTI_QUEUE"
              value="multi-queue"
              c:type="NM_SETTING_TUN_MULTI_QUEUE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_TUN_OWNER"
              value="owner"
              c:type="NM_SETTING_TUN_OWNER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_TUN_PI" value="pi" c:type="NM_SETTING_TUN_PI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_TUN_SETTING_NAME"
              value="tun"
              c:type="NM_SETTING_TUN_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_TUN_VNET_HDR"
              value="vnet-hdr"
              c:type="NM_SETTING_TUN_VNET_HDR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_USER_DATA"
              value="data"
              c:type="NM_SETTING_USER_DATA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_USER_SETTING_NAME"
              value="user"
              c:type="NM_SETTING_USER_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VLAN_EGRESS_PRIORITY_MAP"
              value="egress-priority-map"
              c:type="NM_SETTING_VLAN_EGRESS_PRIORITY_MAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VLAN_FLAGS"
              value="flags"
              c:type="NM_SETTING_VLAN_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VLAN_ID" value="id" c:type="NM_SETTING_VLAN_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VLAN_INGRESS_PRIORITY_MAP"
              value="ingress-priority-map"
              c:type="NM_SETTING_VLAN_INGRESS_PRIORITY_MAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VLAN_PARENT"
              value="parent"
              c:type="NM_SETTING_VLAN_PARENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VLAN_SETTING_NAME"
              value="vlan"
              c:type="NM_SETTING_VLAN_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VPN_DATA"
              value="data"
              c:type="NM_SETTING_VPN_DATA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VPN_PERSISTENT"
              value="persistent"
              c:type="NM_SETTING_VPN_PERSISTENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VPN_SECRETS"
              value="secrets"
              c:type="NM_SETTING_VPN_SECRETS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VPN_SERVICE_TYPE"
              value="service-type"
              c:type="NM_SETTING_VPN_SERVICE_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VPN_SETTING_NAME"
              value="vpn"
              c:type="NM_SETTING_VPN_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VPN_TIMEOUT"
              value="timeout"
              c:type="NM_SETTING_VPN_TIMEOUT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VPN_USER_NAME"
              value="user-name"
              c:type="NM_SETTING_VPN_USER_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VXLAN_AGEING"
              value="ageing"
              c:type="NM_SETTING_VXLAN_AGEING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VXLAN_DESTINATION_PORT"
              value="destination-port"
              c:type="NM_SETTING_VXLAN_DESTINATION_PORT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VXLAN_ID" value="id" c:type="NM_SETTING_VXLAN_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VXLAN_L2_MISS"
              value="l2-miss"
              c:type="NM_SETTING_VXLAN_L2_MISS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VXLAN_L3_MISS"
              value="l3-miss"
              c:type="NM_SETTING_VXLAN_L3_MISS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VXLAN_LEARNING"
              value="learning"
              c:type="NM_SETTING_VXLAN_LEARNING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VXLAN_LIMIT"
              value="limit"
              c:type="NM_SETTING_VXLAN_LIMIT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VXLAN_LOCAL"
              value="local"
              c:type="NM_SETTING_VXLAN_LOCAL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VXLAN_PARENT"
              value="parent"
              c:type="NM_SETTING_VXLAN_PARENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VXLAN_PROXY"
              value="proxy"
              c:type="NM_SETTING_VXLAN_PROXY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VXLAN_REMOTE"
              value="remote"
              c:type="NM_SETTING_VXLAN_REMOTE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VXLAN_RSC"
              value="rsc"
              c:type="NM_SETTING_VXLAN_RSC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VXLAN_SETTING_NAME"
              value="vxlan"
              c:type="NM_SETTING_VXLAN_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VXLAN_SOURCE_PORT_MAX"
              value="source-port-max"
              c:type="NM_SETTING_VXLAN_SOURCE_PORT_MAX">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VXLAN_SOURCE_PORT_MIN"
              value="source-port-min"
              c:type="NM_SETTING_VXLAN_SOURCE_PORT_MIN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VXLAN_TOS"
              value="tos"
              c:type="NM_SETTING_VXLAN_TOS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VXLAN_TTL"
              value="ttl"
              c:type="NM_SETTING_VXLAN_TTL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIMAX_MAC_ADDRESS"
              value="mac-address"
              c:type="NM_SETTING_WIMAX_MAC_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIMAX_NETWORK_NAME"
              value="network-name"
              c:type="NM_SETTING_WIMAX_NETWORK_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIMAX_SETTING_NAME"
              value="wimax"
              c:type="NM_SETTING_WIMAX_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_AUTO_NEGOTIATE"
              value="auto-negotiate"
              c:type="NM_SETTING_WIRED_AUTO_NEGOTIATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_CLONED_MAC_ADDRESS"
              value="cloned-mac-address"
              c:type="NM_SETTING_WIRED_CLONED_MAC_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_DUPLEX"
              value="duplex"
              c:type="NM_SETTING_WIRED_DUPLEX">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_GENERATE_MAC_ADDRESS_MASK"
              value="generate-mac-address-mask"
              c:type="NM_SETTING_WIRED_GENERATE_MAC_ADDRESS_MASK">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_MAC_ADDRESS"
              value="mac-address"
              c:type="NM_SETTING_WIRED_MAC_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_MAC_ADDRESS_BLACKLIST"
              value="mac-address-blacklist"
              c:type="NM_SETTING_WIRED_MAC_ADDRESS_BLACKLIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_MTU"
              value="mtu"
              c:type="NM_SETTING_WIRED_MTU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_PORT"
              value="port"
              c:type="NM_SETTING_WIRED_PORT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_S390_NETTYPE"
              value="s390-nettype"
              c:type="NM_SETTING_WIRED_S390_NETTYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_S390_OPTIONS"
              value="s390-options"
              c:type="NM_SETTING_WIRED_S390_OPTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_S390_SUBCHANNELS"
              value="s390-subchannels"
              c:type="NM_SETTING_WIRED_S390_SUBCHANNELS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_SETTING_NAME"
              value="802-3-ethernet"
              c:type="NM_SETTING_WIRED_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_SPEED"
              value="speed"
              c:type="NM_SETTING_WIRED_SPEED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_WAKE_ON_LAN"
              value="wake-on-lan"
              c:type="NM_SETTING_WIRED_WAKE_ON_LAN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_WAKE_ON_LAN_PASSWORD"
              value="wake-on-lan-password"
              c:type="NM_SETTING_WIRED_WAKE_ON_LAN_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_BAND"
              value="band"
              c:type="NM_SETTING_WIRELESS_BAND">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_BSSID"
              value="bssid"
              c:type="NM_SETTING_WIRELESS_BSSID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_CHANNEL"
              value="channel"
              c:type="NM_SETTING_WIRELESS_CHANNEL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_CLONED_MAC_ADDRESS"
              value="cloned-mac-address"
              c:type="NM_SETTING_WIRELESS_CLONED_MAC_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_GENERATE_MAC_ADDRESS_MASK"
              value="generate-mac-address-mask"
              c:type="NM_SETTING_WIRELESS_GENERATE_MAC_ADDRESS_MASK">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_HIDDEN"
              value="hidden"
              c:type="NM_SETTING_WIRELESS_HIDDEN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_MAC_ADDRESS"
              value="mac-address"
              c:type="NM_SETTING_WIRELESS_MAC_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_MAC_ADDRESS_BLACKLIST"
              value="mac-address-blacklist"
              c:type="NM_SETTING_WIRELESS_MAC_ADDRESS_BLACKLIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_MAC_ADDRESS_RANDOMIZATION"
              value="mac-address-randomization"
              c:type="NM_SETTING_WIRELESS_MAC_ADDRESS_RANDOMIZATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_MODE"
              value="mode"
              c:type="NM_SETTING_WIRELESS_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_MODE_ADHOC"
              value="adhoc"
              c:type="NM_SETTING_WIRELESS_MODE_ADHOC">
      <doc xml:space="preserve">Indicates Ad-Hoc mode where no access point is expected to be present.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_MODE_AP"
              value="ap"
              c:type="NM_SETTING_WIRELESS_MODE_AP">
      <doc xml:space="preserve">Indicates AP/master mode where the wireless device is started as an access
point/hotspot.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_MODE_INFRA"
              value="infrastructure"
              c:type="NM_SETTING_WIRELESS_MODE_INFRA">
      <doc xml:space="preserve">Indicates infrastructure mode where an access point is expected to be present
for this connection.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_MTU"
              value="mtu"
              c:type="NM_SETTING_WIRELESS_MTU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_POWERSAVE"
              value="powersave"
              c:type="NM_SETTING_WIRELESS_POWERSAVE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_RATE"
              value="rate"
              c:type="NM_SETTING_WIRELESS_RATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_AUTH_ALG"
              value="auth-alg"
              c:type="NM_SETTING_WIRELESS_SECURITY_AUTH_ALG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_GROUP"
              value="group"
              c:type="NM_SETTING_WIRELESS_SECURITY_GROUP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_KEY_MGMT"
              value="key-mgmt"
              c:type="NM_SETTING_WIRELESS_SECURITY_KEY_MGMT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_LEAP_PASSWORD"
              value="leap-password"
              c:type="NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_LEAP_PASSWORD_FLAGS"
              value="leap-password-flags"
              c:type="NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_LEAP_USERNAME"
              value="leap-username"
              c:type="NM_SETTING_WIRELESS_SECURITY_LEAP_USERNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_PAIRWISE"
              value="pairwise"
              c:type="NM_SETTING_WIRELESS_SECURITY_PAIRWISE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_PROTO"
              value="proto"
              c:type="NM_SETTING_WIRELESS_SECURITY_PROTO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_PSK"
              value="psk"
              c:type="NM_SETTING_WIRELESS_SECURITY_PSK">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_PSK_FLAGS"
              value="psk-flags"
              c:type="NM_SETTING_WIRELESS_SECURITY_PSK_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_SETTING_NAME"
              value="802-11-wireless-security"
              c:type="NM_SETTING_WIRELESS_SECURITY_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_WEP_KEY0"
              value="wep-key0"
              c:type="NM_SETTING_WIRELESS_SECURITY_WEP_KEY0">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_WEP_KEY1"
              value="wep-key1"
              c:type="NM_SETTING_WIRELESS_SECURITY_WEP_KEY1">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_WEP_KEY2"
              value="wep-key2"
              c:type="NM_SETTING_WIRELESS_SECURITY_WEP_KEY2">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_WEP_KEY3"
              value="wep-key3"
              c:type="NM_SETTING_WIRELESS_SECURITY_WEP_KEY3">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_WEP_KEY_FLAGS"
              value="wep-key-flags"
              c:type="NM_SETTING_WIRELESS_SECURITY_WEP_KEY_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE"
              value="wep-key-type"
              c:type="NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX"
              value="wep-tx-keyidx"
              c:type="NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SEEN_BSSIDS"
              value="seen-bssids"
              c:type="NM_SETTING_WIRELESS_SEEN_BSSIDS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SETTING_NAME"
              value="802-11-wireless"
              c:type="NM_SETTING_WIRELESS_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SSID"
              value="ssid"
              c:type="NM_SETTING_WIRELESS_SSID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_TX_POWER"
              value="tx-power"
              c:type="NM_SETTING_WIRELESS_TX_POWER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <bitfield name="SecretAgentCapabilities"
              glib:type-name="NMSecretAgentCapabilities"
              glib:get-type="nm_secret_agent_capabilities_get_type"
              c:type="NMSecretAgentCapabilities">
      <doc xml:space="preserve">#NMSecretAgentCapabilities indicate various capabilities of the agent.</doc>
      <member name="none"
              value="0"
              c:identifier="NM_SECRET_AGENT_CAPABILITY_NONE"
              glib:nick="none">
        <doc xml:space="preserve">the agent supports no special capabilities</doc>
      </member>
      <member name="vpn_hints"
              value="1"
              c:identifier="NM_SECRET_AGENT_CAPABILITY_VPN_HINTS"
              glib:nick="vpn-hints">
        <doc xml:space="preserve">the agent supports passing hints to
VPN plugin authentication dialogs.</doc>
      </member>
      <member name="last"
              value="1"
              c:identifier="NM_SECRET_AGENT_CAPABILITY_LAST"
              glib:nick="last">
        <doc xml:space="preserve">bounds checking value; should not be used.</doc>
      </member>
    </bitfield>
    <enumeration name="SecretAgentError"
                 glib:type-name="NMSecretAgentError"
                 glib:get-type="nm_secret_agent_error_get_type"
                 c:type="NMSecretAgentError"
                 glib:error-domain="nm-secret-agent-error-quark">
      <doc xml:space="preserve">#NMSecretAgentError values are passed by secret agents back to NetworkManager
when they encounter problems retrieving secrets on behalf of NM. They
correspond to errors in the "org.freedesktop.NetworkManager.SecretManager"
namespace.

Client APIs such as nm_client_activate_connection() will not see these error
codes; instead, the secret agent manager will translate them to the
corresponding #NMAgentManagerError codes.</doc>
      <member name="Failed"
              value="0"
              c:identifier="NM_SECRET_AGENT_ERROR_FAILED"
              glib:nick="Failed">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="PermissionDenied"
              value="1"
              c:identifier="NM_SECRET_AGENT_ERROR_PERMISSION_DENIED"
              glib:nick="PermissionDenied">
        <doc xml:space="preserve">the caller (ie, NetworkManager) is
  not authorized to make this request</doc>
      </member>
      <member name="InvalidConnection"
              value="2"
              c:identifier="NM_SECRET_AGENT_ERROR_INVALID_CONNECTION"
              glib:nick="InvalidConnection">
        <doc xml:space="preserve">the connection for which secrets
  were requested is invalid</doc>
      </member>
      <member name="UserCanceled"
              value="3"
              c:identifier="NM_SECRET_AGENT_ERROR_USER_CANCELED"
              glib:nick="UserCanceled">
        <doc xml:space="preserve">the request was canceled by the user</doc>
      </member>
      <member name="AgentCanceled"
              value="4"
              c:identifier="NM_SECRET_AGENT_ERROR_AGENT_CANCELED"
              glib:nick="AgentCanceled">
        <doc xml:space="preserve">the agent canceled the request
  because it was requested to do so by NetworkManager</doc>
      </member>
      <member name="NoSecrets"
              value="5"
              c:identifier="NM_SECRET_AGENT_ERROR_NO_SECRETS"
              glib:nick="NoSecrets">
        <doc xml:space="preserve">the agent cannot find any secrets for this
  connection</doc>
      </member>
      <function name="quark" c:identifier="nm_secret_agent_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <bitfield name="SecretAgentGetSecretsFlags"
              glib:type-name="NMSecretAgentGetSecretsFlags"
              glib:get-type="nm_secret_agent_get_secrets_flags_get_type"
              c:type="NMSecretAgentGetSecretsFlags">
      <doc xml:space="preserve">#NMSecretAgentGetSecretsFlags values modify the behavior of a GetSecrets request.</doc>
      <member name="none"
              value="0"
              c:identifier="NM_SECRET_AGENT_GET_SECRETS_FLAG_NONE"
              glib:nick="none">
        <doc xml:space="preserve">no special behavior; by default no
  user interaction is allowed and requests for secrets are fulfilled from
  persistent storage, or if no secrets are available an error is returned.</doc>
      </member>
      <member name="allow_interaction"
              value="1"
              c:identifier="NM_SECRET_AGENT_GET_SECRETS_FLAG_ALLOW_INTERACTION"
              glib:nick="allow-interaction">
        <doc xml:space="preserve">allows the request to
  interact with the user, possibly prompting via UI for secrets if any are
  required, or if none are found in persistent storage.</doc>
      </member>
      <member name="request_new"
              value="2"
              c:identifier="NM_SECRET_AGENT_GET_SECRETS_FLAG_REQUEST_NEW"
              glib:nick="request-new">
        <doc xml:space="preserve">explicitly prompt for new
  secrets from the user.  This flag signals that NetworkManager thinks any
  existing secrets are invalid or wrong.  This flag implies that interaction
  is allowed.</doc>
      </member>
      <member name="user_requested"
              value="4"
              c:identifier="NM_SECRET_AGENT_GET_SECRETS_FLAG_USER_REQUESTED"
              glib:nick="user-requested">
        <doc xml:space="preserve">set if the request was
  initiated by user-requested action via the D-Bus interface, as opposed to
  automatically initiated by NetworkManager in response to (for example) scan
  results or carrier changes.</doc>
      </member>
      <member name="only_system"
              value="2147483648"
              c:identifier="NM_SECRET_AGENT_GET_SECRETS_FLAG_ONLY_SYSTEM"
              glib:nick="only-system">
        <doc xml:space="preserve">Internal flag, not part of
  the D-Bus API.</doc>
      </member>
      <member name="no_errors"
              value="1073741824"
              c:identifier="NM_SECRET_AGENT_GET_SECRETS_FLAG_NO_ERRORS"
              glib:nick="no-errors">
        <doc xml:space="preserve">Internal flag, not part of
  the D-Bus API.</doc>
      </member>
    </bitfield>
    <class name="SecretAgentOld"
           c:symbol-prefix="secret_agent_old"
           c:type="NMSecretAgentOld"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="NMSecretAgentOld"
           glib:get-type="nm_secret_agent_old_get_type"
           glib:type-struct="SecretAgentOldClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <virtual-method name="cancel_get_secrets">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="SecretAgentOld" c:type="NMSecretAgentOld*"/>
          </instance-parameter>
          <parameter name="connection_path" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="setting_name" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="delete_secrets" invoker="delete_secrets">
        <doc xml:space="preserve">Asynchronously asks the agent to delete all saved secrets belonging to
@connection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSecretAgentOld</doc>
            <type name="SecretAgentOld" c:type="NMSecretAgentOld*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="connection_path" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback, to be invoked when the operation is done</doc>
            <type name="SecretAgentOldDeleteSecretsFunc"
                  c:type="NMSecretAgentOldDeleteSecretsFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="3">
            <doc xml:space="preserve">caller-specific data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_secrets" invoker="get_secrets">
        <doc xml:space="preserve">Asynchronously retrieves secrets belonging to @connection for the
setting @setting_name.  @flags indicate specific behavior that the secret
agent should use when performing the request, for example returning only
existing secrets without user interaction, or requesting entirely new
secrets from the user.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSecretAgentOld</doc>
            <type name="SecretAgentOld" c:type="NMSecretAgentOld*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection for which we're asked secrets</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="connection_path" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="setting_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the secret setting</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="hints" transfer-ownership="none">
            <doc xml:space="preserve">hints to the agent</doc>
            <array c:type="char**">
              <type name="utf8" c:type="char*"/>
            </array>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags that modify the behavior of the request</doc>
            <type name="SecretAgentGetSecretsFlags"
                  c:type="NMSecretAgentGetSecretsFlags"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="6">
            <doc xml:space="preserve">a callback, to be invoked when the operation is done</doc>
            <type name="SecretAgentOldGetSecretsFunc"
                  c:type="NMSecretAgentOldGetSecretsFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="6">
            <doc xml:space="preserve">caller-specific data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="save_secrets" invoker="save_secrets">
        <doc xml:space="preserve">Asynchronously ensures that all secrets inside @connection are stored to
disk.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSecretAgentOld</doc>
            <type name="SecretAgentOld" c:type="NMSecretAgentOld*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="connection_path" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback, to be invoked when the operation is done</doc>
            <type name="SecretAgentOldSaveSecretsFunc"
                  c:type="NMSecretAgentOldSaveSecretsFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="3">
            <doc xml:space="preserve">caller-specific data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="delete_secrets"
              c:identifier="nm_secret_agent_old_delete_secrets">
        <doc xml:space="preserve">Asynchronously asks the agent to delete all saved secrets belonging to
@connection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSecretAgentOld</doc>
            <type name="SecretAgentOld" c:type="NMSecretAgentOld*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback, to be invoked when the operation is done</doc>
            <type name="SecretAgentOldDeleteSecretsFunc"
                  c:type="NMSecretAgentOldDeleteSecretsFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">caller-specific data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_registered"
              c:identifier="nm_secret_agent_old_get_registered">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a %TRUE if the agent is registered, %FALSE if it is not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSecretAgentOld</doc>
            <type name="SecretAgentOld" c:type="NMSecretAgentOld*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_secrets"
              c:identifier="nm_secret_agent_old_get_secrets">
        <doc xml:space="preserve">Asynchronously retrieves secrets belonging to @connection for the
setting @setting_name.  @flags indicate specific behavior that the secret
agent should use when performing the request, for example returning only
existing secrets without user interaction, or requesting entirely new
secrets from the user.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSecretAgentOld</doc>
            <type name="SecretAgentOld" c:type="NMSecretAgentOld*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection for which we're asked secrets</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="setting_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the secret setting</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="hints" transfer-ownership="none">
            <doc xml:space="preserve">hints to the agent</doc>
            <array c:type="char**">
              <type name="utf8" c:type="char*"/>
            </array>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags that modify the behavior of the request</doc>
            <type name="SecretAgentGetSecretsFlags"
                  c:type="NMSecretAgentGetSecretsFlags"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve">a callback, to be invoked when the operation is done</doc>
            <type name="SecretAgentOldGetSecretsFunc"
                  c:type="NMSecretAgentOldGetSecretsFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">caller-specific data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="register"
              c:identifier="nm_secret_agent_old_register"
              throws="1">
        <doc xml:space="preserve">Registers the #NMSecretAgentOld with the NetworkManager secret manager,
indicating to NetworkManager that the agent is able to provide and save
secrets for connections on behalf of its user.

It is a programmer error to attempt to register an agent that is already
registered, or in the process of registering.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if registration was successful, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSecretAgentOld</doc>
            <type name="SecretAgentOld" c:type="NMSecretAgentOld*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="register_async"
              c:identifier="nm_secret_agent_old_register_async">
        <doc xml:space="preserve">Asynchronously registers the #NMSecretAgentOld with the NetworkManager secret
manager, indicating to NetworkManager that the agent is able to provide and
save secrets for connections on behalf of its user.

It is a programmer error to attempt to register an agent that is already
registered, or in the process of registering.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSecretAgentOld</doc>
            <type name="SecretAgentOld" c:type="NMSecretAgentOld*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">callback to call when the agent is registered</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="register_finish"
              c:identifier="nm_secret_agent_old_register_finish"
              throws="1">
        <doc xml:space="preserve">Gets the result of a call to nm_secret_agent_old_register_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if registration was successful, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSecretAgentOld</doc>
            <type name="SecretAgentOld" c:type="NMSecretAgentOld*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the #GAsyncReadyCallback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="save_secrets"
              c:identifier="nm_secret_agent_old_save_secrets">
        <doc xml:space="preserve">Asynchronously ensures that all secrets inside @connection are stored to
disk.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSecretAgentOld</doc>
            <type name="SecretAgentOld" c:type="NMSecretAgentOld*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback, to be invoked when the operation is done</doc>
            <type name="SecretAgentOldSaveSecretsFunc"
                  c:type="NMSecretAgentOldSaveSecretsFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">caller-specific data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unregister"
              c:identifier="nm_secret_agent_old_unregister"
              throws="1">
        <doc xml:space="preserve">Unregisters the #NMSecretAgentOld with the NetworkManager secret manager,
indicating to NetworkManager that the agent will no longer provide or
store secrets on behalf of this user.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if unregistration was successful, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSecretAgentOld</doc>
            <type name="SecretAgentOld" c:type="NMSecretAgentOld*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unregister_async"
              c:identifier="nm_secret_agent_old_unregister_async">
        <doc xml:space="preserve">Asynchronously unregisters the #NMSecretAgentOld with the NetworkManager secret
manager, indicating to NetworkManager that the agent will no longer provide
or store secrets on behalf of this user.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSecretAgentOld</doc>
            <type name="SecretAgentOld" c:type="NMSecretAgentOld*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">callback to call when the agent is unregistered</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unregister_finish"
              c:identifier="nm_secret_agent_old_unregister_finish"
              throws="1">
        <doc xml:space="preserve">Gets the result of a call to nm_secret_agent_old_unregister_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if unregistration was successful, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSecretAgentOld</doc>
            <type name="SecretAgentOld" c:type="NMSecretAgentOld*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the #GAsyncReadyCallback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="auto-register"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE (the default), the agent will always be registered when
NetworkManager is running; if NetworkManager exits and restarts, the
agent will re-register itself automatically.

In particular, if this property is %TRUE at construct time, then the
agent will register itself with NetworkManager during
construction/initialization, and initialization will fail with an error
if the agent is unable to register itself.

If the property is %FALSE, the agent will not automatically register with
NetworkManager, and nm_secret_agent_old_register() or
nm_secret_agent_old_register_async() must be called to register it.

Calling nm_secret_agent_old_unregister() will suppress auto-registration
until nm_secret_agent_old_register() is called, which re-enables
auto-registration. This ensures that the agent remains un-registered when
you expect it to be unregistered.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="capabilities"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A bitfield of %NMSecretAgentCapabilities.</doc>
        <type name="SecretAgentCapabilities"/>
      </property>
      <property name="identifier"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Identifies this agent; only one agent in each user session may use the
same identifier.  Identifier formatting follows the same rules as
D-Bus bus names with the exception that the ':' character is not
allowed.  The valid set of characters is "[A-Z][a-z][0-9]_-." and the
identifier is limited in length to 255 characters with a minimum
of 3 characters.  An example valid identifier is 'org.gnome.nm-applet'
(without quotes).</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="registered" transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the agent is registered with NetworkManager, %FALSE if not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="SecretAgentOldClass"
            c:type="NMSecretAgentOldClass"
            glib:is-gtype-struct-for="SecretAgentOld">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="get_secrets">
        <callback name="get_secrets">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #NMSecretAgentOld</doc>
              <type name="SecretAgentOld" c:type="NMSecretAgentOld*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">the #NMConnection for which we're asked secrets</doc>
              <type name="Connection" c:type="NMConnection*"/>
            </parameter>
            <parameter name="connection_path" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="setting_name" transfer-ownership="none">
              <doc xml:space="preserve">the name of the secret setting</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="hints" transfer-ownership="none">
              <doc xml:space="preserve">hints to the agent</doc>
              <array c:type="char**">
                <type name="utf8" c:type="char*"/>
              </array>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags that modify the behavior of the request</doc>
              <type name="SecretAgentGetSecretsFlags"
                    c:type="NMSecretAgentGetSecretsFlags"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="7">
              <doc xml:space="preserve">a callback, to be invoked when the operation is done</doc>
              <type name="SecretAgentOldGetSecretsFunc"
                    c:type="NMSecretAgentOldGetSecretsFunc"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="7">
              <doc xml:space="preserve">caller-specific data to be passed to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="cancel_get_secrets">
        <callback name="cancel_get_secrets">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="SecretAgentOld" c:type="NMSecretAgentOld*"/>
            </parameter>
            <parameter name="connection_path" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="setting_name" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="save_secrets">
        <callback name="save_secrets">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #NMSecretAgentOld</doc>
              <type name="SecretAgentOld" c:type="NMSecretAgentOld*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">a #NMConnection</doc>
              <type name="Connection" c:type="NMConnection*"/>
            </parameter>
            <parameter name="connection_path" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:space="preserve">a callback, to be invoked when the operation is done</doc>
              <type name="SecretAgentOldSaveSecretsFunc"
                    c:type="NMSecretAgentOldSaveSecretsFunc"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="4">
              <doc xml:space="preserve">caller-specific data to be passed to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="delete_secrets">
        <callback name="delete_secrets">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #NMSecretAgentOld</doc>
              <type name="SecretAgentOld" c:type="NMSecretAgentOld*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">a #NMConnection</doc>
              <type name="Connection" c:type="NMConnection*"/>
            </parameter>
            <parameter name="connection_path" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:space="preserve">a callback, to be invoked when the operation is done</doc>
              <type name="SecretAgentOldDeleteSecretsFunc"
                    c:type="NMSecretAgentOldDeleteSecretsFunc"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="4">
              <doc xml:space="preserve">caller-specific data to be passed to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="SecretAgentOldDeleteSecretsFunc"
              c:type="NMSecretAgentOldDeleteSecretsFunc">
      <doc xml:space="preserve">Called as a result of a request by NM to delete secrets.  When the
#NMSecretAgentOld subclass has finished deleting the secrets, this function
should be called.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="agent" transfer-ownership="none">
          <doc xml:space="preserve">the secret agent object</doc>
          <type name="SecretAgentOld" c:type="NMSecretAgentOld*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">the connection for which secrets were to be deleted,
note that this object will be unrefed after the callback has returned, use
g_object_ref()/g_object_unref() if you want to use this object after the callback
has returned</doc>
          <type name="Connection" c:type="NMConnection*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">if the deleting secrets failed, give a descriptive error here</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="3">
          <doc xml:space="preserve">caller-specific data to be passed to the function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="SecretAgentOldGetSecretsFunc"
              c:type="NMSecretAgentOldGetSecretsFunc">
      <doc xml:space="preserve">Called as a result of a request by NM to retrieve secrets.  When the
#NMSecretAgentOld subclass has finished retrieving secrets and is ready to
return them, or to return an error, this function should be called with
those secrets or the error.

To easily create the dictionary to return the Wi-Fi PSK, you could do
something like this:
&lt;example&gt;
 &lt;title&gt;Creating a secrets dictionary&lt;/title&gt;
 &lt;programlisting&gt;
  NMConnection *secrets;
  NMSettingWirelessSecurity *s_wsec;
  GVariant *secrets_dict;

  secrets = nm_simple_connection_new ();
  s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
  g_object_set (G_OBJECT (s_wsec),
                NM_SETTING_WIRELESS_SECURITY_PSK, "my really cool PSK",
                NULL);
  nm_connection_add_setting (secrets, NM_SETTING (s_wsec));
  secrets_dict = nm_connection_to_dbus (secrets, NM_CONNECTION_SERIALIZE_ALL);

  (call the NMSecretAgentOldGetSecretsFunc with secrets_dict)

  g_object_unref (secrets);
  g_variant_unref (secrets_dict);
 &lt;/programlisting&gt;
&lt;/example&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="agent" transfer-ownership="none">
          <doc xml:space="preserve">the secret agent object</doc>
          <type name="SecretAgentOld" c:type="NMSecretAgentOld*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">the connection for which secrets were requested,
note that this object will be unrefed after the callback has returned, use
g_object_ref()/g_object_unref() if you want to use this object after the callback
has returned</doc>
          <type name="Connection" c:type="NMConnection*"/>
        </parameter>
        <parameter name="secrets" transfer-ownership="none">
          <doc xml:space="preserve">the #GVariant of type %NM_VARIANT_TYPE_CONNECTION containing the requested
secrets (as created by nm_connection_to_dbus() for example).  Each key in @secrets
should be the name of a #NMSetting object (like "802-11-wireless-security")
and each value should be an %NM_VARIANT_TYPE_SETTING variant.  The sub-dicts
map string:value, where the string is the setting property name (like "psk")
and the value is the secret</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">if the secrets request failed, give a descriptive error here</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="4">
          <doc xml:space="preserve">caller-specific data to be passed to the function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="SecretAgentOldSaveSecretsFunc"
              c:type="NMSecretAgentOldSaveSecretsFunc">
      <doc xml:space="preserve">Called as a result of a request by NM to save secrets.  When the
#NMSecretAgentOld subclass has finished saving the secrets, this function
should be called.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="agent" transfer-ownership="none">
          <doc xml:space="preserve">the secret agent object</doc>
          <type name="SecretAgentOld" c:type="NMSecretAgentOld*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">the connection for which secrets were to be saved,
note that this object will be unrefed after the callback has returned, use
g_object_ref()/g_object_unref() if you want to use this object after the callback
has returned</doc>
          <type name="Connection" c:type="NMConnection*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">if the saving secrets failed, give a descriptive error here</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="3">
          <doc xml:space="preserve">caller-specific data to be passed to the function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Setting"
           c:symbol-prefix="setting"
           c:type="NMSetting"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="NMSetting"
           glib:get-type="nm_setting_get_type"
           glib:type-struct="SettingClass">
      <doc xml:space="preserve">The NMSetting struct contains only private data.
It should only be accessed through the functions described below.</doc>
      <function name="lookup_type" c:identifier="nm_setting_lookup_type">
        <doc xml:space="preserve">Returns the #GType of the setting's class for a given setting name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GType of the setting's class, or %G_TYPE_INVALID if
  @name is not recognized.</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a setting name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="clear_secrets_with_flags" introspectable="0">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none">
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" closure="2">
            <type name="SettingClearSecretsWithFlagsFn"
                  c:type="NMSettingClearSecretsWithFlagsFn"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="2">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="compare_property">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <type name="Setting" c:type="NMSetting*"/>
          </parameter>
          <parameter name="prop_spec" transfer-ownership="none">
            <type name="GObject.ParamSpec" c:type="const GParamSpec*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="SettingCompareFlags" c:type="NMSettingCompareFlags"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_secret_flags" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="secret_name" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="verify_secret" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="out_flags" transfer-ownership="none">
            <type name="SettingSecretFlags" c:type="NMSettingSecretFlags*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="need_secrets" introspectable="0">
        <return-value>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_secret_flags" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="secret_name" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="verify_secret" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="update_one_secret" throws="1">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="verify" throws="1">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="verify_secrets"
                      invoker="verify_secrets"
                      version="1.2"
                      throws="1">
        <doc xml:space="preserve">Verifies the secrets in the setting.
The returned #GError contains information about which secret of the setting
failed validation, and in what way that secret failed validation.
The secret validation is done separately from main setting validation, because
in some cases connection failure is not desired just for the secrets.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the setting secrets are valid, %FALSE if they are not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting to verify secrets in</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="connection"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the #NMConnection that @setting came from, or
  %NULL if @setting is being verified in isolation.</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="compare" c:identifier="nm_setting_compare">
        <doc xml:space="preserve">Compares two #NMSetting objects for similarity, with comparison behavior
modified by a set of flags.  See the documentation for #NMSettingCompareFlags
for a description of each flag's behavior.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the comparison succeeds, %FALSE if it does not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSetting</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a second #NMSetting to compare with the first</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">compare flags, e.g. %NM_SETTING_COMPARE_FLAG_EXACT</doc>
            <type name="SettingCompareFlags" c:type="NMSettingCompareFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="diff" c:identifier="nm_setting_diff">
        <doc xml:space="preserve">Compares two #NMSetting objects for similarity, with comparison behavior
modified by a set of flags.  See the documentation for #NMSettingCompareFlags
for a description of each flag's behavior.  If the settings differ, the keys
of each setting that differ from the other are added to @results, mapped to
one or more #NMSettingDiffResult values.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the settings contain the same values, %FALSE if they do not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSetting</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a second #NMSetting to compare with the first</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">compare flags, e.g. %NM_SETTING_COMPARE_FLAG_EXACT</doc>
            <type name="SettingCompareFlags" c:type="NMSettingCompareFlags"/>
          </parameter>
          <parameter name="invert_results" transfer-ownership="none">
            <doc xml:space="preserve">this parameter is used internally by libnm and should
be set to %FALSE.  If %TRUE inverts the meaning of the #NMSettingDiffResult.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="results"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">if the
settings differ, on return a hash table mapping the differing keys to one or
more %NMSettingDiffResult values OR-ed together.  If the settings do not
differ, any hash table passed in is unmodified.  If no hash table is passed
in and the settings differ, a new one is created and returned.</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="utf8"/>
              <type name="guint32"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="duplicate" c:identifier="nm_setting_duplicate">
        <doc xml:space="preserve">Duplicates a #NMSetting.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #NMSetting containing the same properties and values as the
source #NMSetting</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting to duplicate</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="enumerate_values"
              c:identifier="nm_setting_enumerate_values">
        <doc xml:space="preserve">Iterates over each property of the #NMSetting object, calling the supplied
user function for each property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">user-supplied function called for each property of the setting</doc>
            <type name="SettingValueIterFn" c:type="NMSettingValueIterFn"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data passed to @func at each invocation</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_dbus_property_type"
              c:identifier="nm_setting_get_dbus_property_type">
        <doc xml:space="preserve">Gets the D-Bus marshalling type of a property. @property_name is a D-Bus
property name, which may not necessarily be a #GObject property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the D-Bus marshalling type of @property on @setting.</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">an #NMSetting</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">the property of @setting to get the type of</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="nm_setting_get_name">
        <doc xml:space="preserve">Returns the type name of the #NMSetting object</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string containing the type name of the #NMSetting object,
like 'ppp' or 'wireless' or 'wired'.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_secret_flags"
              c:identifier="nm_setting_get_secret_flags"
              throws="1">
        <doc xml:space="preserve">For a given secret, retrieves the #NMSettingSecretFlags describing how to
handle that secret.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success (if the given secret name was a valid property of
this setting, and if that property is secret), %FALSE if not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="secret_name" transfer-ownership="none">
            <doc xml:space="preserve">the secret key name to get flags for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="out_flags" transfer-ownership="none">
            <doc xml:space="preserve">on success, the #NMSettingSecretFlags for the secret</doc>
            <type name="SettingSecretFlags" c:type="NMSettingSecretFlags*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_secret_flags"
              c:identifier="nm_setting_set_secret_flags"
              throws="1">
        <doc xml:space="preserve">For a given secret, stores the #NMSettingSecretFlags describing how to
handle that secret.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success (if the given secret name was a valid property of
this setting, and if that property is secret), %FALSE if not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="secret_name" transfer-ownership="none">
            <doc xml:space="preserve">the secret key name to set flags for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingSecretFlags for the secret</doc>
            <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="nm_setting_to_string">
        <doc xml:space="preserve">Convert the setting into a string.  For debugging purposes ONLY, should NOT
be used for serialization of the setting, or machine-parsed in any way. The
output format is not guaranteed to be stable and may change at any time.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an allocated string containing a textual representation of the
setting's properties and values (including secrets!), which the caller should
free with g_free()</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="verify" c:identifier="nm_setting_verify" throws="1">
        <doc xml:space="preserve">Validates the setting.  Each setting's properties have allowed values, and
some are dependent on other values (hence the need for @connection).  The
returned #GError contains information about which property of the setting
failed validation, and in what way that property failed validation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the setting is valid, %FALSE if it is not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting to verify</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="connection"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the #NMConnection that @setting came from, or
  %NULL if @setting is being verified in isolation.</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="verify_secrets"
              c:identifier="nm_setting_verify_secrets"
              version="1.2"
              throws="1">
        <doc xml:space="preserve">Verifies the secrets in the setting.
The returned #GError contains information about which secret of the setting
failed validation, and in what way that secret failed validation.
The secret validation is done separately from main setting validation, because
in some cases connection failure is not desired just for the secrets.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the setting secrets are valid, %FALSE if they are not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting to verify secrets in</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="connection"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the #NMConnection that @setting came from, or
  %NULL if @setting is being verified in isolation.</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </method>
      <property name="name" transfer-ownership="none">
        <doc xml:space="preserve">The setting's name, which uniquely identifies the setting within the
connection.  Each setting type has a name unique to that type, for
example "ppp" or "wireless" or "wired".</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <class name="Setting8021x"
           c:symbol-prefix="setting_802_1x"
           c:type="NMSetting8021x"
           parent="Setting"
           glib:type-name="NMSetting8021x"
           glib:get-type="nm_setting_802_1x_get_type"
           glib:type-struct="Setting8021xClass">
      <doc xml:space="preserve">IEEE 802.1x Authentication Settings</doc>
      <constructor name="new" c:identifier="nm_setting_802_1x_new">
        <doc xml:space="preserve">Creates a new #NMSetting8021x object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSetting8021x object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <function name="check_cert_scheme"
                c:identifier="nm_setting_802_1x_check_cert_scheme"
                version="1.2"
                throws="1">
        <doc xml:space="preserve">Determines and verifies the blob type.
When setting certificate properties of NMSetting8021x
the blob must be not UNKNOWN (or NULL).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the scheme of the blob or %NM_SETTING_802_1X_CK_SCHEME_UNKNOWN.
For NULL it also returns NM_SETTING_802_1X_CK_SCHEME_UNKNOWN.</doc>
          <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
        </return-value>
        <parameters>
          <parameter name="pdata"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the data pointer</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of the data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
      <method name="add_altsubject_match"
              c:identifier="nm_setting_802_1x_add_altsubject_match">
        <doc xml:space="preserve">Adds an allowed alternate subject name match.  Until at least one
match is added, the altSubjectName of the remote authentication
server is not verified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the alternative subject name match was
 successfully added, %FALSE if it was already allowed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="altsubject_match" transfer-ownership="none">
            <doc xml:space="preserve">the altSubjectName to allow for this connection</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_eap_method"
              c:identifier="nm_setting_802_1x_add_eap_method">
        <doc xml:space="preserve">Adds an allowed EAP method.  The setting is not valid until at least one
EAP method has been added.  See #NMSetting8021x:eap property for a list of
allowed EAP methods.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the EAP method was successfully added, %FALSE if it was
 not a valid method or if it was already allowed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="eap" transfer-ownership="none">
            <doc xml:space="preserve">the name of the EAP method to allow for this connection</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_phase2_altsubject_match"
              c:identifier="nm_setting_802_1x_add_phase2_altsubject_match">
        <doc xml:space="preserve">Adds an allowed alternate subject name match for "phase 2".  Until
at least one match is added, the altSubjectName of the "phase 2"
remote authentication server is not verified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the "phase 2" alternative subject name match was
 successfully added, %FALSE if it was already allowed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="phase2_altsubject_match" transfer-ownership="none">
            <doc xml:space="preserve">the "phase 2" altSubjectName to allow for this
connection</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_altsubject_matches"
              c:identifier="nm_setting_802_1x_clear_altsubject_matches">
        <doc xml:space="preserve">Clears all altSubjectName matches.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear_eap_methods"
              c:identifier="nm_setting_802_1x_clear_eap_methods">
        <doc xml:space="preserve">Clears all allowed EAP methods.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear_phase2_altsubject_matches"
              c:identifier="nm_setting_802_1x_clear_phase2_altsubject_matches">
        <doc xml:space="preserve">Clears all "phase 2" altSubjectName matches.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_altsubject_match"
              c:identifier="nm_setting_802_1x_get_altsubject_match">
        <doc xml:space="preserve">Returns the altSubjectName match at index @i.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the altSubjectName match at index @i</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">the zero-based index of the array of altSubjectName matches</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_anonymous_identity"
              c:identifier="nm_setting_802_1x_get_anonymous_identity">
        <doc xml:space="preserve">Returns the anonymous identifier used by some EAP methods (like TTLS) to
authenticate the user in the outer unencrypted "phase 1" authentication.  The
inner "phase 2" authentication will use the #NMSetting8021x:identity in
a secure form, if applicable for that EAP method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the anonymous identifier</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_auth_timeout"
              c:identifier="nm_setting_802_1x_get_auth_timeout"
              version="1.8">
        <doc xml:space="preserve">Returns the value contained in the #NMSetting8021x:auth-timeout property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the configured authentication timeout in seconds. Zero means the
global default value.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ca_cert_blob"
              c:identifier="nm_setting_802_1x_get_ca_cert_blob">
        <doc xml:space="preserve">Returns the CA certificate blob if the CA certificate is stored using the
%NM_SETTING_802_1X_CK_SCHEME_BLOB scheme.  Not all EAP methods use a
CA certificate (LEAP for example), and those that can take advantage of the
CA certificate allow it to be unset.  Note that lack of a CA certificate
reduces security by allowing man-in-the-middle attacks, because the identity
of the network cannot be confirmed by the client.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the CA certificate data</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ca_cert_password"
              c:identifier="nm_setting_802_1x_get_ca_cert_password"
              version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the password used to access the CA certificate stored in
#NMSetting8021x:ca-cert property. Only makes sense if the certificate
is stored on a PKCS#&lt;!-- --&gt;11 token that requires a login.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ca_cert_password_flags"
              c:identifier="nm_setting_802_1x_get_ca_cert_password_flags"
              version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the
#NMSetting8021x:ca-cert-password</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ca_cert_path"
              c:identifier="nm_setting_802_1x_get_ca_cert_path">
        <doc xml:space="preserve">Returns the CA certificate path if the CA certificate is stored using the
%NM_SETTING_802_1X_CK_SCHEME_PATH scheme.  Not all EAP methods use a
CA certificate (LEAP for example), and those that can take advantage of the
CA certificate allow it to be unset.  Note that lack of a CA certificate
reduces security by allowing man-in-the-middle attacks, because the identity
of the network cannot be confirmed by the client.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">path to the CA certificate file</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ca_cert_scheme"
              c:identifier="nm_setting_802_1x_get_ca_cert_scheme">
        <doc xml:space="preserve">Returns the scheme used to store the CA certificate.  If the returned scheme
is %NM_SETTING_802_1X_CK_SCHEME_BLOB, use nm_setting_802_1x_get_ca_cert_blob();
if %NM_SETTING_802_1X_CK_SCHEME_PATH, use nm_setting_802_1x_get_ca_cert_path();
if %NM_SETTING_802_1X_CK_SCHEME_PKCS11, use nm_setting_802_1x_get_ca_cert_uri().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">scheme used to store the CA certificate (blob or path)</doc>
          <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ca_cert_uri"
              c:identifier="nm_setting_802_1x_get_ca_cert_uri"
              version="1.6">
        <doc xml:space="preserve">Returns the CA certificate URI analogously to
nm_setting_802_1x_get_ca_cert_blob() and
nm_setting_802_1x_get_ca_cert_path().

Currently it's limited to PKCS#11 URIs ('pkcs11' scheme as defined by RFC
7512), but may be extended to other schemes in future (such as 'file' URIs
for local files and 'data' URIs for inline certificate data).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the URI string</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ca_path" c:identifier="nm_setting_802_1x_get_ca_path">
        <doc xml:space="preserve">Returns the path of the CA certificate directory if previously set.  Systems
will often have a directory that contains multiple individual CA certificates
which the supplicant can then add to the verification chain.  This may be
used in addition to the #NMSetting8021x:ca-cert property to add more CA
certificates for verifying the network to client.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the CA certificate directory path</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_client_cert_blob"
              c:identifier="nm_setting_802_1x_get_client_cert_blob">
        <doc xml:space="preserve">Client certificates are used to identify the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the client certificate data</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_client_cert_password"
              c:identifier="nm_setting_802_1x_get_client_cert_password"
              version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the password used to access the client certificate stored in
#NMSetting8021x:client-cert property. Only makes sense if the certificate
is stored on a PKCS#&lt;!-- --&gt;11 token that requires a login.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_client_cert_password_flags"
              c:identifier="nm_setting_802_1x_get_client_cert_password_flags"
              version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the
#NMSetting8021x:client-cert-password</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_client_cert_path"
              c:identifier="nm_setting_802_1x_get_client_cert_path">
        <doc xml:space="preserve">Client certificates are used to identify the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">path to the client certificate file</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_client_cert_scheme"
              c:identifier="nm_setting_802_1x_get_client_cert_scheme">
        <doc xml:space="preserve">Returns the scheme used to store the client certificate.  If the returned scheme
is %NM_SETTING_802_1X_CK_SCHEME_BLOB, use nm_setting_802_1x_get_client_cert_blob();
if %NM_SETTING_802_1X_CK_SCHEME_PATH, use nm_setting_802_1x_get_client_cert_path();
if %NM_SETTING_802_1X_CK_SCHEME_PKCS11, use nm_setting_802_1x_get_client_cert_uri().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">scheme used to store the client certificate (blob or path)</doc>
          <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_client_cert_uri"
              c:identifier="nm_setting_802_1x_get_client_cert_uri"
              version="1.6">
        <doc xml:space="preserve">Returns the client certificate URI analogously to
nm_setting_802_1x_get_client_cert_blob() and
nm_setting_802_1x_get_client_cert_path().

Currently it's limited to PKCS#11 URIs ('pkcs11' scheme as defined by RFC
7512), but may be extended to other schemes in future (such as 'file' URIs
for local files and 'data' URIs for inline certificate data).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the URI string</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_domain_suffix_match"
              c:identifier="nm_setting_802_1x_get_domain_suffix_match"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSetting8021x:domain-suffix-match property.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_eap_method"
              c:identifier="nm_setting_802_1x_get_eap_method">
        <doc xml:space="preserve">Returns the name of the allowed EAP method at index @i.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of the allowed EAP method at index @i</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">the index of the EAP method name to return</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_identity"
              c:identifier="nm_setting_802_1x_get_identity">
        <doc xml:space="preserve">Returns the identifier used by some EAP methods (like TLS) to
authenticate the user.  Often this is a username or login name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the user identifier</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_altsubject_matches"
              c:identifier="nm_setting_802_1x_get_num_altsubject_matches">
        <doc xml:space="preserve">Returns the number of entries in the
#NMSetting8021x:altsubject-matches property of this setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of altsubject-matches entries.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_eap_methods"
              c:identifier="nm_setting_802_1x_get_num_eap_methods">
        <doc xml:space="preserve">Returns the number of eap methods allowed for use when connecting to the
network.  Generally only one EAP method is used.  Use the functions
nm_setting_802_1x_get_eap_method(), nm_setting_802_1x_add_eap_method(),
and nm_setting_802_1x_remove_eap_method() for adding, removing, and retrieving
allowed EAP methods.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of allowed EAP methods</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_phase2_altsubject_matches"
              c:identifier="nm_setting_802_1x_get_num_phase2_altsubject_matches">
        <doc xml:space="preserve">Returns the number of entries in the
#NMSetting8021x:phase2-altsubject-matches property of this setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of phase2-altsubject-matches entries.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pac_file"
              c:identifier="nm_setting_802_1x_get_pac_file">
        <doc xml:space="preserve">Returns the file containing PAC credentials used by EAP-FAST method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the PAC file</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password"
              c:identifier="nm_setting_802_1x_get_password">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the password used by the authentication method, if any, as specified
  by the #NMSetting8021x:password property</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password_flags"
              c:identifier="nm_setting_802_1x_get_password_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the #NMSetting8021x:password</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password_raw"
              c:identifier="nm_setting_802_1x_get_password_raw">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the password used by the authentication method as a
UTF-8-encoded array of bytes, as specified by the
#NMSetting8021x:password-raw property</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password_raw_flags"
              c:identifier="nm_setting_802_1x_get_password_raw_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the
  #NMSetting8021x:password-raw</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase1_auth_flags"
              c:identifier="nm_setting_802_1x_get_phase1_auth_flags"
              version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the authentication flags for "phase 1".</doc>
          <type name="Setting8021xAuthFlags" c:type="NMSetting8021xAuthFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase1_fast_provisioning"
              c:identifier="nm_setting_802_1x_get_phase1_fast_provisioning">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether "phase 1" PEAP fast provisioning should be used, as specified
 by the #NMSetting8021x:phase1-fast-provisioning property.  See the
 wpa_supplicant documentation for more details.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase1_peaplabel"
              c:identifier="nm_setting_802_1x_get_phase1_peaplabel">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the "phase 1" PEAP label is new-style or old-style, to be
 used when authenticating with EAP-PEAP, as contained in the
 #NMSetting8021x:phase1-peaplabel property.  Valid values are %NULL (unset),
 "0" (use old-style label), and "1" (use new-style label).  See the
 wpa_supplicant documentation for more details.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase1_peapver"
              c:identifier="nm_setting_802_1x_get_phase1_peapver">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the "phase 1" PEAP version to be used when authenticating with
 EAP-PEAP as contained in the #NMSetting8021x:phase1-peapver property.  Valid
 values are %NULL (unset), "0" (PEAP version 0), and "1" (PEAP version 1).</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_altsubject_match"
              c:identifier="nm_setting_802_1x_get_phase2_altsubject_match">
        <doc xml:space="preserve">Returns the "phase 2" altSubjectName match at index @i.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the "phase 2" altSubjectName match at index @i</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">the zero-based index of the array of "phase 2" altSubjectName matches</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_phase2_auth"
              c:identifier="nm_setting_802_1x_get_phase2_auth">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the "phase 2" non-EAP (ex MD5) allowed authentication method as
  specified by the #NMSetting8021x:phase2-auth property.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_autheap"
              c:identifier="nm_setting_802_1x_get_phase2_autheap">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the "phase 2" EAP-based (ex TLS) allowed authentication method as
  specified by the #NMSetting8021x:phase2-autheap property.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_ca_cert_blob"
              c:identifier="nm_setting_802_1x_get_phase2_ca_cert_blob">
        <doc xml:space="preserve">Returns the "phase 2" CA certificate blob if the CA certificate is stored
using the %NM_SETTING_802_1X_CK_SCHEME_BLOB scheme.  Not all EAP methods use
a CA certificate (LEAP for example), and those that can take advantage of the
CA certificate allow it to be unset.  Note that lack of a CA certificate
reduces security by allowing man-in-the-middle attacks, because the identity
of the network cannot be confirmed by the client.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the "phase 2" CA certificate data</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_ca_cert_password"
              c:identifier="nm_setting_802_1x_get_phase2_ca_cert_password"
              version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the password used to access the "phase2" CA certificate stored in
#NMSetting8021x:phase2-ca-cert property. Only makes sense if the certificate
is stored on a PKCS#&lt;!-- --&gt;11 token that requires a login.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_ca_cert_password_flags"
              c:identifier="nm_setting_802_1x_get_phase2_ca_cert_password_flags"
              version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the
#NMSetting8021x:phase2-private-key-password</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_ca_cert_path"
              c:identifier="nm_setting_802_1x_get_phase2_ca_cert_path">
        <doc xml:space="preserve">Returns the "phase 2" CA certificate path if the CA certificate is stored
using the %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.  Not all EAP methods use
a CA certificate (LEAP for example), and those that can take advantage of the
CA certificate allow it to be unset.  Note that lack of a CA certificate
reduces security by allowing man-in-the-middle attacks, because the identity
of the network cannot be confirmed by the client.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">path to the "phase 2" CA certificate file</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_ca_cert_scheme"
              c:identifier="nm_setting_802_1x_get_phase2_ca_cert_scheme">
        <doc xml:space="preserve">Returns the scheme used to store the "phase 2" CA certificate.  If the
returned scheme is %NM_SETTING_802_1X_CK_SCHEME_BLOB, use
nm_setting_802_1x_get_ca_cert_blob(); if %NM_SETTING_802_1X_CK_SCHEME_PATH,
use nm_setting_802_1x_get_ca_cert_path(); if %NM_SETTING_802_1X_CK_SCHEME_PKCS11,
use nm_setting_802_1x_get_ca_cert_uri().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">scheme used to store the "phase 2" CA certificate (blob or path)</doc>
          <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_ca_cert_uri"
              c:identifier="nm_setting_802_1x_get_phase2_ca_cert_uri"
              version="1.6">
        <doc xml:space="preserve">Returns the "phase 2" CA certificate URI analogously to
nm_setting_802_1x_get_phase2_ca_cert_blob() and
nm_setting_802_1x_get_phase2_ca_cert_path().

Currently it's limited to PKCS#11 URIs ('pkcs11' scheme as defined by RFC
7512), but may be extended to other schemes in future (such as 'file' URIs
for local files and 'data' URIs for inline certificate data).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the URI string</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_ca_path"
              c:identifier="nm_setting_802_1x_get_phase2_ca_path">
        <doc xml:space="preserve">Returns the path of the "phase 2" CA certificate directory if previously set.
Systems will often have a directory that contains multiple individual CA
certificates which the supplicant can then add to the verification chain.
This may be used in addition to the #NMSetting8021x:phase2-ca-cert property
to add more CA certificates for verifying the network to client.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the "phase 2" CA certificate directory path</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_client_cert_blob"
              c:identifier="nm_setting_802_1x_get_phase2_client_cert_blob">
        <doc xml:space="preserve">Client certificates are used to identify the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the "phase 2" client certificate data</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_client_cert_password"
              c:identifier="nm_setting_802_1x_get_phase2_client_cert_password"
              version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the password used to access the "phase2" client certificate stored in
#NMSetting8021x:phase2-client-cert property. Only makes sense if the certificate
is stored on a PKCS#&lt;!-- --&gt;11 token that requires a login.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_client_cert_password_flags"
              c:identifier="nm_setting_802_1x_get_phase2_client_cert_password_flags"
              version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the
#NMSetting8021x:phase2-client-cert-password</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_client_cert_path"
              c:identifier="nm_setting_802_1x_get_phase2_client_cert_path">
        <doc xml:space="preserve">Client certificates are used to identify the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">path to the "phase 2" client certificate file</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_client_cert_scheme"
              c:identifier="nm_setting_802_1x_get_phase2_client_cert_scheme">
        <doc xml:space="preserve">Returns the scheme used to store the "phase 2" client certificate.  If the
returned scheme is %NM_SETTING_802_1X_CK_SCHEME_BLOB, use
nm_setting_802_1x_get_client_cert_blob(); if
%NM_SETTING_802_1X_CK_SCHEME_PATH, use
nm_setting_802_1x_get_client_cert_path(); if
%NM_SETTING_802_1X_CK_SCHEME_PKCS11, use
nm_setting_802_1x_get_client_cert_uri().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">scheme used to store the "phase 2" client certificate (blob or path)</doc>
          <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_client_cert_uri"
              c:identifier="nm_setting_802_1x_get_phase2_client_cert_uri"
              version="1.6">
        <doc xml:space="preserve">Returns the "phase 2" client certificate URI analogously to
nm_setting_802_1x_get_phase2_ca_cert_blob() and
nm_setting_802_1x_get_phase2_ca_cert_path().

Currently it's limited to PKCS#11 URIs ('pkcs11' scheme as defined by RFC
7512), but may be extended to other schemes in future (such as 'file' URIs
for local files and 'data' URIs for inline certificate data).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the URI string</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_domain_suffix_match"
              c:identifier="nm_setting_802_1x_get_phase2_domain_suffix_match"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSetting8021x:phase2-domain-suffix-match property.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_private_key_blob"
              c:identifier="nm_setting_802_1x_get_phase2_private_key_blob">
        <doc xml:space="preserve">Private keys are used to authenticate the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.

WARNING: the phase2 private key property is not a "secret" property, and thus
unencrypted private key data may be readable by unprivileged users.  Private
keys should always be encrypted with a private key password.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the "phase 2" private key data</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_private_key_format"
              c:identifier="nm_setting_802_1x_get_phase2_private_key_format">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the data format of the "phase 2" private key data stored in the
  #NMSetting8021x:phase2-private-key property</doc>
          <type name="Setting8021xCKFormat" c:type="NMSetting8021xCKFormat"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_private_key_password"
              c:identifier="nm_setting_802_1x_get_phase2_private_key_password">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the private key password used to decrypt the private key if
 previously set with nm_setting_802_1x_set_phase2_private_key() or the
 #NMSetting8021x:phase2-private-key-password property.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_private_key_password_flags"
              c:identifier="nm_setting_802_1x_get_phase2_private_key_password_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the
#NMSetting8021x:phase2-private-key-password</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_private_key_path"
              c:identifier="nm_setting_802_1x_get_phase2_private_key_path">
        <doc xml:space="preserve">Private keys are used to authenticate the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">path to the "phase 2" private key file</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_private_key_scheme"
              c:identifier="nm_setting_802_1x_get_phase2_private_key_scheme">
        <doc xml:space="preserve">Returns the scheme used to store the "phase 2" private key.  If the returned
scheme is %NM_SETTING_802_1X_CK_SCHEME_BLOB, use
nm_setting_802_1x_get_client_cert_blob(); if
%NM_SETTING_802_1X_CK_SCHEME_PATH, use
nm_setting_802_1x_get_client_cert_path(); if
%NM_SETTING_802_1X_CK_SCHEME_PKCS11, use
nm_setting_802_1x_get_client_cert_uri().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">scheme used to store the "phase 2" private key (blob or path)</doc>
          <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_private_key_uri"
              c:identifier="nm_setting_802_1x_get_phase2_private_key_uri"
              version="1.6">
        <doc xml:space="preserve">Returns the "phase 2" private key URI analogously to
nm_setting_802_1x_get_phase2_private_key_blob() and
nm_setting_802_1x_get_phase2_private_key_path().

Currently it's limited to PKCS#11 URIs ('pkcs11' scheme as defined by RFC
7512), but may be extended to other schemes in future (such as 'file' URIs
for local files and 'data' URIs for inline certificate data).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the URI string</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_subject_match"
              c:identifier="nm_setting_802_1x_get_phase2_subject_match">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSetting8021x:phase2-subject-match property. This is
the substring to be matched against the subject of the "phase 2"
authentication server certificate, or %NULL no subject verification
is to be performed.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pin" c:identifier="nm_setting_802_1x_get_pin">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the PIN used by the authentication method, if any, as specified
  by the #NMSetting8021x:pin property</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pin_flags"
              c:identifier="nm_setting_802_1x_get_pin_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the
#NMSetting8021x:pin</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_private_key_blob"
              c:identifier="nm_setting_802_1x_get_private_key_blob">
        <doc xml:space="preserve">Private keys are used to authenticate the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.

WARNING: the private key property is not a "secret" property, and thus
unencrypted private key data may be readable by unprivileged users.  Private
keys should always be encrypted with a private key password.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the private key data</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_private_key_format"
              c:identifier="nm_setting_802_1x_get_private_key_format">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the data format of the private key data stored in the
  #NMSetting8021x:private-key property</doc>
          <type name="Setting8021xCKFormat" c:type="NMSetting8021xCKFormat"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_private_key_password"
              c:identifier="nm_setting_802_1x_get_private_key_password">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the private key password used to decrypt the private key if
 previously set with nm_setting_802_1x_set_private_key(), or the
 #NMSetting8021x:private-key-password property.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_private_key_password_flags"
              c:identifier="nm_setting_802_1x_get_private_key_password_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the
#NMSetting8021x:private-key-password</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_private_key_path"
              c:identifier="nm_setting_802_1x_get_private_key_path">
        <doc xml:space="preserve">Private keys are used to authenticate the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">path to the private key file</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_private_key_scheme"
              c:identifier="nm_setting_802_1x_get_private_key_scheme">
        <doc xml:space="preserve">Returns the scheme used to store the private key.  If the returned scheme is
%NM_SETTING_802_1X_CK_SCHEME_BLOB, use
nm_setting_802_1x_get_client_cert_blob(); if
%NM_SETTING_802_1X_CK_SCHEME_PATH, use
nm_setting_802_1x_get_client_cert_path(); if
%NM_SETTING_802_1X_CK_SCHEME_PKCS11, use
nm_setting_802_1x_get_client_cert_uri().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">scheme used to store the private key (blob or path)</doc>
          <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_private_key_uri"
              c:identifier="nm_setting_802_1x_get_private_key_uri"
              version="1.6">
        <doc xml:space="preserve">Returns the private key URI analogously to
nm_setting_802_1x_get_private_key_blob() and
nm_setting_802_1x_get_private_key_path().

Currently it's limited to PKCS#11 URIs ('pkcs11' scheme as defined by RFC
7512), but may be extended to other schemes in future (such as 'file' URIs
for local files and 'data' URIs for inline certificate data).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the URI string</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_subject_match"
              c:identifier="nm_setting_802_1x_get_subject_match">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSetting8021x:subject-match property. This is the
substring to be matched against the subject of the authentication
server certificate, or %NULL no subject verification is to be
performed.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_system_ca_certs"
              c:identifier="nm_setting_802_1x_get_system_ca_certs">
        <doc xml:space="preserve">Sets the #NMSetting8021x:system-ca-certs property. The
#NMSetting8021x:ca-path and #NMSetting8021x:phase2-ca-path
properties are ignored if the #NMSetting8021x:system-ca-certs property is
%TRUE, in which case a system-wide CA certificate directory specified at
compile time (using the --system-ca-path configure option) is used in place
of these properties.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a system CA certificate path should be used, %FALSE if not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_altsubject_match"
              c:identifier="nm_setting_802_1x_remove_altsubject_match">
        <doc xml:space="preserve">Removes the allowed altSubjectName at the specified index.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">the index of the altSubjectName match to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_altsubject_match_by_value"
              c:identifier="nm_setting_802_1x_remove_altsubject_match_by_value">
        <doc xml:space="preserve">Removes the allowed altSubjectName @altsubject_match.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the alternative subject name match was found and removed,
         %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="altsubject_match" transfer-ownership="none">
            <doc xml:space="preserve">the altSubjectName to remove</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_eap_method"
              c:identifier="nm_setting_802_1x_remove_eap_method">
        <doc xml:space="preserve">Removes the allowed EAP method at the specified index.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">the index of the EAP method to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_eap_method_by_value"
              c:identifier="nm_setting_802_1x_remove_eap_method_by_value">
        <doc xml:space="preserve">Removes the allowed EAP method @method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the EAP method was founs and removed, %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="eap" transfer-ownership="none">
            <doc xml:space="preserve">the name of the EAP method to remove</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_phase2_altsubject_match"
              c:identifier="nm_setting_802_1x_remove_phase2_altsubject_match">
        <doc xml:space="preserve">Removes the allowed "phase 2" altSubjectName at the specified index.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">the index of the "phase 2" altSubjectName match to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_phase2_altsubject_match_by_value"
              c:identifier="nm_setting_802_1x_remove_phase2_altsubject_match_by_value">
        <doc xml:space="preserve">Removes the allowed "phase 2" altSubjectName @phase2_altsubject_match.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the alternative subject name match for "phase 2" was found and removed,
         %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="phase2_altsubject_match" transfer-ownership="none">
            <doc xml:space="preserve">the "phase 2" altSubjectName to remove</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ca_cert"
              c:identifier="nm_setting_802_1x_set_ca_cert"
              throws="1">
        <doc xml:space="preserve">Reads a certificate from disk and sets the #NMSetting8021x:ca-cert property
with the raw certificate data if using the %NM_SETTING_802_1X_CK_SCHEME_BLOB
scheme, or with the path to the certificate file if using the
%NM_SETTING_802_1X_CK_SCHEME_PATH scheme.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation succeeded, %FALSE if it was unsuccessful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">when @scheme is set to either %NM_SETTING_802_1X_CK_SCHEME_PATH
  or %NM_SETTING_802_1X_CK_SCHEME_BLOB, pass the path of the CA certificate
  file (PEM or DER format).  The path must be UTF-8 encoded; use
  g_filename_to_utf8() to convert if needed.  Passing %NULL with any @scheme
  clears the CA certificate.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:space="preserve">desired storage scheme for the certificate</doc>
            <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
          </parameter>
          <parameter name="out_format" transfer-ownership="none">
            <doc xml:space="preserve">on successful return, the type of the certificate added</doc>
            <type name="Setting8021xCKFormat"
                  c:type="NMSetting8021xCKFormat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_client_cert"
              c:identifier="nm_setting_802_1x_set_client_cert"
              throws="1">
        <doc xml:space="preserve">Reads a certificate from disk and sets the #NMSetting8021x:client-cert
property with the raw certificate data if using the
%NM_SETTING_802_1X_CK_SCHEME_BLOB scheme, or with the path to the certificate
file if using the %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.

Client certificates are used to identify the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation succeeded, %FALSE if it was unsuccessful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">when @scheme is set to either %NM_SETTING_802_1X_CK_SCHEME_PATH
  or %NM_SETTING_802_1X_CK_SCHEME_BLOB, pass the path of the client
  certificate file (PEM, DER, or PKCS#&lt;!-- --&gt;12 format).  The path must be UTF-8
  encoded; use g_filename_to_utf8() to convert if needed.  Passing %NULL with
  any @scheme clears the client certificate.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:space="preserve">desired storage scheme for the certificate</doc>
            <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
          </parameter>
          <parameter name="out_format" transfer-ownership="none">
            <doc xml:space="preserve">on successful return, the type of the certificate added</doc>
            <type name="Setting8021xCKFormat"
                  c:type="NMSetting8021xCKFormat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_phase2_ca_cert"
              c:identifier="nm_setting_802_1x_set_phase2_ca_cert"
              throws="1">
        <doc xml:space="preserve">Reads a certificate from disk and sets the #NMSetting8021x:phase2-ca-cert
property with the raw certificate data if using the
%NM_SETTING_802_1X_CK_SCHEME_BLOB scheme, or with the path to the certificate
file if using the %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation succeeded, %FALSE if it was unsuccessful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">when @scheme is set to either %NM_SETTING_802_1X_CK_SCHEME_PATH
  or %NM_SETTING_802_1X_CK_SCHEME_BLOB, pass the path of the "phase2" CA
  certificate file (PEM or DER format).  The path must be UTF-8 encoded; use
  g_filename_to_utf8() to convert if needed.  Passing %NULL with any @scheme
  clears the "phase2" CA certificate.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:space="preserve">desired storage scheme for the certificate</doc>
            <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
          </parameter>
          <parameter name="out_format" transfer-ownership="none">
            <doc xml:space="preserve">on successful return, the type of the certificate added</doc>
            <type name="Setting8021xCKFormat"
                  c:type="NMSetting8021xCKFormat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_phase2_client_cert"
              c:identifier="nm_setting_802_1x_set_phase2_client_cert"
              throws="1">
        <doc xml:space="preserve">Reads a certificate from disk and sets the #NMSetting8021x:phase2-client-cert
property with the raw certificate data if using the
%NM_SETTING_802_1X_CK_SCHEME_BLOB scheme, or with the path to the certificate
file if using the %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.

Client certificates are used to identify the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation succeeded, %FALSE if it was unsuccessful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">when @scheme is set to either %NM_SETTING_802_1X_CK_SCHEME_PATH
  or %NM_SETTING_802_1X_CK_SCHEME_BLOB, pass the path of the "phase2" client
  certificate file (PEM, DER, or PKCS#&lt;!-- --&gt;12 format).  The path must be UTF-8
  encoded; use g_filename_to_utf8() to convert if needed.  Passing %NULL with
  any @scheme clears the "phase2" client certificate.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:space="preserve">desired storage scheme for the certificate</doc>
            <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
          </parameter>
          <parameter name="out_format" transfer-ownership="none">
            <doc xml:space="preserve">on successful return, the type of the certificate added</doc>
            <type name="Setting8021xCKFormat"
                  c:type="NMSetting8021xCKFormat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_phase2_private_key"
              c:identifier="nm_setting_802_1x_set_phase2_private_key"
              throws="1">
        <doc xml:space="preserve">Private keys are used to authenticate the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.

This function reads a private key from disk and sets the
#NMSetting8021x:phase2-private-key property with the private key file data if
using the %NM_SETTING_802_1X_CK_SCHEME_BLOB scheme, or with the path to the
private key file if using the %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.

If @password is given, this function attempts to decrypt the private key to
verify that @password is correct, and if it is, updates the
#NMSetting8021x:phase2-private-key-password property with the given
@password.  If the decryption is unsuccessful, %FALSE is returned, @error is
set, and no internal data is changed.  If no @password is given, the private
key is assumed to be valid, no decryption is performed, and the password may
be set at a later time.

WARNING: the "phase2" private key property is not a "secret" property, and
thus unencrypted private key data using the BLOB scheme may be readable by
unprivileged users.  Private keys should always be encrypted with a private
key password to prevent unauthorized access to unencrypted private key data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation succeeded, %FALSE if it was unsuccessful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">when @scheme is set to either %NM_SETTING_802_1X_CK_SCHEME_PATH or
  %NM_SETTING_802_1X_CK_SCHEME_BLOB, pass the path of the "phase2" private
  key file (PEM, DER, or PKCS#&lt;!-- --&gt;12 format).  The path must be UTF-8 encoded;
  use g_filename_to_utf8() to convert if needed.  Passing %NULL with any
  @scheme clears the private key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">password used to decrypt the private key, or %NULL if the password
  is unknown.  If the password is given but fails to decrypt the private key,
  an error is returned.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:space="preserve">desired storage scheme for the private key</doc>
            <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
          </parameter>
          <parameter name="out_format" transfer-ownership="none">
            <doc xml:space="preserve">on successful return, the type of the private key added</doc>
            <type name="Setting8021xCKFormat"
                  c:type="NMSetting8021xCKFormat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_private_key"
              c:identifier="nm_setting_802_1x_set_private_key"
              throws="1">
        <doc xml:space="preserve">Private keys are used to authenticate the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.

This function reads a private key from disk and sets the
#NMSetting8021x:private-key property with the private key file data if using
the %NM_SETTING_802_1X_CK_SCHEME_BLOB scheme, or with the path to the private
key file if using the %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.

If @password is given, this function attempts to decrypt the private key to
verify that @password is correct, and if it is, updates the
#NMSetting8021x:private-key-password property with the given @password.  If
the decryption is unsuccessful, %FALSE is returned, @error is set, and no
internal data is changed.  If no @password is given, the private key is
assumed to be valid, no decryption is performed, and the password may be set
at a later time.

WARNING: the private key property is not a "secret" property, and thus
unencrypted private key data using the BLOB scheme may be readable by
unprivileged users.  Private keys should always be encrypted with a private
key password to prevent unauthorized access to unencrypted private key data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation succeeded, %FALSE if it was unsuccessful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">when @scheme is set to either %NM_SETTING_802_1X_CK_SCHEME_PATH or
  %NM_SETTING_802_1X_CK_SCHEME_BLOB, pass the path of the private key file
  (PEM, DER, or PKCS#&lt;!-- --&gt;12 format).  The path must be UTF-8 encoded; use
  g_filename_to_utf8() to convert if needed.  Passing %NULL with any @scheme
  clears the private key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">password used to decrypt the private key, or %NULL if the password
  is unknown.  If the password is given but fails to decrypt the private key,
  an error is returned.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:space="preserve">desired storage scheme for the private key</doc>
            <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
          </parameter>
          <parameter name="out_format" transfer-ownership="none">
            <doc xml:space="preserve">on successful return, the type of the private key added</doc>
            <type name="Setting8021xCKFormat"
                  c:type="NMSetting8021xCKFormat*"/>
          </parameter>
        </parameters>
      </method>
      <property name="altsubject-matches"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">List of strings to be matched against the altSubjectName of the
certificate presented by the authentication server. If the list is empty,
no verification of the server certificate's altSubjectName is performed.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="anonymous-identity"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Anonymous identity string for EAP authentication methods.  Used as the
unencrypted identity with EAP types that support different tunneled
identity like EAP-TTLS.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="auth-timeout"
                version="1.8"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A timeout for the authentication. Zero means the global default; if the
global default is not set, the authentication timeout is 25 seconds.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="ca-cert" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Contains the CA certificate if used by the EAP method specified in the
#NMSetting8021x:eap property.

Certificate data is specified using a "scheme"; two are currently
supported: blob and path. When using the blob scheme (which is backwards
compatible with NM 0.7.x) this property should be set to the
certificate's DER encoded data. When using the path scheme, this property
should be set to the full UTF-8 encoded path of the certificate, prefixed
with the string "file://" and ending with a terminating NUL byte. This
property can be unset even if the EAP method supports CA certificates,
but this allows man-in-the-middle attacks and is NOT recommended.

Setting this property directly is discouraged; use the
nm_setting_802_1x_set_ca_cert() function instead.</doc>
        <type name="GLib.Bytes"/>
      </property>
      <property name="ca-cert-password"
                version="1.8"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The password used to access the CA certificate stored in
#NMSetting8021x:ca-cert property. Only makes sense if the certificate
is stored on a PKCS#&lt;!-- --&gt;11 token that requires a login.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="ca-cert-password-flags"
                version="1.8"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSetting8021x:ca-cert-password property.</doc>
        <type name="SettingSecretFlags"/>
      </property>
      <property name="ca-path" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">UTF-8 encoded path to a directory containing PEM or DER formatted
certificates to be added to the verification chain in addition to the
certificate specified in the #NMSetting8021x:ca-cert property.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="client-cert" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Contains the client certificate if used by the EAP method specified in
the #NMSetting8021x:eap property.

Certificate data is specified using a "scheme"; two are currently
supported: blob and path. When using the blob scheme (which is backwards
compatible with NM 0.7.x) this property should be set to the
certificate's DER encoded data. When using the path scheme, this property
should be set to the full UTF-8 encoded path of the certificate, prefixed
with the string "file://" and ending with a terminating NUL byte.

Setting this property directly is discouraged; use the
nm_setting_802_1x_set_client_cert() function instead.</doc>
        <type name="GLib.Bytes"/>
      </property>
      <property name="client-cert-password"
                version="1.8"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The password used to access the client certificate stored in
#NMSetting8021x:client-cert property. Only makes sense if the certificate
is stored on a PKCS#&lt;!-- --&gt;11 token that requires a login.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="client-cert-password-flags"
                version="1.8"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSetting8021x:client-cert-password property.</doc>
        <type name="SettingSecretFlags"/>
      </property>
      <property name="domain-suffix-match"
                version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Constraint for server domain name. If set, this FQDN is used as a suffix
match requirement for dNSName element(s) of the certificate presented by
the authentication server.  If a matching dNSName is found, this
constraint is met.  If no dNSName values are present, this constraint is
matched against SubjectName CN using same suffix match comparison.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="eap" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The allowed EAP method to be used when authenticating to the network with
802.1x.  Valid methods are: "leap", "md5", "tls", "peap", "ttls", "pwd",
and "fast".  Each method requires different configuration using the
properties of this setting; refer to wpa_supplicant documentation for the
allowed combinations.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="identity" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Identity string for EAP authentication methods.  Often the user's user or
login name.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="pac-file" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">UTF-8 encoded file path containing PAC for EAP-FAST.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="password" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">UTF-8 encoded password used for EAP authentication methods. If both the
#NMSetting8021x:password property and the #NMSetting8021x:password-raw
property are specified, #NMSetting8021x:password is preferred.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="password-flags" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSetting8021x:password property.</doc>
        <type name="SettingSecretFlags"/>
      </property>
      <property name="password-raw" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Password used for EAP authentication methods, given as a byte array to
allow passwords in other encodings than UTF-8 to be used. If both the
#NMSetting8021x:password property and the #NMSetting8021x:password-raw
property are specified, #NMSetting8021x:password is preferred.</doc>
        <type name="GLib.Bytes"/>
      </property>
      <property name="password-raw-flags"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSetting8021x:password-raw property.</doc>
        <type name="SettingSecretFlags"/>
      </property>
      <property name="phase1-auth-flags"
                version="1.8"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Specifies authentication flags to use in "phase 1" outer
authentication using #NMSetting8021xAuthFlags options.
The invidual TLS versions can be explicitly disabled. If a certain
TLS disable flag is not set, it is up to the supplicant to allow
or forbid it. The TLS options map to tls_disable_tlsv1_x settings.
See the wpa_supplicant documentation for more details.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="phase1-fast-provisioning"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Enables or disables in-line provisioning of EAP-FAST credentials when
FAST is specified as the EAP method in the #NMSetting8021x:eap property.
Recognized values are "0" (disabled), "1" (allow unauthenticated
provisioning), "2" (allow authenticated provisioning), and "3" (allow
both authenticated and unauthenticated provisioning).  See the
wpa_supplicant documentation for more details.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="phase1-peaplabel" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Forces use of the new PEAP label during key derivation.  Some RADIUS
servers may require forcing the new PEAP label to interoperate with
PEAPv1.  Set to "1" to force use of the new PEAP label.  See the
wpa_supplicant documentation for more details.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="phase1-peapver" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Forces which PEAP version is used when PEAP is set as the EAP method in
the #NMSetting8021x:eap property.  When unset, the version reported by
the server will be used.  Sometimes when using older RADIUS servers, it
is necessary to force the client to use a particular PEAP version.  To do
so, this property may be set to "0" or "1" to force that specific PEAP
version.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="phase2-altsubject-matches"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">List of strings to be matched against the altSubjectName of the
certificate presented by the authentication server during the inner
"phase 2" authentication. If the list is empty, no verification of the
server certificate's altSubjectName is performed.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="phase2-auth" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Specifies the allowed "phase 2" inner non-EAP authentication methods when
an EAP method that uses an inner TLS tunnel is specified in the
#NMSetting8021x:eap property.  Recognized non-EAP "phase 2" methods are
"pap", "chap", "mschap", "mschapv2", "gtc", "otp", "md5", and "tls".
Each "phase 2" inner method requires specific parameters for successful
authentication; see the wpa_supplicant documentation for more details.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="phase2-autheap" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Specifies the allowed "phase 2" inner EAP-based authentication methods
when an EAP method that uses an inner TLS tunnel is specified in the
#NMSetting8021x:eap property.  Recognized EAP-based "phase 2" methods are
"md5", "mschapv2", "otp", "gtc", and "tls". Each "phase 2" inner method
requires specific parameters for successful authentication; see the
wpa_supplicant documentation for more details.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="phase2-ca-cert" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Contains the "phase 2" CA certificate if used by the EAP method specified
in the #NMSetting8021x:phase2-auth or #NMSetting8021x:phase2-autheap
properties.

Certificate data is specified using a "scheme"; two are currently
supported: blob and path. When using the blob scheme (which is backwards
compatible with NM 0.7.x) this property should be set to the
certificate's DER encoded data. When using the path scheme, this property
should be set to the full UTF-8 encoded path of the certificate, prefixed
with the string "file://" and ending with a terminating NUL byte. This
property can be unset even if the EAP method supports CA certificates,
but this allows man-in-the-middle attacks and is NOT recommended.

Setting this property directly is discouraged; use the
nm_setting_802_1x_set_phase2_ca_cert() function instead.</doc>
        <type name="GLib.Bytes"/>
      </property>
      <property name="phase2-ca-cert-password"
                version="1.8"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The password used to access the "phase2" CA certificate stored in
#NMSetting8021x:phase2-ca-cert property. Only makes sense if the certificate
is stored on a PKCS#&lt;!-- --&gt;11 token that requires a login.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="phase2-ca-cert-password-flags"
                version="1.8"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSetting8021x:phase2-ca-cert-password property.</doc>
        <type name="SettingSecretFlags"/>
      </property>
      <property name="phase2-ca-path" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">UTF-8 encoded path to a directory containing PEM or DER formatted
certificates to be added to the verification chain in addition to the
certificate specified in the #NMSetting8021x:phase2-ca-cert property.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="phase2-client-cert"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Contains the "phase 2" client certificate if used by the EAP method
specified in the #NMSetting8021x:phase2-auth or
#NMSetting8021x:phase2-autheap properties.

Certificate data is specified using a "scheme"; two are currently
supported: blob and path. When using the blob scheme (which is backwards
compatible with NM 0.7.x) this property should be set to the
certificate's DER encoded data. When using the path scheme, this property
should be set to the full UTF-8 encoded path of the certificate, prefixed
with the string "file://" and ending with a terminating NUL byte. This
property can be unset even if the EAP method supports CA certificates,
but this allows man-in-the-middle attacks and is NOT recommended.

Setting this property directly is discouraged; use the
nm_setting_802_1x_set_phase2_client_cert() function instead.</doc>
        <type name="GLib.Bytes"/>
      </property>
      <property name="phase2-client-cert-password"
                version="1.8"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The password used to access the "phase2" client certificate stored in
#NMSetting8021x:phase2-client-cert property. Only makes sense if the certificate
is stored on a PKCS#&lt;!-- --&gt;11 token that requires a login.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="phase2-client-cert-password-flags"
                version="1.8"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSetting8021x:phase2-client-cert-password property.</doc>
        <type name="SettingSecretFlags"/>
      </property>
      <property name="phase2-domain-suffix-match"
                version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Constraint for server domain name. If set, this FQDN is used as a suffix
match requirement for dNSName element(s) of the certificate presented by
the authentication server during the inner "phase 2" authentication.  If
a matching dNSName is found, this constraint is met.  If no dNSName
values are present, this constraint is matched against SubjectName CN
using same suffix match comparison.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="phase2-private-key"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Contains the "phase 2" inner private key when the
#NMSetting8021x:phase2-auth or #NMSetting8021x:phase2-autheap property is
set to "tls".

Key data is specified using a "scheme"; two are currently supported: blob
and path. When using the blob scheme and private keys, this property
should be set to the key's encrypted PEM encoded data. When using private
keys with the path scheme, this property should be set to the full UTF-8
encoded path of the key, prefixed with the string "file://" and ending
with a terminating NUL byte. When using PKCS#&lt;!-- --&gt;12 format private
keys and the blob scheme, this property should be set to the
PKCS#&lt;!-- --&gt;12 data and the #NMSetting8021x:phase2-private-key-password
property must be set to password used to decrypt the PKCS#&lt;!-- --&gt;12
certificate and key. When using PKCS#&lt;!-- --&gt;12 files and the path
scheme, this property should be set to the full UTF-8 encoded path of the
key, prefixed with the string "file://" and ending with a terminating
NUL byte, and as with the blob scheme the
#NMSetting8021x:phase2-private-key-password property must be set to the
password used to decode the PKCS#&lt;!-- --&gt;12 private key and certificate.

Setting this property directly is discouraged; use the
nm_setting_802_1x_set_phase2_private_key() function instead.</doc>
        <type name="GLib.Bytes"/>
      </property>
      <property name="phase2-private-key-password"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The password used to decrypt the "phase 2" private key specified in the
#NMSetting8021x:phase2-private-key property when the private key either
uses the path scheme, or is a PKCS#&lt;!-- --&gt;12 format key.  Setting this
property directly is not generally necessary except when returning
secrets to NetworkManager; it is generally set automatically when setting
the private key by the nm_setting_802_1x_set_phase2_private_key()
function.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="phase2-private-key-password-flags"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the
#NMSetting8021x:phase2-private-key-password property.</doc>
        <type name="SettingSecretFlags"/>
      </property>
      <property name="phase2-subject-match"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Substring to be matched against the subject of the certificate presented
by the authentication server during the inner "phase 2"
authentication. When unset, no verification of the authentication server
certificate's subject is performed.  This property provides little security,
if any, and its use is deprecated in favor of
NMSetting8021x:phase2-domain-suffix-match.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="pin" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">PIN used for EAP authentication methods.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="pin-flags" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSetting8021x:pin property.</doc>
        <type name="SettingSecretFlags"/>
      </property>
      <property name="private-key" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Contains the private key when the #NMSetting8021x:eap property is set to
"tls".

Key data is specified using a "scheme"; two are currently supported: blob
and path. When using the blob scheme and private keys, this property
should be set to the key's encrypted PEM encoded data. When using private
keys with the path scheme, this property should be set to the full UTF-8
encoded path of the key, prefixed with the string "file://" and ending
with a terminating NUL byte. When using PKCS#&lt;!-- --&gt;12 format private
keys and the blob scheme, this property should be set to the
PKCS#&lt;!-- --&gt;12 data and the #NMSetting8021x:private-key-password
property must be set to password used to decrypt the PKCS#&lt;!-- --&gt;12
certificate and key. When using PKCS#&lt;!-- --&gt;12 files and the path
scheme, this property should be set to the full UTF-8 encoded path of the
key, prefixed with the string "file://" and ending with a terminating
NUL byte, and as with the blob scheme the "private-key-password" property
must be set to the password used to decode the PKCS#&lt;!-- --&gt;12 private
key and certificate.

Setting this property directly is discouraged; use the
nm_setting_802_1x_set_private_key() function instead.

WARNING: #NMSetting8021x:private-key is not a "secret" property, and thus
unencrypted private key data using the BLOB scheme may be readable by
unprivileged users.  Private keys should always be encrypted with a
private key password to prevent unauthorized access to unencrypted
private key data.</doc>
        <type name="GLib.Bytes"/>
      </property>
      <property name="private-key-password"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The password used to decrypt the private key specified in the
#NMSetting8021x:private-key property when the private key either uses the
path scheme, or if the private key is a PKCS#&lt;!-- --&gt;12 format key.  Setting this
property directly is not generally necessary except when returning
secrets to NetworkManager; it is generally set automatically when setting
the private key by the nm_setting_802_1x_set_private_key() function.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="private-key-password-flags"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSetting8021x:private-key-password
property.</doc>
        <type name="SettingSecretFlags"/>
      </property>
      <property name="subject-match" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Substring to be matched against the subject of the certificate presented
by the authentication server. When unset, no verification of the
authentication server certificate's subject is performed.  This property
provides little security, if any, and its use is deprecated in favor of
NMSetting8021x:domain-suffix-match.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="system-ca-certs"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">When %TRUE, overrides the #NMSetting8021x:ca-path and
#NMSetting8021x:phase2-ca-path properties using the system CA directory
specified at configure time with the --system-ca-path switch.  The
certificates in this directory are added to the verification chain in
addition to any certificates specified by the #NMSetting8021x:ca-cert and
#NMSetting8021x:phase2-ca-cert properties. If the path provided with
--system-ca-path is rather a file name (bundle of trusted CA certificates),
it overrides #NMSetting8021x:ca-cert and #NMSetting8021x:phase2-ca-cert
properties instead (sets ca_cert/ca_cert2 options for wpa_supplicant).</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <bitfield name="Setting8021xAuthFlags"
              version="1.8"
              glib:type-name="NMSetting8021xAuthFlags"
              glib:get-type="nm_setting_802_1x_auth_flags_get_type"
              c:type="NMSetting8021xAuthFlags">
      <doc xml:space="preserve">#NMSetting8021xAuthFlags values indicate which authentication settings
should be used.</doc>
      <member name="none"
              value="0"
              c:identifier="NM_SETTING_802_1X_AUTH_FLAGS_NONE"
              glib:nick="none">
        <doc xml:space="preserve">No flags</doc>
      </member>
      <member name="tls_1_0_disable"
              value="1"
              c:identifier="NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_0_DISABLE"
              glib:nick="tls-1-0-disable">
        <doc xml:space="preserve">Disable TLSv1.0</doc>
      </member>
      <member name="tls_1_1_disable"
              value="2"
              c:identifier="NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_1_DISABLE"
              glib:nick="tls-1-1-disable">
        <doc xml:space="preserve">Disable TLSv1.1</doc>
      </member>
      <member name="tls_1_2_disable"
              value="4"
              c:identifier="NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_2_DISABLE"
              glib:nick="tls-1-2-disable">
        <doc xml:space="preserve">Disable TLSv1.2</doc>
      </member>
      <member name="all"
              value="7"
              c:identifier="NM_SETTING_802_1X_AUTH_FLAGS_ALL"
              glib:nick="all">
        <doc xml:space="preserve">All supported flags</doc>
      </member>
    </bitfield>
    <enumeration name="Setting8021xCKFormat"
                 glib:type-name="NMSetting8021xCKFormat"
                 glib:get-type="nm_setting_802_1x_ck_format_get_type"
                 c:type="NMSetting8021xCKFormat">
      <doc xml:space="preserve">#NMSetting8021xCKFormat values indicate the general type of a certificate
or private key</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_SETTING_802_1X_CK_FORMAT_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">unknown file format</doc>
      </member>
      <member name="x509"
              value="1"
              c:identifier="NM_SETTING_802_1X_CK_FORMAT_X509"
              glib:nick="x509">
        <doc xml:space="preserve">file contains an X.509 format certificate</doc>
      </member>
      <member name="raw_key"
              value="2"
              c:identifier="NM_SETTING_802_1X_CK_FORMAT_RAW_KEY"
              glib:nick="raw-key">
        <doc xml:space="preserve">file contains an old-style OpenSSL PEM
or DER private key</doc>
      </member>
      <member name="pkcs12"
              value="3"
              c:identifier="NM_SETTING_802_1X_CK_FORMAT_PKCS12"
              glib:nick="pkcs12">
        <doc xml:space="preserve">file contains a PKCS#&lt;!-- --&gt;12 certificate
and private key</doc>
      </member>
    </enumeration>
    <enumeration name="Setting8021xCKScheme"
                 glib:type-name="NMSetting8021xCKScheme"
                 glib:get-type="nm_setting_802_1x_ck_scheme_get_type"
                 c:type="NMSetting8021xCKScheme">
      <doc xml:space="preserve">#NMSetting8021xCKScheme values indicate how a certificate or private key is
stored in the setting properties, either as a blob of the item's data, or as
a path to a certificate or private key file on the filesystem</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_SETTING_802_1X_CK_SCHEME_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">unknown certificate or private key
scheme</doc>
      </member>
      <member name="blob"
              value="1"
              c:identifier="NM_SETTING_802_1X_CK_SCHEME_BLOB"
              glib:nick="blob">
        <doc xml:space="preserve">certificate or key is stored as the raw
item data</doc>
      </member>
      <member name="path"
              value="2"
              c:identifier="NM_SETTING_802_1X_CK_SCHEME_PATH"
              glib:nick="path">
        <doc xml:space="preserve">certificate or key is stored as a path
to a file containing the certificate or key data</doc>
      </member>
      <member name="pkcs11"
              value="3"
              c:identifier="NM_SETTING_802_1X_CK_SCHEME_PKCS11"
              glib:nick="pkcs11">
        <doc xml:space="preserve">certificate or key is stored as a
URI of an object on a PKCS#11 token</doc>
      </member>
    </enumeration>
    <record name="Setting8021xClass"
            c:type="NMSetting8021xClass"
            glib:is-gtype-struct-for="Setting8021x">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="SettingAdsl"
           c:symbol-prefix="setting_adsl"
           c:type="NMSettingAdsl"
           parent="Setting"
           glib:type-name="NMSettingAdsl"
           glib:get-type="nm_setting_adsl_get_type"
           glib:type-struct="SettingAdslClass">
      <doc xml:space="preserve">ADSL Settings</doc>
      <constructor name="new" c:identifier="nm_setting_adsl_new">
        <doc xml:space="preserve">Creates a new #NMSettingAdsl object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingAdsl object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_encapsulation"
              c:identifier="nm_setting_adsl_get_encapsulation">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingAdsl:encapsulation property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingAdsl</doc>
            <type name="SettingAdsl" c:type="NMSettingAdsl*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password" c:identifier="nm_setting_adsl_get_password">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingAdsl:password property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingAdsl</doc>
            <type name="SettingAdsl" c:type="NMSettingAdsl*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password_flags"
              c:identifier="nm_setting_adsl_get_password_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the #NMSettingAdsl:password</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingAdsl</doc>
            <type name="SettingAdsl" c:type="NMSettingAdsl*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_protocol" c:identifier="nm_setting_adsl_get_protocol">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingAdsl:protocol property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingAdsl</doc>
            <type name="SettingAdsl" c:type="NMSettingAdsl*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_username" c:identifier="nm_setting_adsl_get_username">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingAdsl:username property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingAdsl</doc>
            <type name="SettingAdsl" c:type="NMSettingAdsl*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vci" c:identifier="nm_setting_adsl_get_vci">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingAdsl:vci property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingAdsl</doc>
            <type name="SettingAdsl" c:type="NMSettingAdsl*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vpi" c:identifier="nm_setting_adsl_get_vpi">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingAdsl:vpi property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingAdsl</doc>
            <type name="SettingAdsl" c:type="NMSettingAdsl*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="encapsulation" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Encapsulation of ADSL connection.  Can be "vcmux" or "llc".</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="password" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Password used to authenticate with the ADSL service.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="password-flags" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSettingAdsl:password property.</doc>
        <type name="SettingSecretFlags"/>
      </property>
      <property name="protocol" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">ADSL connection protocol.  Can be "pppoa", "pppoe" or "ipoatm".</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="username" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Username used to authenticate with the ADSL service.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="vci" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">VCI of ADSL connection</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="vpi" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">VPI of ADSL connection</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingAdslClass"
            c:type="NMSettingAdslClass"
            glib:is-gtype-struct-for="SettingAdsl">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="SettingBluetooth"
           c:symbol-prefix="setting_bluetooth"
           c:type="NMSettingBluetooth"
           parent="Setting"
           glib:type-name="NMSettingBluetooth"
           glib:get-type="nm_setting_bluetooth_get_type"
           glib:type-struct="SettingBluetoothClass">
      <doc xml:space="preserve">Bluetooth Settings</doc>
      <constructor name="new" c:identifier="nm_setting_bluetooth_new">
        <doc xml:space="preserve">Creates a new #NMSettingBluetooth object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingBluetooth object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_bdaddr" c:identifier="nm_setting_bluetooth_get_bdaddr">
        <doc xml:space="preserve">Gets the Bluetooth address of the remote device which this setting
describes a connection to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the Bluetooth address</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBluetooth</doc>
            <type name="SettingBluetooth" c:type="NMSettingBluetooth*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_connection_type"
              c:identifier="nm_setting_bluetooth_get_connection_type">
        <doc xml:space="preserve">Returns the connection method for communicating with the remote device (i.e.
either DUN to a DUN-capable device or PANU to a NAP-capable device).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type, either %NM_SETTING_BLUETOOTH_TYPE_PANU or
%NM_SETTING_BLUETOOTH_TYPE_DUN</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBluetooth</doc>
            <type name="SettingBluetooth" c:type="NMSettingBluetooth*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="bdaddr" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The Bluetooth address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="type" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Either "dun" for Dial-Up Networking connections or "panu" for Personal
Area Networking connections to devices supporting the NAP profile.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingBluetoothClass"
            c:type="NMSettingBluetoothClass"
            glib:is-gtype-struct-for="SettingBluetooth">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="SettingBond"
           c:symbol-prefix="setting_bond"
           c:type="NMSettingBond"
           parent="Setting"
           glib:type-name="NMSettingBond"
           glib:get-type="nm_setting_bond_get_type"
           glib:type-struct="SettingBondClass">
      <doc xml:space="preserve">Bonding Settings</doc>
      <constructor name="new" c:identifier="nm_setting_bond_new">
        <doc xml:space="preserve">Creates a new #NMSettingBond object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingBond object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <function name="validate_option"
                c:identifier="nm_setting_bond_validate_option">
        <doc xml:space="preserve">Checks whether @name is a valid bond option and @value is a valid value for
the @name. If @value is %NULL, the function only validates the option name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE, if the @value is valid for the given name.
If the @name is not a valid option, %FALSE will be returned.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the option to validate</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value of the option to validate</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <method name="add_option" c:identifier="nm_setting_bond_add_option">
        <doc xml:space="preserve">Add an option to the table.  The option is compared to an internal list
of allowed options.  Option names may contain only alphanumeric characters
(ie [a-zA-Z0-9]).  Adding a new name replaces any existing name/value pair
that may already exist.

The order of how to set several options is relevant because there are options
that conflict with each other.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the option was valid and was added to the internal option
list, %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBond</doc>
            <type name="SettingBond" c:type="NMSettingBond*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name for the option</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value for the option</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_num_options"
              c:identifier="nm_setting_bond_get_num_options">
        <doc xml:space="preserve">Returns the number of options that should be set for this bond when it
is activated. This can be used to retrieve each option individually
using nm_setting_bond_get_option().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bonding options</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBond</doc>
            <type name="SettingBond" c:type="NMSettingBond*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_option" c:identifier="nm_setting_bond_get_option">
        <doc xml:space="preserve">Given an index, return the value of the bonding option at that index.  Indexes
are *not* guaranteed to be static across modifications to options done by
nm_setting_bond_add_option() and nm_setting_bond_remove_option(),
and should not be used to refer to options except for short periods of time
such as during option iteration.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success if the index was valid and an option was found,
%FALSE if the index was invalid (ie, greater than the number of options
currently held by the setting)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBond</doc>
            <type name="SettingBond" c:type="NMSettingBond*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the desired option, from 0 to
nm_setting_bond_get_num_options() - 1</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="out_name"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve">on return, the name of the bonding option;
  this value is owned by the setting and should not be modified</doc>
            <type name="utf8" c:type="const char**"/>
          </parameter>
          <parameter name="out_value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve">on return, the value of the name of the
  bonding option; this value is owned by the setting and should not be
  modified</doc>
            <type name="utf8" c:type="const char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_option_by_name"
              c:identifier="nm_setting_bond_get_option_by_name">
        <doc xml:space="preserve">Returns the value associated with the bonding option specified by
@name, if it exists.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value, or %NULL if the key/value pair was never added to the
setting; the value is owned by the setting and must not be modified</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBond</doc>
            <type name="SettingBond" c:type="NMSettingBond*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the option name for which to retrieve the value</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_option_default"
              c:identifier="nm_setting_bond_get_option_default">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the bond option if not overridden by an entry in
  the #NMSettingBond:options property.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBond</doc>
            <type name="SettingBond" c:type="NMSettingBond*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the option</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_valid_options"
              c:identifier="nm_setting_bond_get_valid_options">
        <doc xml:space="preserve">Returns a list of valid bond options.

The @setting argument is unused and may be passed as %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a %NULL-terminated array of strings of valid bond options.</doc>
          <array c:type="const char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">the #NMSettingBond</doc>
            <type name="SettingBond" c:type="NMSettingBond*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_option"
              c:identifier="nm_setting_bond_remove_option">
        <doc xml:space="preserve">Remove the bonding option referenced by @name from the internal option
list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the option was found and removed from the internal option
list, %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBond</doc>
            <type name="SettingBond" c:type="NMSettingBond*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the option to remove</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="options" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Dictionary of key/value pairs of bonding options.  Both keys and values
must be strings. Option names must contain only alphanumeric characters
(ie, [a-zA-Z0-9]).</doc>
        <type name="GLib.HashTable">
          <type name="utf8"/>
          <type name="utf8"/>
        </type>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingBondClass"
            c:type="NMSettingBondClass"
            glib:is-gtype-struct-for="SettingBond">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="SettingBridge"
           c:symbol-prefix="setting_bridge"
           c:type="NMSettingBridge"
           parent="Setting"
           glib:type-name="NMSettingBridge"
           glib:get-type="nm_setting_bridge_get_type"
           glib:type-struct="SettingBridgeClass">
      <doc xml:space="preserve">Bridging Settings</doc>
      <constructor name="new" c:identifier="nm_setting_bridge_new">
        <doc xml:space="preserve">Creates a new #NMSettingBridge object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingBridge object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_ageing_time"
              c:identifier="nm_setting_bridge_get_ageing_time">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingBridge:ageing-time property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBridge</doc>
            <type name="SettingBridge" c:type="NMSettingBridge*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_forward_delay"
              c:identifier="nm_setting_bridge_get_forward_delay">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingBridge:forward-delay property of the setting</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBridge</doc>
            <type name="SettingBridge" c:type="NMSettingBridge*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hello_time"
              c:identifier="nm_setting_bridge_get_hello_time">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingBridge:hello-time property of the setting</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBridge</doc>
            <type name="SettingBridge" c:type="NMSettingBridge*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mac_address"
              c:identifier="nm_setting_bridge_get_mac_address">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingBridge:mac-address property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBridge</doc>
            <type name="SettingBridge" c:type="NMSettingBridge*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_age" c:identifier="nm_setting_bridge_get_max_age">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingBridge:max-age property of the setting</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBridge</doc>
            <type name="SettingBridge" c:type="NMSettingBridge*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_multicast_snooping"
              c:identifier="nm_setting_bridge_get_multicast_snooping"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingBridge:multicast-snooping property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBridge</doc>
            <type name="SettingBridge" c:type="NMSettingBridge*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_priority"
              c:identifier="nm_setting_bridge_get_priority">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingBridge:priority property of the setting</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBridge</doc>
            <type name="SettingBridge" c:type="NMSettingBridge*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_stp" c:identifier="nm_setting_bridge_get_stp">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingBridge:stp property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBridge</doc>
            <type name="SettingBridge" c:type="NMSettingBridge*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="ageing-time"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The Ethernet MAC address aging time, in seconds.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="forward-delay"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The Spanning Tree Protocol (STP) forwarding delay, in seconds.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="hello-time"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The Spanning Tree Protocol (STP) hello time, in seconds.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="mac-address" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">If specified, the MAC address of bridge. When creating a new bridge, this
MAC address will be set. When matching an existing (outside
NetworkManager created) bridge, this MAC address must match.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="max-age"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The Spanning Tree Protocol (STP) maximum message age, in seconds.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="multicast-snooping"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Controls whether IGMP snooping is enabled for this bridge.
Note that if snooping was automatically disabled due to hash collisions,
the system may refuse to enable the feature until the collisions are
resolved.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="priority"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Sets the Spanning Tree Protocol (STP) priority for this bridge.  Lower
values are "better"; the lowest priority bridge will be elected the root
bridge.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="stp"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Controls whether Spanning Tree Protocol (STP) is enabled for this bridge.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingBridgeClass"
            c:type="NMSettingBridgeClass"
            glib:is-gtype-struct-for="SettingBridge">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="SettingBridgePort"
           c:symbol-prefix="setting_bridge_port"
           c:type="NMSettingBridgePort"
           parent="Setting"
           glib:type-name="NMSettingBridgePort"
           glib:get-type="nm_setting_bridge_port_get_type"
           glib:type-struct="SettingBridgePortClass">
      <doc xml:space="preserve">Bridge Port Settings</doc>
      <constructor name="new" c:identifier="nm_setting_bridge_port_new">
        <doc xml:space="preserve">Creates a new #NMSettingBridgePort object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingBridgePort object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_hairpin_mode"
              c:identifier="nm_setting_bridge_port_get_hairpin_mode">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingBridgePort:hairpin-mode property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBridgePort</doc>
            <type name="SettingBridgePort" c:type="NMSettingBridgePort*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_path_cost"
              c:identifier="nm_setting_bridge_port_get_path_cost">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingBridgePort:path-cost property of the setting</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBridgePort</doc>
            <type name="SettingBridgePort" c:type="NMSettingBridgePort*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_priority"
              c:identifier="nm_setting_bridge_port_get_priority">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingBridgePort:priority property of the setting</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBridgePort</doc>
            <type name="SettingBridgePort" c:type="NMSettingBridgePort*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="hairpin-mode" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Enables or disabled "hairpin mode" for the port, which allows frames to
be sent back out through the port the frame was received on.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="path-cost"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The Spanning Tree Protocol (STP) port cost for destinations via this
port.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="priority"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The Spanning Tree Protocol (STP) priority of this bridge port.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingBridgePortClass"
            c:type="NMSettingBridgePortClass"
            glib:is-gtype-struct-for="SettingBridgePort">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="SettingCdma"
           c:symbol-prefix="setting_cdma"
           c:type="NMSettingCdma"
           parent="Setting"
           glib:type-name="NMSettingCdma"
           glib:get-type="nm_setting_cdma_get_type"
           glib:type-struct="SettingCdmaClass">
      <doc xml:space="preserve">CDMA-based Mobile Broadband Settings</doc>
      <constructor name="new" c:identifier="nm_setting_cdma_new">
        <doc xml:space="preserve">Creates a new #NMSettingCdma object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingCdma object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_mtu"
              c:identifier="nm_setting_cdma_get_mtu"
              version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingCdma:mtu property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingCdma</doc>
            <type name="SettingCdma" c:type="NMSettingCdma*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_number" c:identifier="nm_setting_cdma_get_number">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingCdma:number property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingCdma</doc>
            <type name="SettingCdma" c:type="NMSettingCdma*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password" c:identifier="nm_setting_cdma_get_password">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingCdma:password property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingCdma</doc>
            <type name="SettingCdma" c:type="NMSettingCdma*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password_flags"
              c:identifier="nm_setting_cdma_get_password_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the #NMSettingCdma:password</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingCdma</doc>
            <type name="SettingCdma" c:type="NMSettingCdma*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_username" c:identifier="nm_setting_cdma_get_username">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingCdma:username property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingCdma</doc>
            <type name="SettingCdma" c:type="NMSettingCdma*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="mtu"
                version="1.8"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-zero, only transmit packets of the specified size or smaller,
breaking larger packets up into multiple frames.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="number" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The number to dial to establish the connection to the CDMA-based mobile
broadband network, if any.  If not specified, the default number (#777)
is used when required.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="password" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The password used to authenticate with the network, if required.  Many
providers do not require a password, or accept any password.  But if a
password is required, it is specified here.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="password-flags" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSettingCdma:password property.</doc>
        <type name="SettingSecretFlags"/>
      </property>
      <property name="username" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The username used to authenticate with the network, if required.  Many
providers do not require a username, or accept any username.  But if a
username is required, it is specified here.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingCdmaClass"
            c:type="NMSettingCdmaClass"
            glib:is-gtype-struct-for="SettingCdma">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="SettingClass"
            c:type="NMSettingClass"
            glib:is-gtype-struct-for="Setting">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="verify">
        <callback name="verify" throws="1">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="setting" transfer-ownership="none">
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="Connection" c:type="NMConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="verify_secrets">
        <callback name="verify_secrets" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the setting secrets are valid, %FALSE if they are not</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="setting" transfer-ownership="none">
              <doc xml:space="preserve">the #NMSetting to verify secrets in</doc>
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
            <parameter name="connection"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">the #NMConnection that @setting came from, or
  %NULL if @setting is being verified in isolation.</doc>
              <type name="Connection" c:type="NMConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="need_secrets" introspectable="0">
        <callback name="need_secrets" introspectable="0">
          <return-value>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="setting" transfer-ownership="none">
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="update_one_secret">
        <callback name="update_one_secret" throws="1">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="setting" transfer-ownership="none">
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
            <parameter name="key" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_secret_flags">
        <callback name="get_secret_flags" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="setting" transfer-ownership="none">
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
            <parameter name="secret_name" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="verify_secret" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="out_flags" transfer-ownership="none">
              <type name="SettingSecretFlags" c:type="NMSettingSecretFlags*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_secret_flags">
        <callback name="set_secret_flags" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="setting" transfer-ownership="none">
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
            <parameter name="secret_name" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="verify_secret" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="clear_secrets_with_flags" introspectable="0">
        <callback name="clear_secrets_with_flags" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="setting" transfer-ownership="none">
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
            <parameter name="pspec" transfer-ownership="none">
              <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
            </parameter>
            <parameter name="func" transfer-ownership="none" closure="3">
              <type name="SettingClearSecretsWithFlagsFn"
                    c:type="NMSettingClearSecretsWithFlagsFn"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="3">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="compare_property">
        <callback name="compare_property">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="setting" transfer-ownership="none">
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
            <parameter name="other" transfer-ownership="none">
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
            <parameter name="prop_spec" transfer-ownership="none">
              <type name="GObject.ParamSpec" c:type="const GParamSpec*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <type name="SettingCompareFlags" c:type="NMSettingCompareFlags"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="7">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="SettingClearSecretsWithFlagsFn"
              c:type="NMSettingClearSecretsWithFlagsFn">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE to clear the secret, %FALSE to not clear the secret</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="setting" transfer-ownership="none">
          <doc xml:space="preserve">The setting for which secrets are being iterated</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </parameter>
        <parameter name="secret" transfer-ownership="none">
          <doc xml:space="preserve">The secret's name</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">The secret's flags, eg %NM_SETTING_SECRET_FLAG_AGENT_OWNED</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="3">
          <doc xml:space="preserve">User data passed to nm_connection_clear_secrets_with_flags()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="SettingCompareFlags"
                 glib:type-name="NMSettingCompareFlags"
                 glib:get-type="nm_setting_compare_flags_get_type"
                 c:type="NMSettingCompareFlags">
      <doc xml:space="preserve">These flags modify the comparison behavior when comparing two settings or
two connections.</doc>
      <member name="exact"
              value="0"
              c:identifier="NM_SETTING_COMPARE_FLAG_EXACT"
              glib:nick="exact">
        <doc xml:space="preserve">match all properties exactly</doc>
      </member>
      <member name="fuzzy"
              value="1"
              c:identifier="NM_SETTING_COMPARE_FLAG_FUZZY"
              glib:nick="fuzzy">
        <doc xml:space="preserve">match only important attributes, like SSID,
  type, security settings, etc.  Does not match, for example, connection ID
  or UUID.</doc>
      </member>
      <member name="ignore_id"
              value="2"
              c:identifier="NM_SETTING_COMPARE_FLAG_IGNORE_ID"
              glib:nick="ignore-id">
        <doc xml:space="preserve">ignore the connection's ID</doc>
      </member>
      <member name="ignore_secrets"
              value="4"
              c:identifier="NM_SETTING_COMPARE_FLAG_IGNORE_SECRETS"
              glib:nick="ignore-secrets">
        <doc xml:space="preserve">ignore all secrets</doc>
      </member>
      <member name="ignore_agent_owned_secrets"
              value="8"
              c:identifier="NM_SETTING_COMPARE_FLAG_IGNORE_AGENT_OWNED_SECRETS"
              glib:nick="ignore-agent-owned-secrets">
        <doc xml:space="preserve">ignore secrets for which
  the secret's flags indicate the secret is owned by a user secret agent
  (ie, the secret's flag includes @NM_SETTING_SECRET_FLAG_AGENT_OWNED)</doc>
      </member>
      <member name="ignore_not_saved_secrets"
              value="16"
              c:identifier="NM_SETTING_COMPARE_FLAG_IGNORE_NOT_SAVED_SECRETS"
              glib:nick="ignore-not-saved-secrets">
        <doc xml:space="preserve">ignore secrets for which
  the secret's flags indicate the secret should not be saved to persistent
  storage (ie, the secret's flag includes @NM_SETTING_SECRET_FLAG_NOT_SAVED)</doc>
      </member>
      <member name="diff_result_with_default"
              value="32"
              c:identifier="NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT"
              glib:nick="diff-result-with-default">
        <doc xml:space="preserve">if this flag is set,
  nm_setting_diff() and nm_connection_diff() will also include properties that
  are set to their default value. See also @NM_SETTING_COMPARE_FLAG_DIFF_RESULT_NO_DEFAULT.</doc>
      </member>
      <member name="diff_result_no_default"
              value="64"
              c:identifier="NM_SETTING_COMPARE_FLAG_DIFF_RESULT_NO_DEFAULT"
              glib:nick="diff-result-no-default">
        <doc xml:space="preserve">if this flag is set,
  nm_setting_diff() and nm_connection_diff() will not include properties that
  are set to their default value. This is the opposite of
  @NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT. If both flags are set together,
  @NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT wins. If both flags are unset,
  this means to exclude default properties if there is a setting to compare,
  but include all properties, if the setting 'b' is missing. This is the legacy
  behaviour of libnm-util, where nm_setting_diff() behaved differently depending
  on whether the setting 'b' was available. If @NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT
  is set, nm_setting_diff() will also set the flags @NM_SETTING_DIFF_RESULT_IN_A_DEFAULT
  and @NM_SETTING_DIFF_RESULT_IN_B_DEFAULT, if the values are default values.</doc>
      </member>
      <member name="ignore_timestamp"
              value="128"
              c:identifier="NM_SETTING_COMPARE_FLAG_IGNORE_TIMESTAMP"
              glib:nick="ignore-timestamp">
        <doc xml:space="preserve">ignore the connection's timestamp</doc>
      </member>
    </enumeration>
    <class name="SettingConnection"
           c:symbol-prefix="setting_connection"
           c:type="NMSettingConnection"
           parent="Setting"
           glib:type-name="NMSettingConnection"
           glib:get-type="nm_setting_connection_get_type"
           glib:type-struct="SettingConnectionClass">
      <doc xml:space="preserve">General Connection Profile Settings</doc>
      <constructor name="new" c:identifier="nm_setting_connection_new">
        <doc xml:space="preserve">Creates a new #NMSettingConnection object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingConnection object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="add_permission"
              c:identifier="nm_setting_connection_add_permission">
        <doc xml:space="preserve">Adds a permission to the connection's permission list.  At this time, only
the "user" permission type is supported, and @pitem must be a username. See
#NMSettingConnection:permissions: for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the permission was unique and was successfully added to the
list, %FALSE if @ptype or @pitem was invalid or it the permission was already
present in the list</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
          <parameter name="ptype" transfer-ownership="none">
            <doc xml:space="preserve">the permission type; at this time only "user" is supported</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="pitem" transfer-ownership="none">
            <doc xml:space="preserve">the permission item formatted as required for @ptype</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="detail"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">unused at this time; must be %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_secondary"
              c:identifier="nm_setting_connection_add_secondary">
        <doc xml:space="preserve">Adds a new secondary connetion UUID to the setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the secondary connection UUID was added; %FALSE if the UUID
was already present</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
          <parameter name="sec_uuid" transfer-ownership="none">
            <doc xml:space="preserve">the secondary connection UUID to add</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_autoconnect"
              c:identifier="nm_setting_connection_get_autoconnect">
        <doc xml:space="preserve">Returns the #NMSettingConnection:autoconnect property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the connection's autoconnect behavior</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_autoconnect_priority"
              c:identifier="nm_setting_connection_get_autoconnect_priority">
        <doc xml:space="preserve">Returns the #NMSettingConnection:autoconnect-priority property of the connection.
The higher number, the higher priority.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the connection's autoconnect priority</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_autoconnect_retries"
              c:identifier="nm_setting_connection_get_autoconnect_retries"
              version="1.6">
        <doc xml:space="preserve">Returns the #NMSettingConnection:autoconnect-retries property of the connection.
Zero means infinite, -1 means the global default value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the connection's autoconnect retries</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_autoconnect_slaves"
              c:identifier="nm_setting_connection_get_autoconnect_slaves"
              version="1.2">
        <doc xml:space="preserve">Returns the #NMSettingConnection:autoconnect-slaves property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether slaves of the connection should be activated together
         with the connection.</doc>
          <type name="SettingConnectionAutoconnectSlaves"
                c:type="NMSettingConnectionAutoconnectSlaves"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_connection_type"
              c:identifier="nm_setting_connection_get_connection_type">
        <doc xml:space="preserve">Returns the #NMSettingConnection:type property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the connection type</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_gateway_ping_timeout"
              c:identifier="nm_setting_connection_get_gateway_ping_timeout">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value contained in the #NMSettingConnection:gateway-ping-timeout
property.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_id" c:identifier="nm_setting_connection_get_id">
        <doc xml:space="preserve">Returns the #NMSettingConnection:id property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the connection ID</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_interface_name"
              c:identifier="nm_setting_connection_get_interface_name">
        <doc xml:space="preserve">Returns the #NMSettingConnection:interface-name property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the connection's interface name</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_lldp"
              c:identifier="nm_setting_connection_get_lldp"
              version="1.2">
        <doc xml:space="preserve">Returns the #NMSettingConnection:lldp property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a %NMSettingConnectionLldp which indicates whether LLDP must be
enabled for the connection.</doc>
          <type name="SettingConnectionLldp" c:type="NMSettingConnectionLldp"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_master"
              c:identifier="nm_setting_connection_get_master">
        <doc xml:space="preserve">Returns the #NMSettingConnection:master property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">interface name of the master device or UUID of the master
connection.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_metered"
              c:identifier="nm_setting_connection_get_metered"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingConnection:metered property of the setting.</doc>
          <type name="Metered" c:type="NMMetered"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_permissions"
              c:identifier="nm_setting_connection_get_num_permissions">
        <doc xml:space="preserve">Returns the number of entries in the #NMSettingConnection:permissions
property of this setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of permissions entries</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_secondaries"
              c:identifier="nm_setting_connection_get_num_secondaries">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of configured secondary connection UUIDs</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_permission"
              c:identifier="nm_setting_connection_get_permission">
        <doc xml:space="preserve">Retrieve one of the entries of the #NMSettingConnection:permissions property
of this setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a permission was returned, %FALSE if @idx was invalid</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">the zero-based index of the permissions entry</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="out_ptype" transfer-ownership="none">
            <doc xml:space="preserve">on return, the permission type (at this time, always "user")</doc>
            <type name="utf8" c:type="const char**"/>
          </parameter>
          <parameter name="out_pitem" transfer-ownership="none">
            <doc xml:space="preserve">on return, the permission item (formatted accoring to @ptype, see
#NMSettingConnection:permissions for more detail</doc>
            <type name="utf8" c:type="const char**"/>
          </parameter>
          <parameter name="out_detail" transfer-ownership="none">
            <doc xml:space="preserve">on return, the permission detail (at this time, always %NULL)</doc>
            <type name="utf8" c:type="const char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_read_only"
              c:identifier="nm_setting_connection_get_read_only">
        <doc xml:space="preserve">Returns the #NMSettingConnection:read-only property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection is read-only, %FALSE if it is not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_secondary"
              c:identifier="nm_setting_connection_get_secondary">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the secondary connection UUID at index @idx</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">the zero-based index of the secondary connection UUID entry</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_slave_type"
              c:identifier="nm_setting_connection_get_slave_type">
        <doc xml:space="preserve">Returns the #NMSettingConnection:slave-type property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type of slave this connection is, if any</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_stable_id"
              c:identifier="nm_setting_connection_get_stable_id"
              version="1.4">
        <doc xml:space="preserve">Returns the #NMSettingConnection:stable_id property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the stable-id for the connection</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_timestamp"
              c:identifier="nm_setting_connection_get_timestamp">
        <doc xml:space="preserve">Returns the #NMSettingConnection:timestamp property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the connection's timestamp</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uuid" c:identifier="nm_setting_connection_get_uuid">
        <doc xml:space="preserve">Returns the #NMSettingConnection:uuid property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the connection UUID</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_zone" c:identifier="nm_setting_connection_get_zone">
        <doc xml:space="preserve">Returns the #NMSettingConnection:zone property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the trust level of a connection</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_slave_type"
              c:identifier="nm_setting_connection_is_slave_type">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if connection is of the given slave @type</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the setting name (ie #NM_SETTING_BOND_SETTING_NAME) to be matched
against @setting's slave type</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="permissions_user_allowed"
              c:identifier="nm_setting_connection_permissions_user_allowed">
        <doc xml:space="preserve">Checks whether the given username is allowed to view/access this connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the requested user is allowed to view this connection,
%FALSE if the given user is not allowed to view this connection</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
          <parameter name="uname" transfer-ownership="none">
            <doc xml:space="preserve">the user name to check permissions for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_permission"
              c:identifier="nm_setting_connection_remove_permission">
        <doc xml:space="preserve">Removes the permission at index @idx from the connection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">the zero-based index of the permission to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_permission_by_value"
              c:identifier="nm_setting_connection_remove_permission_by_value">
        <doc xml:space="preserve">Removes the permission from the connection.
At this time, only the "user" permission type is supported, and @pitem must
be a username. See #NMSettingConnection:permissions: for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the permission was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
          <parameter name="ptype" transfer-ownership="none">
            <doc xml:space="preserve">the permission type; at this time only "user" is supported</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="pitem" transfer-ownership="none">
            <doc xml:space="preserve">the permission item formatted as required for @ptype</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="detail"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">unused at this time; must be %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_secondary"
              c:identifier="nm_setting_connection_remove_secondary">
        <doc xml:space="preserve">Removes the secondary coonnection UUID at index @idx.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index number of the secondary connection UUID</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_secondary_by_value"
              c:identifier="nm_setting_connection_remove_secondary_by_value">
        <doc xml:space="preserve">Removes the secondary coonnection UUID @sec_uuid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the secondary connection UUID was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
          <parameter name="sec_uuid" transfer-ownership="none">
            <doc xml:space="preserve">the secondary connection UUID to remove</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="autoconnect"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Whether or not the connection should be automatically connected by
NetworkManager when the resources for the connection are available.
%TRUE to automatically activate the connection, %FALSE to require manual
intervention to activate the connection.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="autoconnect-priority"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The autoconnect priority. If the connection is set to autoconnect,
connections with higher priority will be preferred. Defaults to 0.
The higher number means higher priority.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="autoconnect-retries"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The number of times a connection should be tried when autoctivating before
giving up. Zero means forever, -1 means the global default (4 times if not
overridden).</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="autoconnect-slaves"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Whether or not slaves of this connection should be automatically brought up
when NetworkManager activates this connection. This only has a real effect
for master connections.
The permitted values are: 0: leave slave connections untouched,
1: activate all the slave connections with this connection, -1: default.
If -1 (default) is set, global connection.autoconnect-slaves is read to
determine the real value. If it is default as well, this fallbacks to 0.</doc>
        <type name="SettingConnectionAutoconnectSlaves"/>
      </property>
      <property name="gateway-ping-timeout"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If greater than zero, delay success of IP addressing until either the
timeout is reached, or an IP gateway replies to a ping.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="id" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">A human readable unique identifier for the connection, like "Work Wi-Fi"
or "T-Mobile 3G".</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="interface-name" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The name of the network interface this connection is bound to. If not
set, then the connection can be attached to any interface of the
appropriate type (subject to restrictions imposed by other settings).

For software devices this specifies the name of the created device.

For connection types where interface names cannot easily be made
persistent (e.g. mobile broadband or USB Ethernet), this property should
not be used. Setting this property restricts the interfaces a connection
can be used with, and if interface names change or are reordered the
connection may be applied to the wrong interface.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="lldp"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Whether LLDP is enabled for the connection.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="master" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Interface name of the master device or UUID of the master connection.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="metered"
                version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Whether the connection is metered.

When updating this property on a currently activated connection,
the change takes effect immediately.</doc>
        <type name="Metered"/>
      </property>
      <property name="permissions" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">An array of strings defining what access a given user has to this
connection.  If this is %NULL or empty, all users are allowed to access
this connection.  Otherwise a user is allowed to access this connection
if and only if they are in this list. Each entry is of the form
"[type]:[id]:[reserved]"; for example, "user:dcbw:blah".

At this time only the "user" [type] is allowed.  Any other values are
ignored and reserved for future use.  [id] is the username that this
permission refers to, which may not contain the ":" character. Any
[reserved] information present must be ignored and is reserved for future
use.  All of [type], [id], and [reserved] must be valid UTF-8.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="read-only"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">%FALSE if the connection can be modified using the provided settings
service's D-Bus interface with the right privileges, or %TRUE if the
connection is read-only and cannot be modified.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="secondaries" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">List of connection UUIDs that should be activated when the base
connection itself is activated. Currently only VPN connections are
supported.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="slave-type" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Setting name of the device type of this slave's master connection (eg,
%NM_SETTING_BOND_SETTING_NAME), or %NULL if this connection is not a
slave.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="stable-id"
                version="1.4"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Token to generate stable IDs for the connection.

The stable-id is used for generating IPv6 stable private addresses
with ipv6.addr-gen-mode=stable-privacy. It is also used to seed the
generated cloned MAC address for ethernet.cloned-mac-address=stable
and wifi.cloned-mac-address=stable. Note that also the interface name
of the activating connection and a per-host secret key is included
into the address generation so that the same stable-id on different
hosts/devices yields different addresses.

If the value is unset, an ID unique for the connection is used.
Specifing a stable-id allows multiple connections to generate the
same addresses. Another use is to generate IDs at runtime via
dynamic substitutions.

The '$' character is treated special to perform dynamic substitutions
at runtime. Currently supported are "${CONNECTION}", "${BOOT}", "${RANDOM}".
These effectively create unique IDs per-connection, per-boot, or every time.
Any unrecognized patterns following '$' are treated verbatim, however
are reserved for future use. You are thus advised to avoid '$' or
escape it as "$$".
For example, set it to "${CONNECTION}/${BOOT}" to create a unique id for
this connection that changes with every reboot.

Note that two connections only use the same effective id if
their stable-id is also identical before performing dynamic substitutions.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="timestamp"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The time, in seconds since the Unix Epoch, that the connection was last
_successfully_ fully activated.

NetworkManager updates the connection timestamp periodically when the
connection is active to ensure that an active connection has the latest
timestamp. The property is only meant for reading (changes to this
property will not be preserved).</doc>
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="type" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Base type of the connection. For hardware-dependent connections, should
contain the setting name of the hardware-type specific setting (ie,
"802-3-ethernet" or "802-11-wireless" or "bluetooth", etc), and for
non-hardware dependent connections like VPN or otherwise, should contain
the setting name of that setting type (ie, "vpn" or "bridge", etc).</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="uuid" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">A universally unique identifier for the connection, for example generated
with libuuid.  It should be assigned when the connection is created, and
never changed as long as the connection still applies to the same
network.  For example, it should not be changed when the
#NMSettingConnection:id property or #NMSettingIP4Config changes, but
might need to be re-created when the Wi-Fi SSID, mobile broadband network
provider, or #NMSettingConnection:type property changes.

The UUID must be in the format "2815492f-7e56-435e-b2e9-246bd7cdc664"
(ie, contains only hexadecimal characters and "-").  A suitable UUID may
be generated by nm_utils_uuid_generate() or
nm_utils_uuid_generate_from_string().</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="zone"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The trust level of a the connection.  Free form case-insensitive string
(for example "Home", "Work", "Public").  %NULL or unspecified zone means
the connection will be placed in the default zone as defined by the
firewall.

When updating this property on a currently activated connection,
the change takes effect immediately.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <enumeration name="SettingConnectionAutoconnectSlaves"
                 glib:type-name="NMSettingConnectionAutoconnectSlaves"
                 glib:get-type="nm_setting_connection_autoconnect_slaves_get_type"
                 c:type="NMSettingConnectionAutoconnectSlaves">
      <doc xml:space="preserve">#NMSettingConnectionAutoconnectSlaves values indicate whether slave connections
should be activated when master is activated.</doc>
      <member name="default"
              value="-1"
              c:identifier="NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_DEFAULT"
              glib:nick="default">
        <doc xml:space="preserve">default value</doc>
      </member>
      <member name="no"
              value="0"
              c:identifier="NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_NO"
              glib:nick="no">
        <doc xml:space="preserve">slaves are not brought up when
  master is activated</doc>
      </member>
      <member name="yes"
              value="1"
              c:identifier="NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_YES"
              glib:nick="yes">
        <doc xml:space="preserve">slaves are brought up when
  master is activated</doc>
      </member>
    </enumeration>
    <record name="SettingConnectionClass"
            c:type="NMSettingConnectionClass"
            glib:is-gtype-struct-for="SettingConnection">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="SettingConnectionLldp"
                 glib:type-name="NMSettingConnectionLldp"
                 glib:get-type="nm_setting_connection_lldp_get_type"
                 c:type="NMSettingConnectionLldp">
      <doc xml:space="preserve">#NMSettingConnectionLldp values indicate whether LLDP should be enabled.</doc>
      <member name="default"
              value="-1"
              c:identifier="NM_SETTING_CONNECTION_LLDP_DEFAULT"
              glib:nick="default">
        <doc xml:space="preserve">default value</doc>
      </member>
      <member name="disable"
              value="0"
              c:identifier="NM_SETTING_CONNECTION_LLDP_DISABLE"
              glib:nick="disable">
        <doc xml:space="preserve">disable LLDP</doc>
      </member>
      <member name="enable_rx"
              value="1"
              c:identifier="NM_SETTING_CONNECTION_LLDP_ENABLE_RX"
              glib:nick="enable-rx">
        <doc xml:space="preserve">enable reception of LLDP frames</doc>
      </member>
    </enumeration>
    <class name="SettingDcb"
           c:symbol-prefix="setting_dcb"
           c:type="NMSettingDcb"
           parent="Setting"
           glib:type-name="NMSettingDcb"
           glib:get-type="nm_setting_dcb_get_type"
           glib:type-struct="SettingDcbClass">
      <doc xml:space="preserve">Data Center Bridging Settings</doc>
      <constructor name="new" c:identifier="nm_setting_dcb_new">
        <doc xml:space="preserve">Creates a new #NMSettingDcb object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingDcb object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_app_fcoe_flags"
              c:identifier="nm_setting_dcb_get_app_fcoe_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingDcb:app-fcoe-flags property of the setting</doc>
          <type name="SettingDcbFlags" c:type="NMSettingDcbFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_app_fcoe_mode"
              c:identifier="nm_setting_dcb_get_app_fcoe_mode">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingDcb:app-fcoe-mode property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_app_fcoe_priority"
              c:identifier="nm_setting_dcb_get_app_fcoe_priority">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingDcb:app-fcoe-priority property of the setting</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_app_fip_flags"
              c:identifier="nm_setting_dcb_get_app_fip_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingDcb:app-fip-flags property of the setting</doc>
          <type name="SettingDcbFlags" c:type="NMSettingDcbFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_app_fip_priority"
              c:identifier="nm_setting_dcb_get_app_fip_priority">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingDcb:app-fip-priority property of the setting</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_app_iscsi_flags"
              c:identifier="nm_setting_dcb_get_app_iscsi_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingDcb:app-iscsi-flags property of the setting</doc>
          <type name="SettingDcbFlags" c:type="NMSettingDcbFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_app_iscsi_priority"
              c:identifier="nm_setting_dcb_get_app_iscsi_priority">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingDcb:app-iscsi-priority property of the setting</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_priority_bandwidth"
              c:identifier="nm_setting_dcb_get_priority_bandwidth">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the allowed bandwidth percentage of @user_priority in its priority group.
These values are only valid when #NMSettingDcb:priority-group-flags includes the
%NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
          <parameter name="user_priority" transfer-ownership="none">
            <doc xml:space="preserve">the User Priority (0 - 7) to retrieve the group bandwidth percentage for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_priority_flow_control"
              c:identifier="nm_setting_dcb_get_priority_flow_control">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if flow control is enabled for the given @user_priority,
%FALSE if not enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
          <parameter name="user_priority" transfer-ownership="none">
            <doc xml:space="preserve">the User Priority (0 - 7) to retrieve flow control for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_priority_flow_control_flags"
              c:identifier="nm_setting_dcb_get_priority_flow_control_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingDcb:priority-flow-control-flags property of the setting</doc>
          <type name="SettingDcbFlags" c:type="NMSettingDcbFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_priority_group_bandwidth"
              c:identifier="nm_setting_dcb_get_priority_group_bandwidth">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the bandwidth percentage assigned to @group_id.  These values are
only valid when #NMSettingDcb:priority-group-flags includes the
%NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
          <parameter name="group_id" transfer-ownership="none">
            <doc xml:space="preserve">the priority group (0 - 7) to retrieve the bandwidth percentage for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_priority_group_flags"
              c:identifier="nm_setting_dcb_get_priority_group_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingDcb:priority-group-flags property of the setting</doc>
          <type name="SettingDcbFlags" c:type="NMSettingDcbFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_priority_group_id"
              c:identifier="nm_setting_dcb_get_priority_group_id">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the group number @user_priority is assigned to.  These values are
only valid when #NMSettingDcb:priority-group-flags includes the
%NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
          <parameter name="user_priority" transfer-ownership="none">
            <doc xml:space="preserve">the User Priority (0 - 7) to retrieve the group ID for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_priority_strict_bandwidth"
              c:identifier="nm_setting_dcb_get_priority_strict_bandwidth">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @user_priority may use all of the bandwidth allocated to its
assigned group, or %FALSE if not. These values are only valid when
#NMSettingDcb:priority-group-flags includes the %NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
          <parameter name="user_priority" transfer-ownership="none">
            <doc xml:space="preserve">the User Priority (0 - 7) to retrieve strict bandwidth for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_priority_traffic_class"
              c:identifier="nm_setting_dcb_get_priority_traffic_class">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the traffic class assigned to @user_priority. These values are only
valid when #NMSettingDcb:priority-group-flags includes the
%NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
          <parameter name="user_priority" transfer-ownership="none">
            <doc xml:space="preserve">the User Priority (0 - 7) to retrieve the traffic class for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_priority_bandwidth"
              c:identifier="nm_setting_dcb_set_priority_bandwidth">
        <doc xml:space="preserve">These values are only valid when #NMSettingDcb:priority-group-flags includes
the %NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
          <parameter name="user_priority" transfer-ownership="none">
            <doc xml:space="preserve">the User Priority (0 - 7) to set the bandwidth percentage for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="bandwidth_percent" transfer-ownership="none">
            <doc xml:space="preserve">the bandwidth percentage (0 - 100) that @user_priority is
allowed to use within its priority group</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_priority_flow_control"
              c:identifier="nm_setting_dcb_set_priority_flow_control">
        <doc xml:space="preserve">These values are only valid when #NMSettingDcb:priority-flow-control includes
the %NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
          <parameter name="user_priority" transfer-ownership="none">
            <doc xml:space="preserve">the User Priority (0 - 7) to set flow control for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to enable flow control for this priority, %FALSE to disable it</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_priority_group_bandwidth"
              c:identifier="nm_setting_dcb_set_priority_group_bandwidth">
        <doc xml:space="preserve">These values are only valid when #NMSettingDcb:priority-group-flags includes
the %NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
          <parameter name="group_id" transfer-ownership="none">
            <doc xml:space="preserve">the priority group (0 - 7) to set the bandwidth percentage for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="bandwidth_percent" transfer-ownership="none">
            <doc xml:space="preserve">the bandwidth percentage (0 - 100) to assign to @group_id to</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_priority_group_id"
              c:identifier="nm_setting_dcb_set_priority_group_id">
        <doc xml:space="preserve">These values are only valid when #NMSettingDcb:priority-group-flags includes
the %NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
          <parameter name="user_priority" transfer-ownership="none">
            <doc xml:space="preserve">the User Priority (0 - 7) to set flow control for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="group_id" transfer-ownership="none">
            <doc xml:space="preserve">the group (0 - 7) to assign @user_priority to, or 15 for the
unrestricted group.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_priority_strict_bandwidth"
              c:identifier="nm_setting_dcb_set_priority_strict_bandwidth">
        <doc xml:space="preserve">These values are only valid when #NMSettingDcb:priority-group-flags includes
the %NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
          <parameter name="user_priority" transfer-ownership="none">
            <doc xml:space="preserve">the User Priority (0 - 7) to set strict bandwidth for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="strict" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to allow @user_priority to use all the bandwidth allocated to
its priority group, or %FALSE if not</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_priority_traffic_class"
              c:identifier="nm_setting_dcb_set_priority_traffic_class">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
          <parameter name="user_priority" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="traffic_class" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <property name="app-fcoe-flags" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Specifies the #NMSettingDcbFlags for the DCB FCoE application.  Flags may
be any combination of %NM_SETTING_DCB_FLAG_ENABLE,
%NM_SETTING_DCB_FLAG_ADVERTISE, and %NM_SETTING_DCB_FLAG_WILLING.</doc>
        <type name="SettingDcbFlags"/>
      </property>
      <property name="app-fcoe-mode"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The FCoE controller mode; either %NM_SETTING_DCB_FCOE_MODE_FABRIC
(default) or %NM_SETTING_DCB_FCOE_MODE_VN2VN.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="app-fcoe-priority"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The highest User Priority (0 - 7) which FCoE frames should use, or -1 for
default priority.  Only used when the #NMSettingDcb:app-fcoe-flags
property includes the %NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="app-fip-flags" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Specifies the #NMSettingDcbFlags for the DCB FIP application.  Flags may
be any combination of %NM_SETTING_DCB_FLAG_ENABLE,
%NM_SETTING_DCB_FLAG_ADVERTISE, and %NM_SETTING_DCB_FLAG_WILLING.</doc>
        <type name="SettingDcbFlags"/>
      </property>
      <property name="app-fip-priority"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The highest User Priority (0 - 7) which FIP frames should use, or -1 for
default priority.  Only used when the #NMSettingDcb:app-fip-flags
property includes the %NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="app-iscsi-flags" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Specifies the #NMSettingDcbFlags for the DCB iSCSI application.  Flags
may be any combination of %NM_SETTING_DCB_FLAG_ENABLE,
%NM_SETTING_DCB_FLAG_ADVERTISE, and %NM_SETTING_DCB_FLAG_WILLING.</doc>
        <type name="SettingDcbFlags"/>
      </property>
      <property name="app-iscsi-priority"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The highest User Priority (0 - 7) which iSCSI frames should use, or -1
for default priority. Only used when the #NMSettingDcb:app-iscsi-flags
property includes the %NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="priority-bandwidth"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">An array of 8 uint values, where the array index corresponds to the User
Priority (0 - 7) and the value indicates the percentage of bandwidth of
the priority's assigned group that the priority may use.  The sum of all
percentages for priorities which belong to the same group must total 100
percent.

Element-type: guint</doc>
        <array name="GLib.Array">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="priority-flow-control"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">An array of 8 boolean values, where the array index corresponds to the User
Priority (0 - 7) and the value indicates whether or not the corresponding
priority should transmit priority pause.

Element-type: gboolean</doc>
        <array name="GLib.Array">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="priority-flow-control-flags"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Specifies the #NMSettingDcbFlags for DCB Priority Flow Control (PFC).
Flags may be any combination of %NM_SETTING_DCB_FLAG_ENABLE,
%NM_SETTING_DCB_FLAG_ADVERTISE, and %NM_SETTING_DCB_FLAG_WILLING.</doc>
        <type name="SettingDcbFlags"/>
      </property>
      <property name="priority-group-bandwidth"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">An array of 8 uint values, where the array index corresponds to the
Priority Group ID (0 - 7) and the value indicates the percentage of link
bandwidth allocated to that group.  Allowed values are 0 - 100, and the
sum of all values must total 100 percent.

Element-type: guint</doc>
        <array name="GLib.Array">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="priority-group-flags"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Specifies the #NMSettingDcbFlags for DCB Priority Groups.  Flags may be
any combination of %NM_SETTING_DCB_FLAG_ENABLE,
%NM_SETTING_DCB_FLAG_ADVERTISE, and %NM_SETTING_DCB_FLAG_WILLING.</doc>
        <type name="SettingDcbFlags"/>
      </property>
      <property name="priority-group-id"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">An array of 8 uint values, where the array index corresponds to the User
Priority (0 - 7) and the value indicates the Priority Group ID.  Allowed
Priority Group ID values are 0 - 7 or 15 for the unrestricted group.

Element-type: guint</doc>
        <array name="GLib.Array">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="priority-strict-bandwidth"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">An array of 8 boolean values, where the array index corresponds to the User
Priority (0 - 7) and the value indicates whether or not the priority may
use all of the bandwidth allocated to its assigned group.

Element-type: gboolean</doc>
        <array name="GLib.Array">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="priority-traffic-class"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">An array of 8 uint values, where the array index corresponds to the User
Priority (0 - 7) and the value indicates the traffic class (0 - 7) to
which the priority is mapped.

Element-type: guint</doc>
        <array name="GLib.Array">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingDcbClass"
            c:type="NMSettingDcbClass"
            glib:is-gtype-struct-for="SettingDcb">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="SettingDcbFlags"
              glib:type-name="NMSettingDcbFlags"
              glib:get-type="nm_setting_dcb_flags_get_type"
              c:type="NMSettingDcbFlags">
      <doc xml:space="preserve">DCB feature flags.</doc>
      <member name="none"
              value="0"
              c:identifier="NM_SETTING_DCB_FLAG_NONE"
              glib:nick="none">
        <doc xml:space="preserve">no flag</doc>
      </member>
      <member name="enable"
              value="1"
              c:identifier="NM_SETTING_DCB_FLAG_ENABLE"
              glib:nick="enable">
        <doc xml:space="preserve">the feature is enabled</doc>
      </member>
      <member name="advertise"
              value="2"
              c:identifier="NM_SETTING_DCB_FLAG_ADVERTISE"
              glib:nick="advertise">
        <doc xml:space="preserve">the feature is advertised</doc>
      </member>
      <member name="willing"
              value="4"
              c:identifier="NM_SETTING_DCB_FLAG_WILLING"
              glib:nick="willing">
        <doc xml:space="preserve">the feature is willing to change based on
peer configuration advertisements</doc>
      </member>
    </bitfield>
    <enumeration name="SettingDiffResult"
                 glib:type-name="NMSettingDiffResult"
                 glib:get-type="nm_setting_diff_result_get_type"
                 c:type="NMSettingDiffResult">
      <doc xml:space="preserve">These values indicate the result of a setting difference operation.</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_SETTING_DIFF_RESULT_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">unknown result</doc>
      </member>
      <member name="in_a"
              value="1"
              c:identifier="NM_SETTING_DIFF_RESULT_IN_A"
              glib:nick="in-a">
        <doc xml:space="preserve">the property is present in setting A</doc>
      </member>
      <member name="in_b"
              value="2"
              c:identifier="NM_SETTING_DIFF_RESULT_IN_B"
              glib:nick="in-b">
        <doc xml:space="preserve">the property is present in setting B</doc>
      </member>
      <member name="in_a_default"
              value="4"
              c:identifier="NM_SETTING_DIFF_RESULT_IN_A_DEFAULT"
              glib:nick="in-a-default">
        <doc xml:space="preserve">the property is present in
setting A but is set to the default value. This flag is only set,
if you specify @NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT.</doc>
      </member>
      <member name="in_b_default"
              value="4"
              c:identifier="NM_SETTING_DIFF_RESULT_IN_B_DEFAULT"
              glib:nick="in-b-default">
        <doc xml:space="preserve">analog to @NM_SETTING_DIFF_RESULT_IN_A_DEFAULT.</doc>
      </member>
    </enumeration>
    <class name="SettingDummy"
           c:symbol-prefix="setting_dummy"
           c:type="NMSettingDummy"
           parent="Setting"
           glib:type-name="NMSettingDummy"
           glib:get-type="nm_setting_dummy_get_type"
           glib:type-struct="SettingDummyClass">
      <doc xml:space="preserve">Dummy Link Settings</doc>
      <constructor name="new"
                   c:identifier="nm_setting_dummy_new"
                   version="1.8">
        <doc xml:space="preserve">Creates a new #NMSettingDummy object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingDummy object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingDummyClass"
            c:type="NMSettingDummyClass"
            glib:is-gtype-struct-for="SettingDummy">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="SettingGeneric"
           c:symbol-prefix="setting_generic"
           c:type="NMSettingGeneric"
           parent="Setting"
           glib:type-name="NMSettingGeneric"
           glib:get-type="nm_setting_generic_get_type"
           glib:type-struct="SettingGenericClass">
      <doc xml:space="preserve">Generic Link Settings</doc>
      <constructor name="new" c:identifier="nm_setting_generic_new">
        <doc xml:space="preserve">Creates a new #NMSettingGeneric object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingGeneric object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingGenericClass"
            c:type="NMSettingGenericClass"
            glib:is-gtype-struct-for="SettingGeneric">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="SettingGsm"
           c:symbol-prefix="setting_gsm"
           c:type="NMSettingGsm"
           parent="Setting"
           glib:type-name="NMSettingGsm"
           glib:get-type="nm_setting_gsm_get_type"
           glib:type-struct="SettingGsmClass">
      <doc xml:space="preserve">GSM-based Mobile Broadband Settings</doc>
      <constructor name="new" c:identifier="nm_setting_gsm_new">
        <doc xml:space="preserve">Creates a new #NMSettingGsm object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingGsm object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_apn" c:identifier="nm_setting_gsm_get_apn">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingGsm:apn property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingGsm</doc>
            <type name="SettingGsm" c:type="NMSettingGsm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_device_id"
              c:identifier="nm_setting_gsm_get_device_id"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingGsm:device-id property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingGsm</doc>
            <type name="SettingGsm" c:type="NMSettingGsm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_home_only" c:identifier="nm_setting_gsm_get_home_only">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingGsm:home-only property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingGsm</doc>
            <type name="SettingGsm" c:type="NMSettingGsm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mtu"
              c:identifier="nm_setting_gsm_get_mtu"
              version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingGsm:mtu property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingGsm</doc>
            <type name="SettingGsm" c:type="NMSettingGsm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_network_id"
              c:identifier="nm_setting_gsm_get_network_id">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingGsm:network-id property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingGsm</doc>
            <type name="SettingGsm" c:type="NMSettingGsm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_number" c:identifier="nm_setting_gsm_get_number">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingGsm:number property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingGsm</doc>
            <type name="SettingGsm" c:type="NMSettingGsm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password" c:identifier="nm_setting_gsm_get_password">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingGsm:password property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingGsm</doc>
            <type name="SettingGsm" c:type="NMSettingGsm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password_flags"
              c:identifier="nm_setting_gsm_get_password_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the #NMSettingGsm:password</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingGsm</doc>
            <type name="SettingGsm" c:type="NMSettingGsm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pin" c:identifier="nm_setting_gsm_get_pin">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingGsm:pin property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingGsm</doc>
            <type name="SettingGsm" c:type="NMSettingGsm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pin_flags" c:identifier="nm_setting_gsm_get_pin_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the #NMSettingGsm:pin</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingGsm</doc>
            <type name="SettingGsm" c:type="NMSettingGsm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sim_id"
              c:identifier="nm_setting_gsm_get_sim_id"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingGsm:sim-id property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingGsm</doc>
            <type name="SettingGsm" c:type="NMSettingGsm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sim_operator_id"
              c:identifier="nm_setting_gsm_get_sim_operator_id"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingGsm:sim-operator-id property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingGsm</doc>
            <type name="SettingGsm" c:type="NMSettingGsm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_username" c:identifier="nm_setting_gsm_get_username">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingGsm:username property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingGsm</doc>
            <type name="SettingGsm" c:type="NMSettingGsm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="apn" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The GPRS Access Point Name specifying the APN used when establishing a
data session with the GSM-based network.  The APN often determines how
the user will be billed for their network usage and whether the user has
access to the Internet or just a provider-specific walled-garden, so it
is important to use the correct APN for the user's mobile broadband plan.
The APN may only be composed of the characters a-z, 0-9, ., and - per GSM
03.60 Section 14.9.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="device-id"
                version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The device unique identifier (as given by the WWAN management service)
which this connection applies to.  If given, the connection will only
apply to the specified device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="home-only" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">When %TRUE, only connections to the home network will be allowed.
Connections to roaming networks will not be made.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="mtu"
                version="1.8"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-zero, only transmit packets of the specified size or smaller,
breaking larger packets up into multiple frames.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="network-id" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The Network ID (GSM LAI format, ie MCC-MNC) to force specific network
registration.  If the Network ID is specified, NetworkManager will
attempt to force the device to register only on the specified network.
This can be used to ensure that the device does not roam when direct
roaming control of the device is not otherwise possible.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="number" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Number to dial when establishing a PPP data session with the GSM-based
mobile broadband network.  Many modems do not require PPP for connections
to the mobile network and thus this property should be left blank, which
allows NetworkManager to select the appropriate settings automatically.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="password" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The password used to authenticate with the network, if required.  Many
providers do not require a password, or accept any password.  But if a
password is required, it is specified here.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="password-flags" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSettingGsm:password property.</doc>
        <type name="SettingSecretFlags"/>
      </property>
      <property name="pin" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">If the SIM is locked with a PIN it must be unlocked before any other
operations are requested.  Specify the PIN here to allow operation of the
device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="pin-flags" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSettingGsm:pin property.</doc>
        <type name="SettingSecretFlags"/>
      </property>
      <property name="sim-id"
                version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The SIM card unique identifier (as given by the WWAN management service)
which this connection applies to.  If given, the connection will apply
to any device also allowed by #NMSettingGsm:device-id which contains a
SIM card matching the given identifier.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="sim-operator-id"
                version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A MCC/MNC string like "310260" or "21601" identifying the specific
mobile network operator which this connection applies to.  If given,
the connection will apply to any device also allowed by
#NMSettingGsm:device-id and #NMSettingGsm:sim-id which contains a SIM
card provisioined by the given operator.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="username" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The username used to authenticate with the network, if required.  Many
providers do not require a username, or accept any username.  But if a
username is required, it is specified here.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingGsmClass"
            c:type="NMSettingGsmClass"
            glib:is-gtype-struct-for="SettingGsm">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="SettingIP4Config"
           c:symbol-prefix="setting_ip4_config"
           c:type="NMSettingIP4Config"
           parent="SettingIPConfig"
           glib:type-name="NMSettingIP4Config"
           glib:get-type="nm_setting_ip4_config_get_type"
           glib:type-struct="SettingIP4ConfigClass">
      <doc xml:space="preserve">IPv4 Settings</doc>
      <constructor name="new" c:identifier="nm_setting_ip4_config_new">
        <doc xml:space="preserve">Creates a new #NMSettingIP4Config object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingIP4Config object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_dhcp_client_id"
              c:identifier="nm_setting_ip4_config_get_dhcp_client_id">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIP4Config:dhcp-client-id
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the configured Client ID to send to the DHCP server when requesting
addresses via DHCP.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dhcp_fqdn"
              c:identifier="nm_setting_ip4_config_get_dhcp_fqdn"
              version="1.2">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIP4Config:dhcp-fqdn
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the configured FQDN to send to the DHCP server</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="dhcp-client-id" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">A string sent to the DHCP server to identify the local machine which the
DHCP server may use to customize the DHCP lease and options.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="dhcp-fqdn"
                version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If the #NMSettingIPConfig:dhcp-send-hostname property is %TRUE, then the
specified FQDN will be sent to the DHCP server when acquiring a lease. This
property and #NMSettingIPConfig:dhcp-hostname are mutually exclusive and
cannot be set at the same time.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="SettingIPConfig" c:type="NMSettingIPConfig"/>
      </field>
    </class>
    <record name="SettingIP4ConfigClass"
            c:type="NMSettingIP4ConfigClass"
            glib:is-gtype-struct-for="SettingIP4Config">
      <field name="parent">
        <type name="SettingIPConfigClass" c:type="NMSettingIPConfigClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="SettingIP6Config"
           c:symbol-prefix="setting_ip6_config"
           c:type="NMSettingIP6Config"
           parent="SettingIPConfig"
           glib:type-name="NMSettingIP6Config"
           glib:get-type="nm_setting_ip6_config_get_type"
           glib:type-struct="SettingIP6ConfigClass">
      <doc xml:space="preserve">IPv6 Settings</doc>
      <constructor name="new" c:identifier="nm_setting_ip6_config_new">
        <doc xml:space="preserve">Creates a new #NMSettingIP6Config object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingIP6Config object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_addr_gen_mode"
              c:identifier="nm_setting_ip6_config_get_addr_gen_mode"
              version="1.2">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIP6Config:addr-gen-mode
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">IPv6 Address Generation Mode.</doc>
          <type name="SettingIP6ConfigAddrGenMode"
                c:type="NMSettingIP6ConfigAddrGenMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ip6_privacy"
              c:identifier="nm_setting_ip6_config_get_ip6_privacy">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIP6Config:ip6-privacy
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">IPv6 Privacy Extensions configuration value (#NMSettingIP6ConfigPrivacy).</doc>
          <type name="SettingIP6ConfigPrivacy"
                c:type="NMSettingIP6ConfigPrivacy"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_token"
              c:identifier="nm_setting_ip6_config_get_token"
              version="1.4">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIP6Config:token
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A string.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="addr-gen-mode"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Configure method for creating the address for use with RFC4862 IPv6
Stateless Address Autoconfiguration. The permitted values are: "eui64",
or "stable-privacy".

If the property is set to "eui64", the addresses will be generated
using the interface tokens derived from  hardware address. This makes
the host part of the address to stay constant, making it possible
to track host's presence when it changes networks. The address changes
when the interface hardware is replaced.

The value of "stable-privacy" enables use of cryptographically
secure hash of a secret host-specific key along with the connection's
stable-id and the network address as specified by RFC7217.
This makes it impossible to use the address track host's presence,
and makes the address stable when the network interface hardware is
replaced.

On D-Bus, the absence of an addr-gen-mode setting equals enabling
"stable-privacy". For keyfile plugin, the absence of the setting
on disk means "eui64" so that the property doesn't change on upgrade
from older versions.

Note that this setting is distinct from the Privacy Extensions as
configured by "ip6-privacy" property and it does not affect the
temporary addresses configured with this option.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="ip6-privacy"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Configure IPv6 Privacy Extensions for SLAAC, described in RFC4941.  If
enabled, it makes the kernel generate a temporary IPv6 address in
addition to the public one generated from MAC address via modified
EUI-64.  This enhances privacy, but could cause problems in some
applications, on the other hand.  The permitted values are: -1: unknown,
0: disabled, 1: enabled (prefer public address), 2: enabled (prefer temporary
addresses).

Having a per-connection setting set to "-1" (unknown) means fallback to
global configuration "ipv6.ip6-privacy".

If also global configuration is unspecified or set to "-1", fallback to read
"/proc/sys/net/ipv6/conf/default/use_tempaddr".

Note that this setting is distinct from the Stable Privacy addresses
that can be enabled with the "addr-gen-mode" property's "stable-privacy"
setting as another way of avoiding host tracking with IPv6 addresses.</doc>
        <type name="SettingIP6ConfigPrivacy"/>
      </property>
      <property name="token"
                version="1.4"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Configure the token for draft-chown-6man-tokenised-ipv6-identifiers-02
IPv6 tokenized interface identifiers. Useful with eui64 addr-gen-mode.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="SettingIPConfig" c:type="NMSettingIPConfig"/>
      </field>
    </class>
    <enumeration name="SettingIP6ConfigAddrGenMode"
                 version="1.2"
                 glib:type-name="NMSettingIP6ConfigAddrGenMode"
                 glib:get-type="nm_setting_ip6_config_addr_gen_mode_get_type"
                 c:type="NMSettingIP6ConfigAddrGenMode">
      <doc xml:space="preserve">#NMSettingIP6ConfigAddrGenMode controls how the Interface Identifier for
RFC4862 Stateless Address Autoconfiguration is created.</doc>
      <member name="eui64"
              value="0"
              c:identifier="NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64"
              glib:nick="eui64">
        <doc xml:space="preserve">The Interface Identifier is derived
from the interface hardware address.</doc>
      </member>
      <member name="stable_privacy"
              value="1"
              c:identifier="NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY"
              glib:nick="stable-privacy">
        <doc xml:space="preserve">The Interface Identifier
is created by using a cryptographically secure hash of a secret host-specific
key along with the connection identification and the network address as
specified by RFC7217.</doc>
      </member>
    </enumeration>
    <record name="SettingIP6ConfigClass"
            c:type="NMSettingIP6ConfigClass"
            glib:is-gtype-struct-for="SettingIP6Config">
      <field name="parent">
        <type name="SettingIPConfigClass" c:type="NMSettingIPConfigClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="SettingIP6ConfigPrivacy"
                 glib:type-name="NMSettingIP6ConfigPrivacy"
                 glib:get-type="nm_setting_ip6_config_privacy_get_type"
                 c:type="NMSettingIP6ConfigPrivacy">
      <doc xml:space="preserve">#NMSettingIP6ConfigPrivacy values indicate if and how IPv6 Privacy
Extensions are used (RFC4941).</doc>
      <member name="unknown"
              value="-1"
              c:identifier="NM_SETTING_IP6_CONFIG_PRIVACY_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">unknown or no value specified</doc>
      </member>
      <member name="disabled"
              value="0"
              c:identifier="NM_SETTING_IP6_CONFIG_PRIVACY_DISABLED"
              glib:nick="disabled">
        <doc xml:space="preserve">IPv6 Privacy Extensions are disabled</doc>
      </member>
      <member name="prefer_public_addr"
              value="1"
              c:identifier="NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_PUBLIC_ADDR"
              glib:nick="prefer-public-addr">
        <doc xml:space="preserve">IPv6 Privacy Extensions
are enabled, but public addresses are preferred over temporary addresses</doc>
      </member>
      <member name="prefer_temp_addr"
              value="2"
              c:identifier="NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_TEMP_ADDR"
              glib:nick="prefer-temp-addr">
        <doc xml:space="preserve">IPv6 Privacy Extensions
are enabled and temporary addresses are preferred over public addresses</doc>
      </member>
    </enumeration>
    <class name="SettingIPConfig"
           c:symbol-prefix="setting_ip_config"
           c:type="NMSettingIPConfig"
           parent="Setting"
           abstract="1"
           glib:type-name="NMSettingIPConfig"
           glib:get-type="nm_setting_ip_config_get_type"
           glib:type-struct="SettingIPConfigClass">
      <method name="add_address"
              c:identifier="nm_setting_ip_config_add_address">
        <doc xml:space="preserve">Adds a new IP address and associated information to the setting.  The
given address is duplicated internally and is not changed by this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the address was added; %FALSE if the address was already
known.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the new address to add</doc>
            <type name="IPAddress" c:type="NMIPAddress*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_dns" c:identifier="nm_setting_ip_config_add_dns">
        <doc xml:space="preserve">Adds a new DNS server to the setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the DNS server was added; %FALSE if the server was already
known</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
          <parameter name="dns" transfer-ownership="none">
            <doc xml:space="preserve">the IP address of the DNS server to add</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_dns_option"
              c:identifier="nm_setting_ip_config_add_dns_option"
              version="1.2">
        <doc xml:space="preserve">Adds a new DNS option to the setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the DNS option was added; %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
          <parameter name="dns_option" transfer-ownership="none">
            <doc xml:space="preserve">the DNS option to add</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_dns_search"
              c:identifier="nm_setting_ip_config_add_dns_search">
        <doc xml:space="preserve">Adds a new DNS search domain to the setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the DNS search domain was added; %FALSE if the search
domain was already known</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
          <parameter name="dns_search" transfer-ownership="none">
            <doc xml:space="preserve">the search domain to add</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_route" c:identifier="nm_setting_ip_config_add_route">
        <doc xml:space="preserve">Adds a new route and associated information to the setting.  The
given route is duplicated internally and is not changed by this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the route was added; %FALSE if the route was already known.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
          <parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the route to add</doc>
            <type name="IPRoute" c:type="NMIPRoute*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_addresses"
              c:identifier="nm_setting_ip_config_clear_addresses">
        <doc xml:space="preserve">Removes all configured addresses.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear_dns" c:identifier="nm_setting_ip_config_clear_dns">
        <doc xml:space="preserve">Removes all configured DNS servers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear_dns_options"
              c:identifier="nm_setting_ip_config_clear_dns_options"
              version="1.2">
        <doc xml:space="preserve">Removes all configured DNS options.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
          <parameter name="is_set" transfer-ownership="none">
            <doc xml:space="preserve">the dns-options can be either empty or unset (default).
  Specify how to clear the options.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_dns_searches"
              c:identifier="nm_setting_ip_config_clear_dns_searches">
        <doc xml:space="preserve">Removes all configured DNS search domains.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear_routes"
              c:identifier="nm_setting_ip_config_clear_routes">
        <doc xml:space="preserve">Removes all configured routes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_address"
              c:identifier="nm_setting_ip_config_get_address">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the address at index @idx</doc>
          <type name="IPAddress" c:type="NMIPAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index number of the address to return</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_dad_timeout"
              c:identifier="nm_setting_ip_config_get_dad_timeout"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingIPConfig:dad-timeout property.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dhcp_hostname"
              c:identifier="nm_setting_ip_config_get_dhcp_hostname">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIPConfig:dhcp-hostname
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the configured hostname to send to the DHCP server</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dhcp_send_hostname"
              c:identifier="nm_setting_ip_config_get_dhcp_send_hostname">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIPConfig:dhcp-send-hostname
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if NetworkManager should send the machine hostname to the
DHCP server when requesting addresses to allow the server to automatically
update DNS information for this machine.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dhcp_timeout"
              c:identifier="nm_setting_ip_config_get_dhcp_timeout"
              version="1.2">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIPConfig:dhcp-timeout
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the configured DHCP timeout in seconds. 0 = default for
the particular kind of device.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dns" c:identifier="nm_setting_ip_config_get_dns">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IP address of the DNS server at index @idx</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index number of the DNS server to return</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_dns_option"
              c:identifier="nm_setting_ip_config_get_dns_option"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the DNS option at index @idx</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index number of the DNS option</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_dns_priority"
              c:identifier="nm_setting_ip_config_get_dns_priority"
              version="1.4">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the priority of DNS servers</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dns_search"
              c:identifier="nm_setting_ip_config_get_dns_search">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the DNS search domain at index @idx</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index number of the DNS search domain to return</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_gateway"
              c:identifier="nm_setting_ip_config_get_gateway">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IP address of the gateway associated with this configuration, or
%NULL.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ignore_auto_dns"
              c:identifier="nm_setting_ip_config_get_ignore_auto_dns">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIPConfig:ignore-auto-dns
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if automatically configured (ie via DHCP) DNS information
should be ignored.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ignore_auto_routes"
              c:identifier="nm_setting_ip_config_get_ignore_auto_routes">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIPConfig:ignore-auto-routes
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if automatically configured (ie via DHCP) routes should be
ignored.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_may_fail"
              c:identifier="nm_setting_ip_config_get_may_fail">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIPConfig:may-fail
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if this connection doesn't require this type of IP
addressing to complete for the connection to succeed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_method" c:identifier="nm_setting_ip_config_get_method">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingIPConfig:method property of the setting; see
#NMSettingIP4Config and #NMSettingIP6Config for details of the
methods available with each type.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_never_default"
              c:identifier="nm_setting_ip_config_get_never_default">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIPConfig:never-default
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if this connection should never be the default
  connection</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_addresses"
              c:identifier="nm_setting_ip_config_get_num_addresses">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of configured addresses</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_dns"
              c:identifier="nm_setting_ip_config_get_num_dns">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of configured DNS servers</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_dns_options"
              c:identifier="nm_setting_ip_config_get_num_dns_options"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of configured DNS options</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_dns_searches"
              c:identifier="nm_setting_ip_config_get_num_dns_searches">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of configured DNS search domains</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_routes"
              c:identifier="nm_setting_ip_config_get_num_routes">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of configured routes</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_route" c:identifier="nm_setting_ip_config_get_route">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the route at index @idx</doc>
          <type name="IPRoute" c:type="NMIPRoute*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index number of the route to return</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_route_metric"
              c:identifier="nm_setting_ip_config_get_route_metric">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIPConfig:route-metric
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the route metric that is used for routes that don't explicitly
specify a metric. See #NMSettingIPConfig:route-metric for more details.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_dns_options"
              c:identifier="nm_setting_ip_config_has_dns_options">
        <doc xml:space="preserve">NMSettingIPConfig can have a list of dns-options. If the list
is empty, there are two similar (but differentiated) states.
Either the options are explicitly set to have no values,
or the options are left undefined. The latter means to use
a default configuration, while the former explicitly means "no-options".</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether DNS options are initalized or left unset (the default).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="next_valid_dns_option"
              c:identifier="nm_setting_ip_config_next_valid_dns_option"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the index, greater or equal than @idx, of the first valid
DNS option, or -1 if no valid option is found</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index to start the search from</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_address"
              c:identifier="nm_setting_ip_config_remove_address">
        <doc xml:space="preserve">Removes the address at index @idx.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index number of the address to remove</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_address_by_value"
              c:identifier="nm_setting_ip_config_remove_address_by_value">
        <doc xml:space="preserve">Removes the address @address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the address was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the IP address to remove</doc>
            <type name="IPAddress" c:type="NMIPAddress*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_dns" c:identifier="nm_setting_ip_config_remove_dns">
        <doc xml:space="preserve">Removes the DNS server at index @idx.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index number of the DNS server to remove</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_dns_by_value"
              c:identifier="nm_setting_ip_config_remove_dns_by_value">
        <doc xml:space="preserve">Removes the DNS server @dns.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the DNS server was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
          <parameter name="dns" transfer-ownership="none">
            <doc xml:space="preserve">the DNS server to remove</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_dns_option"
              c:identifier="nm_setting_ip_config_remove_dns_option"
              version="1.2">
        <doc xml:space="preserve">Removes the DNS option at index @idx.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index number of the DNS option</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_dns_option_by_value"
              c:identifier="nm_setting_ip_config_remove_dns_option_by_value"
              version="1.2">
        <doc xml:space="preserve">Removes the DNS option @dns_option.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the DNS option was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
          <parameter name="dns_option" transfer-ownership="none">
            <doc xml:space="preserve">the DNS option to remove</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_dns_search"
              c:identifier="nm_setting_ip_config_remove_dns_search">
        <doc xml:space="preserve">Removes the DNS search domain at index @idx.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index number of the DNS search domain</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_dns_search_by_value"
              c:identifier="nm_setting_ip_config_remove_dns_search_by_value">
        <doc xml:space="preserve">Removes the DNS search domain @dns_search.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the DNS search domain was found and removed; %FALSE if it was not.

Since 0.9.10</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
          <parameter name="dns_search" transfer-ownership="none">
            <doc xml:space="preserve">the search domain to remove</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_route"
              c:identifier="nm_setting_ip_config_remove_route">
        <doc xml:space="preserve">Removes the route at index @idx.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index number of the route</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_route_by_value"
              c:identifier="nm_setting_ip_config_remove_route_by_value">
        <doc xml:space="preserve">Removes the route @route.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the route was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPConfig</doc>
            <type name="SettingIPConfig" c:type="NMSettingIPConfig*"/>
          </instance-parameter>
          <parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the route to remove</doc>
            <type name="IPRoute" c:type="NMIPRoute*"/>
          </parameter>
        </parameters>
      </method>
      <property name="addresses" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Array of IP addresses.

Element-Type: NMIPAddress</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="dad-timeout"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Timeout in milliseconds used to check for the presence of duplicate IP
addresses on the network.  If an address conflict is detected, the
activation will fail.  A zero value means that no duplicate address
detection is performed, -1 means the default value (either configuration
ipvx.dad-timeout override or 3 seconds).  A value greater than zero is a
timeout in milliseconds.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="dhcp-hostname" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">If the #NMSettingIPConfig:dhcp-send-hostname property is %TRUE, then the
specified name will be sent to the DHCP server when acquiring a lease.
This property and #NMSettingIP4Config:dhcp-fqdn are mutually exclusive and
cannot be set at the same time.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="dhcp-send-hostname"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, a hostname is sent to the DHCP server when acquiring a lease.
Some DHCP servers use this hostname to update DNS databases, essentially
providing a static hostname for the computer.  If the
#NMSettingIPConfig:dhcp-hostname property is %NULL and this property is
%TRUE, the current persistent hostname of the computer is sent.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="dhcp-timeout" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">A timeout for a DHCP transaction in seconds.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="dns" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Array of IP addresses of DNS servers.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="dns-options"
                version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Array of DNS options as described in man 5 resolv.conf.

%NULL means that the options are unset and left at the default.
In this case NetworkManager will use default options. This is
distinct from an empty list of properties.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="dns-priority"
                version="1.4"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Intra-connection DNS priority.

The relative priority to be used when determining the order of DNS
servers in resolv.conf.  A lower value means that servers will be on top
of the file.  Zero selects the default value, which is 50 for VPNs and
100 for other connections.  Note that the priority is to order DNS
settings for multiple active connections. It does not disambiguate
multiple DNS servers within the same connection profile. For that,
just specify the DNS servers in the desired order.
When multiple devices have configurations with the same priority, the
one with an active default route will be preferred.
Note that when using dns=dnsmasq the order is meaningless
since dnsmasq forwards queries to all known servers at the same time.

Negative values have the special effect of excluding other configurations
with a greater priority value; so in presence of at least a negative
priority, only DNS servers from connections with the lowest priority
value will be used.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="dns-search" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Array of DNS search domains.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="gateway" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The gateway associated with this configuration. This is only meaningful
if #NMSettingIPConfig:addresses is also set.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="ignore-auto-dns"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">When #NMSettingIPConfig:method is set to "auto" and this property to
%TRUE, automatically configured nameservers and search domains are
ignored and only nameservers and search domains specified in the
#NMSettingIPConfig:dns and #NMSettingIPConfig:dns-search properties, if
any, are used.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="ignore-auto-routes"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">When #NMSettingIPConfig:method is set to "auto" and this property to
%TRUE, automatically configured routes are ignored and only routes
specified in the #NMSettingIPConfig:routes property, if any, are used.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="may-fail"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, allow overall network configuration to proceed even if the
configuration specified by this property times out.  Note that at least
one IP configuration must succeed or overall network configuration will
still fail.  For example, in IPv6-only networks, setting this property to
%TRUE on the #NMSettingIP4Config allows the overall network configuration
to succeed if IPv4 configuration fails but IPv6 configuration completes
successfully.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="method" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">IP configuration method.

#NMSettingIP4Config and #NMSettingIP6Config both support "auto",
"manual", and "link-local". See the subclass-specific documentation for
other values.

In general, for the "auto" method, properties such as
#NMSettingIPConfig:dns and #NMSettingIPConfig:routes specify information
that is added on to the information returned from automatic
configuration.  The #NMSettingIPConfig:ignore-auto-routes and
#NMSettingIPConfig:ignore-auto-dns properties modify this behavior.

For methods that imply no upstream network, such as "shared" or
"link-local", these properties must be empty.

For IPv4 method "shared", the IP subnet can be configured by adding one
manual IPv4 address or otherwise 10.42.x.0/24 is chosen.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="never-default"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, this connection will never be the default connection for this
IP type, meaning it will never be assigned the default route by
NetworkManager.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="route-metric"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The default metric for routes that don't explicitly specify a metric.
The default value -1 means that the metric is choosen automatically
based on the device type.
The metric applies to dynamic routes, manual (static) routes that
don't have an explicit metric setting, address prefix routes, and
the default route.
Note that for IPv6, the kernel accepts zero (0) but coerces it to
1024 (user default). Hence, setting this property to zero effectively
mean setting it to 1024.
For IPv4, zero is a regular value for the metric.</doc>
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="routes" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Array of IP routes.

Element-Type: NMIPRoute</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingIPConfigClass"
            c:type="NMSettingIPConfigClass"
            glib:is-gtype-struct-for="SettingIPConfig">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="SettingIPTunnel"
           c:symbol-prefix="setting_ip_tunnel"
           c:type="NMSettingIPTunnel"
           parent="Setting"
           glib:type-name="NMSettingIPTunnel"
           glib:get-type="nm_setting_ip_tunnel_get_type"
           glib:type-struct="SettingIPTunnelClass">
      <doc xml:space="preserve">IP Tunneling Settings</doc>
      <constructor name="new"
                   c:identifier="nm_setting_ip_tunnel_new"
                   version="1.2">
        <doc xml:space="preserve">Creates a new #NMSettingIPTunnel object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingIPTunnel object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_encapsulation_limit"
              c:identifier="nm_setting_ip_tunnel_get_encapsulation_limit"
              version="1.2">
        <doc xml:space="preserve">Returns the #NMSettingIPTunnel:encapsulation-limit property of the setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the encapsulation limit value</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPTunnel</doc>
            <type name="SettingIPTunnel" c:type="NMSettingIPTunnel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flow_label"
              c:identifier="nm_setting_ip_tunnel_get_flow_label"
              version="1.2">
        <doc xml:space="preserve">Returns the #NMSettingIPTunnel:flow-label property of the setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the flow label value</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPTunnel</doc>
            <type name="SettingIPTunnel" c:type="NMSettingIPTunnel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_input_key"
              c:identifier="nm_setting_ip_tunnel_get_input_key"
              version="1.2">
        <doc xml:space="preserve">Returns the #NMSettingIPTunnel:input-key property of the setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the input key</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPTunnel</doc>
            <type name="SettingIPTunnel" c:type="NMSettingIPTunnel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_local"
              c:identifier="nm_setting_ip_tunnel_get_local"
              version="1.2">
        <doc xml:space="preserve">Returns the #NMSettingIPTunnel:local property of the setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the local endpoint</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPTunnel</doc>
            <type name="SettingIPTunnel" c:type="NMSettingIPTunnel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mode"
              c:identifier="nm_setting_ip_tunnel_get_mode"
              version="1.2">
        <doc xml:space="preserve">Returns the #NMSettingIPTunnel:mode property of the setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the tunnel mode</doc>
          <type name="IPTunnelMode" c:type="NMIPTunnelMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPTunnel</doc>
            <type name="SettingIPTunnel" c:type="NMSettingIPTunnel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mtu"
              c:identifier="nm_setting_ip_tunnel_get_mtu"
              version="1.2">
        <doc xml:space="preserve">Returns the #NMSettingIPTunnel:mtu property of the setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the MTU</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPTunnel</doc>
            <type name="SettingIPTunnel" c:type="NMSettingIPTunnel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_output_key"
              c:identifier="nm_setting_ip_tunnel_get_output_key"
              version="1.2">
        <doc xml:space="preserve">Returns the #NMSettingIPTunnel:output-key property of the setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the output key</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPTunnel</doc>
            <type name="SettingIPTunnel" c:type="NMSettingIPTunnel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parent"
              c:identifier="nm_setting_ip_tunnel_get_parent"
              version="1.2">
        <doc xml:space="preserve">Returns the #NMSettingIPTunnel:parent property of the setting</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the parent device</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPTunnel</doc>
            <type name="SettingIPTunnel" c:type="NMSettingIPTunnel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_path_mtu_discovery"
              c:identifier="nm_setting_ip_tunnel_get_path_mtu_discovery"
              version="1.2">
        <doc xml:space="preserve">Returns the #NMSettingIPTunnel:path-mtu-discovery property of the setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether path MTU discovery is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPTunnel</doc>
            <type name="SettingIPTunnel" c:type="NMSettingIPTunnel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_remote"
              c:identifier="nm_setting_ip_tunnel_get_remote"
              version="1.2">
        <doc xml:space="preserve">Returns the #NMSettingIPTunnel:remote property of the setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the remote endpoint</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPTunnel</doc>
            <type name="SettingIPTunnel" c:type="NMSettingIPTunnel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tos"
              c:identifier="nm_setting_ip_tunnel_get_tos"
              version="1.2">
        <doc xml:space="preserve">Returns the #NMSettingIPTunnel:tos property of the setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the TOS value</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPTunnel</doc>
            <type name="SettingIPTunnel" c:type="NMSettingIPTunnel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ttl"
              c:identifier="nm_setting_ip_tunnel_get_ttl"
              version="1.2">
        <doc xml:space="preserve">Returns the #NMSettingIPTunnel:ttl property of the setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the Time-to-live value</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIPTunnel</doc>
            <type name="SettingIPTunnel" c:type="NMSettingIPTunnel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="encapsulation-limit"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">How many additional levels of encapsulation are permitted to be prepended
to packets. This property applies only to IPv6 tunnels.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="flow-label"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The flow label to assign to tunnel packets. This property applies only to
IPv6 tunnels.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="input-key"
                version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The key used for tunnel input packets; the property is valid only for
certain tunnel modes (GRE, IP6GRE). If empty, no key is used.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="local"
                version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The local endpoint of the tunnel; the value can be empty, otherwise it
must contain an IPv4 or IPv6 address.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="mode"
                version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The tunneling mode, for example %NM_IP_TUNNEL_MODE_IPIP or
%NM_IP_TUNNEL_MODE_GRE.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="mtu"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="output-key"
                version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The key used for tunnel output packets; the property is valid only for
certain tunnel modes (GRE, IP6GRE). If empty, no key is used.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="parent"
                version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If given, specifies the parent interface name or parent connection UUID
the new device will be bound to so that tunneled packets will only be
routed via that interface.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="path-mtu-discovery"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Whether to enable Path MTU Discovery on this tunnel.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="remote"
                version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The remote endpoint of the tunnel; the value must contain an IPv4 or IPv6
address.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="tos"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The type of service (IPv4) or traffic class (IPv6) field to be set on
tunneled packets.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="ttl"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The TTL to assign to tunneled packets. 0 is a special value meaning that
packets inherit the TTL value.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingIPTunnelClass"
            c:type="NMSettingIPTunnelClass"
            glib:is-gtype-struct-for="SettingIPTunnel">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="SettingInfiniband"
           c:symbol-prefix="setting_infiniband"
           c:type="NMSettingInfiniband"
           parent="Setting"
           glib:type-name="NMSettingInfiniband"
           glib:get-type="nm_setting_infiniband_get_type"
           glib:type-struct="SettingInfinibandClass">
      <doc xml:space="preserve">Infiniband Settings</doc>
      <constructor name="new" c:identifier="nm_setting_infiniband_new">
        <doc xml:space="preserve">Creates a new #NMSettingInfiniband object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingInfiniband object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_mac_address"
              c:identifier="nm_setting_infiniband_get_mac_address">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingInfiniband:mac-address property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingInfiniband</doc>
            <type name="SettingInfiniband" c:type="NMSettingInfiniband*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mtu" c:identifier="nm_setting_infiniband_get_mtu">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingInfiniband:mtu property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingInfiniband</doc>
            <type name="SettingInfiniband" c:type="NMSettingInfiniband*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_p_key" c:identifier="nm_setting_infiniband_get_p_key">
        <doc xml:space="preserve">Returns the P_Key to use for this device. A value of -1 means to
use the default P_Key (aka "the P_Key at index 0"). Otherwise it is
a 16-bit unsigned integer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IPoIB P_Key</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingInfiniband</doc>
            <type name="SettingInfiniband" c:type="NMSettingInfiniband*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parent"
              c:identifier="nm_setting_infiniband_get_parent">
        <doc xml:space="preserve">Returns the parent interface name for this device, if set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the parent interface name</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingInfiniband</doc>
            <type name="SettingInfiniband" c:type="NMSettingInfiniband*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_transport_mode"
              c:identifier="nm_setting_infiniband_get_transport_mode">
        <doc xml:space="preserve">Returns the transport mode for this device. Either 'datagram' or
'connected'.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IPoIB transport mode</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingInfiniband</doc>
            <type name="SettingInfiniband" c:type="NMSettingInfiniband*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_virtual_interface_name"
              c:identifier="nm_setting_infiniband_get_virtual_interface_name">
        <doc xml:space="preserve">Returns the interface name created by combining #NMSettingInfiniband:parent
and #NMSettingInfiniband:p-key. (If either property is unset, this will
return %NULL.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the interface name, or %NULL</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingInfiniband</doc>
            <type name="SettingInfiniband" c:type="NMSettingInfiniband*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="mac-address" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">If specified, this connection will only apply to the IPoIB device whose
permanent MAC address matches. This property does not change the MAC
address of the device (i.e. MAC spoofing).</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="mtu"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-zero, only transmit packets of the specified size or smaller,
breaking larger packets up into multiple frames.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="p-key"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The InfiniBand P_Key to use for this device. A value of -1 means to use
the default P_Key (aka "the P_Key at index 0").  Otherwise it is a 16-bit
unsigned integer, whose high bit is set if it is a "full membership"
P_Key.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="parent"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The interface name of the parent device of this device. Normally %NULL,
but if the #NMSettingInfiniband:p_key property is set, then you must
specify the base device by setting either this property or
#NMSettingInfiniband:mac-address.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="transport-mode"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The IP-over-InfiniBand transport mode. Either "datagram" or
"connected".</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingInfinibandClass"
            c:type="NMSettingInfinibandClass"
            glib:is-gtype-struct-for="SettingInfiniband">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="SettingMacRandomization"
                 glib:type-name="NMSettingMacRandomization"
                 glib:get-type="nm_setting_mac_randomization_get_type"
                 c:type="NMSettingMacRandomization">
      <doc xml:space="preserve">Controls if and how the MAC address of a device is randomzied.</doc>
      <member name="default"
              value="0"
              c:identifier="NM_SETTING_MAC_RANDOMIZATION_DEFAULT"
              glib:nick="default">
        <doc xml:space="preserve">the default value, which unless
overridden by user-controlled defaults configuration, is "never".</doc>
      </member>
      <member name="never"
              value="1"
              c:identifier="NM_SETTING_MAC_RANDOMIZATION_NEVER"
              glib:nick="never">
        <doc xml:space="preserve">the device's MAC address is always used.</doc>
      </member>
      <member name="always"
              value="2"
              c:identifier="NM_SETTING_MAC_RANDOMIZATION_ALWAYS"
              glib:nick="always">
        <doc xml:space="preserve">a random MAC address is used.</doc>
      </member>
    </enumeration>
    <class name="SettingMacsec"
           c:symbol-prefix="setting_macsec"
           c:type="NMSettingMacsec"
           parent="Setting"
           glib:type-name="NMSettingMacsec"
           glib:get-type="nm_setting_macsec_get_type"
           glib:type-struct="SettingMacsecClass">
      <doc xml:space="preserve">MACSec Settings</doc>
      <constructor name="new"
                   c:identifier="nm_setting_macsec_new"
                   version="1.6">
        <doc xml:space="preserve">Creates a new #NMSettingMacsec object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingMacsec object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_encrypt"
              c:identifier="nm_setting_macsec_get_encrypt"
              version="1.6">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingMacsec:encrypt property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingMacsec</doc>
            <type name="SettingMacsec" c:type="NMSettingMacsec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mka_cak"
              c:identifier="nm_setting_macsec_get_mka_cak"
              version="1.6">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingMacsec:mka-cak property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingMacsec</doc>
            <type name="SettingMacsec" c:type="NMSettingMacsec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mka_cak_flags"
              c:identifier="nm_setting_macsec_get_mka_cak_flags"
              version="1.6">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the #NMSettingMacsec:mka-cak</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingMacsec</doc>
            <type name="SettingMacsec" c:type="NMSettingMacsec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mka_ckn"
              c:identifier="nm_setting_macsec_get_mka_ckn"
              version="1.6">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingMacsec:mka-ckn property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingMacsec</doc>
            <type name="SettingMacsec" c:type="NMSettingMacsec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mode"
              c:identifier="nm_setting_macsec_get_mode"
              version="1.6">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingMacsec:mode property of the setting</doc>
          <type name="SettingMacsecMode" c:type="NMSettingMacsecMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingMacsec</doc>
            <type name="SettingMacsec" c:type="NMSettingMacsec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parent"
              c:identifier="nm_setting_macsec_get_parent"
              version="1.6">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingMacsec:parent property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingMacsec</doc>
            <type name="SettingMacsec" c:type="NMSettingMacsec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_port"
              c:identifier="nm_setting_macsec_get_port"
              version="1.6">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingMacsec:port property of the setting</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingMacsec</doc>
            <type name="SettingMacsec" c:type="NMSettingMacsec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_validation"
              c:identifier="nm_setting_macsec_get_validation"
              version="1.6">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingMacsec:validation property of the setting</doc>
          <type name="SettingMacsecValidation"
                c:type="NMSettingMacsecValidation"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingMacsec</doc>
            <type name="SettingMacsec" c:type="NMSettingMacsec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="encrypt"
                version="1.6"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Whether the transmitted traffic must be encrypted.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="mka-cak"
                version="1.6"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The pre-shared CAK (Connectivity Association Key) for MACsec
Key Agreement.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="mka-cak-flags"
                version="1.6"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSettingMacsec:mka-cak
property.</doc>
        <type name="SettingSecretFlags"/>
      </property>
      <property name="mka-ckn"
                version="1.6"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The pre-shared CKN (Connectivity-association Key Name) for
MACsec Key Agreement.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="mode"
                version="1.6"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Specifies how the CAK (Connectivity Association Key) for MKA (MACsec Key
Agreement) is obtained.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="parent"
                version="1.6"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If given, specifies the parent interface name or parent connection UUID
from which this MACSEC interface should be created.  If this property is
not specified, the connection must contain an #NMSettingWired setting
with a #NMSettingWired:mac-address property.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="port"
                version="1.6"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The port component of the SCI (Secure Channel Identifier), between 1 and 65534.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="validation"
                version="1.6"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Specifies the validation mode for incoming frames.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingMacsecClass"
            c:type="NMSettingMacsecClass"
            glib:is-gtype-struct-for="SettingMacsec">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="SettingMacsecMode"
                 version="1.6"
                 glib:type-name="NMSettingMacsecMode"
                 glib:get-type="nm_setting_macsec_mode_get_type"
                 c:type="NMSettingMacsecMode">
      <doc xml:space="preserve">#NMSettingMacsecMode controls how the CAK (Connectivity Association Key) used
in MKA (MACsec Key Agreement) is obtained.</doc>
      <member name="psk"
              value="0"
              c:identifier="NM_SETTING_MACSEC_MODE_PSK"
              glib:nick="psk">
        <doc xml:space="preserve">The CAK is pre-shared</doc>
      </member>
      <member name="eap"
              value="1"
              c:identifier="NM_SETTING_MACSEC_MODE_EAP"
              glib:nick="eap">
        <doc xml:space="preserve">The CAK is the result of participation in EAP</doc>
      </member>
    </enumeration>
    <enumeration name="SettingMacsecValidation"
                 version="1.6"
                 glib:type-name="NMSettingMacsecValidation"
                 glib:get-type="nm_setting_macsec_validation_get_type"
                 c:type="NMSettingMacsecValidation">
      <doc xml:space="preserve">#NMSettingMacsecValidation specifies a validation mode for incoming frames.</doc>
      <member name="disable"
              value="0"
              c:identifier="NM_SETTING_MACSEC_VALIDATION_DISABLE"
              glib:nick="disable">
        <doc xml:space="preserve">All incoming frames are accepted if
  possible</doc>
      </member>
      <member name="check"
              value="1"
              c:identifier="NM_SETTING_MACSEC_VALIDATION_CHECK"
              glib:nick="check">
        <doc xml:space="preserve">Non protected, invalid, or impossible to
  verify frames are accepted and counted as "invalid"</doc>
      </member>
      <member name="strict"
              value="2"
              c:identifier="NM_SETTING_MACSEC_VALIDATION_STRICT"
              glib:nick="strict">
        <doc xml:space="preserve">Non protected, invalid, or impossible to
  verify frames are dropped</doc>
      </member>
    </enumeration>
    <class name="SettingMacvlan"
           c:symbol-prefix="setting_macvlan"
           c:type="NMSettingMacvlan"
           parent="Setting"
           glib:type-name="NMSettingMacvlan"
           glib:get-type="nm_setting_macvlan_get_type"
           glib:type-struct="SettingMacvlanClass">
      <doc xml:space="preserve">MAC VLAN Settings</doc>
      <constructor name="new"
                   c:identifier="nm_setting_macvlan_new"
                   version="1.2">
        <doc xml:space="preserve">Creates a new #NMSettingMacvlan object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingMacvlan object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_mode"
              c:identifier="nm_setting_macvlan_get_mode"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingMacvlan:mode property of the setting</doc>
          <type name="SettingMacvlanMode" c:type="NMSettingMacvlanMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingMacvlan</doc>
            <type name="SettingMacvlan" c:type="NMSettingMacvlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parent"
              c:identifier="nm_setting_macvlan_get_parent"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingMacvlan:parent property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingMacvlan</doc>
            <type name="SettingMacvlan" c:type="NMSettingMacvlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_promiscuous"
              c:identifier="nm_setting_macvlan_get_promiscuous"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingMacvlan:promiscuous property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingMacvlan</doc>
            <type name="SettingMacvlan" c:type="NMSettingMacvlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tap"
              c:identifier="nm_setting_macvlan_get_tap"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingMacvlan:tap property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingMacvlan</doc>
            <type name="SettingMacvlan" c:type="NMSettingMacvlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="mode"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The macvlan mode, which specifies the communication mechanism between multiple
macvlans on the same lower device.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="parent"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If given, specifies the parent interface name or parent connection UUID
from which this MAC-VLAN interface should be created.  If this property is
not specified, the connection must contain an #NMSettingWired setting
with a #NMSettingWired:mac-address property.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="promiscuous"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Whether the interface should be put in promiscuous mode.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="tap"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Whether the interface should be a MACVTAP.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingMacvlanClass"
            c:type="NMSettingMacvlanClass"
            glib:is-gtype-struct-for="SettingMacvlan">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="SettingMacvlanMode"
                 glib:type-name="NMSettingMacvlanMode"
                 glib:get-type="nm_setting_macvlan_mode_get_type"
                 c:type="NMSettingMacvlanMode">
      <member name="unknown"
              value="0"
              c:identifier="NM_SETTING_MACVLAN_MODE_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">unknown/unset mode</doc>
      </member>
      <member name="vepa"
              value="1"
              c:identifier="NM_SETTING_MACVLAN_MODE_VEPA"
              glib:nick="vepa">
        <doc xml:space="preserve">Virtual Ethernet Port Aggregator mode</doc>
      </member>
      <member name="bridge"
              value="2"
              c:identifier="NM_SETTING_MACVLAN_MODE_BRIDGE"
              glib:nick="bridge">
        <doc xml:space="preserve">bridge mode</doc>
      </member>
      <member name="private"
              value="3"
              c:identifier="NM_SETTING_MACVLAN_MODE_PRIVATE"
              glib:nick="private">
        <doc xml:space="preserve">private mode</doc>
      </member>
      <member name="passthru"
              value="4"
              c:identifier="NM_SETTING_MACVLAN_MODE_PASSTHRU"
              glib:nick="passthru">
        <doc xml:space="preserve">passthru mode</doc>
      </member>
      <member name="source"
              value="5"
              c:identifier="NM_SETTING_MACVLAN_MODE_SOURCE"
              glib:nick="source">
        <doc xml:space="preserve">source mode</doc>
      </member>
    </enumeration>
    <class name="SettingOlpcMesh"
           c:symbol-prefix="setting_olpc_mesh"
           c:type="NMSettingOlpcMesh"
           parent="Setting"
           glib:type-name="NMSettingOlpcMesh"
           glib:get-type="nm_setting_olpc_mesh_get_type"
           glib:type-struct="SettingOlpcMeshClass">
      <doc xml:space="preserve">OLPC Wireless Mesh Settings</doc>
      <constructor name="new" c:identifier="nm_setting_olpc_mesh_new">
        <doc xml:space="preserve">Creates a new #NMSettingOlpcMesh object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingOlpcMesh object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_channel"
              c:identifier="nm_setting_olpc_mesh_get_channel">
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <type name="SettingOlpcMesh" c:type="NMSettingOlpcMesh*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dhcp_anycast_address"
              c:identifier="nm_setting_olpc_mesh_get_dhcp_anycast_address">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <type name="SettingOlpcMesh" c:type="NMSettingOlpcMesh*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ssid" c:identifier="nm_setting_olpc_mesh_get_ssid">
        <return-value transfer-ownership="none">
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingOlpcMesh</doc>
            <type name="SettingOlpcMesh" c:type="NMSettingOlpcMesh*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="channel"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Channel on which the mesh network to join is located.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="dhcp-anycast-address"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Anycast DHCP MAC address used when requesting an IP address via DHCP.
The specific anycast address used determines which DHCP server class
answers the request.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="ssid" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">SSID of the mesh network to join.</doc>
        <type name="GLib.Bytes"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingOlpcMeshClass"
            c:type="NMSettingOlpcMeshClass"
            glib:is-gtype-struct-for="SettingOlpcMesh">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="SettingPpp"
           c:symbol-prefix="setting_ppp"
           c:type="NMSettingPpp"
           parent="Setting"
           glib:type-name="NMSettingPpp"
           glib:get-type="nm_setting_ppp_get_type"
           glib:type-struct="SettingPppClass">
      <doc xml:space="preserve">Point-to-Point Protocol Settings</doc>
      <constructor name="new" c:identifier="nm_setting_ppp_new">
        <doc xml:space="preserve">Creates a new #NMSettingPpp object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingPpp object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_baud" c:identifier="nm_setting_ppp_get_baud">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPpp:baud property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPpp</doc>
            <type name="SettingPpp" c:type="NMSettingPpp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_crtscts" c:identifier="nm_setting_ppp_get_crtscts">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPpp:crtscts property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPpp</doc>
            <type name="SettingPpp" c:type="NMSettingPpp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_lcp_echo_failure"
              c:identifier="nm_setting_ppp_get_lcp_echo_failure">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPpp:lcp-echo-failure property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPpp</doc>
            <type name="SettingPpp" c:type="NMSettingPpp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_lcp_echo_interval"
              c:identifier="nm_setting_ppp_get_lcp_echo_interval">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPpp:lcp-echo-interval property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPpp</doc>
            <type name="SettingPpp" c:type="NMSettingPpp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mppe_stateful"
              c:identifier="nm_setting_ppp_get_mppe_stateful">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPpp:mppe-stateful property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPpp</doc>
            <type name="SettingPpp" c:type="NMSettingPpp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mru" c:identifier="nm_setting_ppp_get_mru">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPpp:mru property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPpp</doc>
            <type name="SettingPpp" c:type="NMSettingPpp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mtu" c:identifier="nm_setting_ppp_get_mtu">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPpp:mtu property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPpp</doc>
            <type name="SettingPpp" c:type="NMSettingPpp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_no_vj_comp"
              c:identifier="nm_setting_ppp_get_no_vj_comp">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPpp:no-vj-comp property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPpp</doc>
            <type name="SettingPpp" c:type="NMSettingPpp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_noauth" c:identifier="nm_setting_ppp_get_noauth">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPpp:noauth property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPpp</doc>
            <type name="SettingPpp" c:type="NMSettingPpp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_nobsdcomp" c:identifier="nm_setting_ppp_get_nobsdcomp">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPpp:nobsdcomp property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPpp</doc>
            <type name="SettingPpp" c:type="NMSettingPpp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_nodeflate" c:identifier="nm_setting_ppp_get_nodeflate">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPpp:nodeflate property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPpp</doc>
            <type name="SettingPpp" c:type="NMSettingPpp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_refuse_chap"
              c:identifier="nm_setting_ppp_get_refuse_chap">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPpp:refuse-chap property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPpp</doc>
            <type name="SettingPpp" c:type="NMSettingPpp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_refuse_eap"
              c:identifier="nm_setting_ppp_get_refuse_eap">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPpp:refuse-eap property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPpp</doc>
            <type name="SettingPpp" c:type="NMSettingPpp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_refuse_mschap"
              c:identifier="nm_setting_ppp_get_refuse_mschap">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPpp:refuse-mschap property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPpp</doc>
            <type name="SettingPpp" c:type="NMSettingPpp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_refuse_mschapv2"
              c:identifier="nm_setting_ppp_get_refuse_mschapv2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPpp:refuse-mschapv2 property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPpp</doc>
            <type name="SettingPpp" c:type="NMSettingPpp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_refuse_pap"
              c:identifier="nm_setting_ppp_get_refuse_pap">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPpp:refuse-pap property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPpp</doc>
            <type name="SettingPpp" c:type="NMSettingPpp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_require_mppe"
              c:identifier="nm_setting_ppp_get_require_mppe">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPpp:require-mppe property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPpp</doc>
            <type name="SettingPpp" c:type="NMSettingPpp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_require_mppe_128"
              c:identifier="nm_setting_ppp_get_require_mppe_128">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPpp:require-mppe-128 property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPpp</doc>
            <type name="SettingPpp" c:type="NMSettingPpp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="baud"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-zero, instruct pppd to set the serial port to the specified
baudrate.  This value should normally be left as 0 to automatically
choose the speed.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="crtscts"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, specify that pppd should set the serial port to use hardware
flow control with RTS and CTS signals.  This value should normally be set
to %FALSE.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="lcp-echo-failure"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-zero, instruct pppd to presume the connection to the peer has
failed if the specified number of LCP echo-requests go unanswered by the
peer.  The "lcp-echo-interval" property must also be set to a non-zero
value if this property is used.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="lcp-echo-interval"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-zero, instruct pppd to send an LCP echo-request frame to the peer
every n seconds (where n is the specified value).  Note that some PPP
peers will respond to echo requests and some will not, and it is not
possible to autodetect this.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="mppe-stateful"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, stateful MPPE is used.  See pppd documentation for more
information on stateful MPPE.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="mru"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-zero, instruct pppd to request that the peer send packets no
larger than the specified size.  If non-zero, the MRU should be between
128 and 16384.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="mtu"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-zero, instruct pppd to send packets no larger than the specified
size.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="no-vj-comp"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, Van Jacobsen TCP header compression will not be requested.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="noauth"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, do not require the other side (usually the PPP server) to
authenticate itself to the client.  If %FALSE, require authentication
from the remote side.  In almost all cases, this should be %TRUE.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="nobsdcomp"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, BSD compression will not be requested.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="nodeflate"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, "deflate" compression will not be requested.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="refuse-chap"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, the CHAP authentication method will not be used.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="refuse-eap"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, the EAP authentication method will not be used.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="refuse-mschap"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, the MSCHAP authentication method will not be used.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="refuse-mschapv2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, the MSCHAPv2 authentication method will not be used.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="refuse-pap"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, the PAP authentication method will not be used.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="require-mppe"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, MPPE (Microsoft Point-to-Point Encrpytion) will be required for
the PPP session.  If either 64-bit or 128-bit MPPE is not available the
session will fail.  Note that MPPE is not used on mobile broadband
connections.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="require-mppe-128"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, 128-bit MPPE (Microsoft Point-to-Point Encrpytion) will be
required for the PPP session, and the "require-mppe" property must also
be set to %TRUE.  If 128-bit MPPE is not available the session will fail.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingPppClass"
            c:type="NMSettingPppClass"
            glib:is-gtype-struct-for="SettingPpp">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="SettingPppoe"
           c:symbol-prefix="setting_pppoe"
           c:type="NMSettingPppoe"
           parent="Setting"
           glib:type-name="NMSettingPppoe"
           glib:get-type="nm_setting_pppoe_get_type"
           glib:type-struct="SettingPppoeClass">
      <doc xml:space="preserve">PPP-over-Ethernet Settings</doc>
      <constructor name="new" c:identifier="nm_setting_pppoe_new">
        <doc xml:space="preserve">Creates a new #NMSettingPppoe object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingPppoe object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_password" c:identifier="nm_setting_pppoe_get_password">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPppoe:password property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPppoe</doc>
            <type name="SettingPppoe" c:type="NMSettingPppoe*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password_flags"
              c:identifier="nm_setting_pppoe_get_password_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the #NMSettingPppoe:password</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPppoe</doc>
            <type name="SettingPppoe" c:type="NMSettingPppoe*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_service" c:identifier="nm_setting_pppoe_get_service">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPppoe:service property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPppoe</doc>
            <type name="SettingPppoe" c:type="NMSettingPppoe*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_username" c:identifier="nm_setting_pppoe_get_username">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPppoe:username property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPppoe</doc>
            <type name="SettingPppoe" c:type="NMSettingPppoe*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="password" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Password used to authenticate with the PPPoE service.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="password-flags" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSettingPppoe:password property.</doc>
        <type name="SettingSecretFlags"/>
      </property>
      <property name="service" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">If specified, instruct PPPoE to only initiate sessions with access
concentrators that provide the specified service.  For most providers,
this should be left blank.  It is only required if there are multiple
access concentrators or a specific service is known to be required.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="username" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Username used to authenticate with the PPPoE service.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingPppoeClass"
            c:type="NMSettingPppoeClass"
            glib:is-gtype-struct-for="SettingPppoe">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="SettingProxy"
           c:symbol-prefix="setting_proxy"
           c:type="NMSettingProxy"
           parent="Setting"
           glib:type-name="NMSettingProxy"
           glib:get-type="nm_setting_proxy_get_type"
           glib:type-struct="SettingProxyClass">
      <doc xml:space="preserve">WWW Proxy Settings</doc>
      <constructor name="new"
                   c:identifier="nm_setting_proxy_new"
                   version="1.6">
        <doc xml:space="preserve">Creates a new #NMSettingProxy object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingProxy object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_browser_only"
              c:identifier="nm_setting_proxy_get_browser_only"
              version="1.6">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if this proxy configuration is only for browser
clients/schemes, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingProxy</doc>
            <type name="SettingProxy" c:type="NMSettingProxy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_method"
              c:identifier="nm_setting_proxy_get_method"
              version="1.6">
        <doc xml:space="preserve">Returns the proxy configuration method. By default the value is %NM_SETTING_PROXY_METHOD_NONE.
%NM_SETTING_PROXY_METHOD_NONE should be selected for a connection intended for direct network
access.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the proxy configuration method</doc>
          <type name="SettingProxyMethod" c:type="NMSettingProxyMethod"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingProxy</doc>
            <type name="SettingProxy" c:type="NMSettingProxy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pac_script"
              c:identifier="nm_setting_proxy_get_pac_script"
              version="1.6">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the PAC script</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingProxy</doc>
            <type name="SettingProxy" c:type="NMSettingProxy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pac_url"
              c:identifier="nm_setting_proxy_get_pac_url"
              version="1.6">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the PAC URL for obtaining PAC file</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingProxy</doc>
            <type name="SettingProxy" c:type="NMSettingProxy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="browser-only"
                version="1.6"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Whether the proxy configuration is for browser only.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="method"
                version="1.6"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Method for proxy configuration, Default is %NM_SETTING_PROXY_METHOD_NONE</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="pac-script"
                version="1.6"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">PAC script for the connection.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="pac-url"
                version="1.6"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">PAC URL for obtaining PAC file.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingProxyClass"
            c:type="NMSettingProxyClass"
            glib:is-gtype-struct-for="SettingProxy">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="SettingProxyMethod"
                 version="1.6"
                 glib:type-name="NMSettingProxyMethod"
                 glib:get-type="nm_setting_proxy_method_get_type"
                 c:type="NMSettingProxyMethod">
      <doc xml:space="preserve">The Proxy method.</doc>
      <member name="none"
              value="0"
              c:identifier="NM_SETTING_PROXY_METHOD_NONE"
              glib:nick="none">
        <doc xml:space="preserve">No Proxy for the Connection</doc>
      </member>
      <member name="auto"
              value="1"
              c:identifier="NM_SETTING_PROXY_METHOD_AUTO"
              glib:nick="auto">
        <doc xml:space="preserve">DHCP obtained Proxy/ Manual override</doc>
      </member>
    </enumeration>
    <bitfield name="SettingSecretFlags"
              glib:type-name="NMSettingSecretFlags"
              glib:get-type="nm_setting_secret_flags_get_type"
              c:type="NMSettingSecretFlags">
      <doc xml:space="preserve">These flags indicate specific behavior related to handling of a secret.  Each
secret has a corresponding set of these flags which indicate how the secret
is to be stored and/or requested when it is needed.</doc>
      <member name="none"
              value="0"
              c:identifier="NM_SETTING_SECRET_FLAG_NONE"
              glib:nick="none">
        <doc xml:space="preserve">the system is responsible for providing and
storing this secret (default)</doc>
      </member>
      <member name="agent_owned"
              value="1"
              c:identifier="NM_SETTING_SECRET_FLAG_AGENT_OWNED"
              glib:nick="agent-owned">
        <doc xml:space="preserve">a user secret agent is responsible
for providing and storing this secret; when it is required agents will be
asked to retrieve it</doc>
      </member>
      <member name="not_saved"
              value="2"
              c:identifier="NM_SETTING_SECRET_FLAG_NOT_SAVED"
              glib:nick="not-saved">
        <doc xml:space="preserve">this secret should not be saved, but
should be requested from the user each time it is needed</doc>
      </member>
      <member name="not_required"
              value="4"
              c:identifier="NM_SETTING_SECRET_FLAG_NOT_REQUIRED"
              glib:nick="not-required">
        <doc xml:space="preserve">in situations where it cannot be
automatically determined that the secret is required (some VPNs and PPP
providers dont require all secrets) this flag indicates that the specific
secret is not required</doc>
      </member>
    </bitfield>
    <class name="SettingSerial"
           c:symbol-prefix="setting_serial"
           c:type="NMSettingSerial"
           parent="Setting"
           glib:type-name="NMSettingSerial"
           glib:get-type="nm_setting_serial_get_type"
           glib:type-struct="SettingSerialClass">
      <doc xml:space="preserve">Serial Link Settings</doc>
      <constructor name="new" c:identifier="nm_setting_serial_new">
        <doc xml:space="preserve">Creates a new #NMSettingSerial object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingSerial object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_baud" c:identifier="nm_setting_serial_get_baud">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSerial:baud property of the setting</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingSerial</doc>
            <type name="SettingSerial" c:type="NMSettingSerial*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bits" c:identifier="nm_setting_serial_get_bits">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSerial:bits property of the setting</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingSerial</doc>
            <type name="SettingSerial" c:type="NMSettingSerial*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parity" c:identifier="nm_setting_serial_get_parity">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSerial:parity property of the setting</doc>
          <type name="SettingSerialParity" c:type="NMSettingSerialParity"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingSerial</doc>
            <type name="SettingSerial" c:type="NMSettingSerial*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_send_delay"
              c:identifier="nm_setting_serial_get_send_delay">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSerial:send-delay property of the setting</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingSerial</doc>
            <type name="SettingSerial" c:type="NMSettingSerial*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_stopbits"
              c:identifier="nm_setting_serial_get_stopbits">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSerial:stopbits property of the setting</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingSerial</doc>
            <type name="SettingSerial" c:type="NMSettingSerial*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="baud"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Speed to use for communication over the serial port.  Note that this
value usually has no effect for mobile broadband modems as they generally
ignore speed settings and use the highest available speed.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="bits"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Byte-width of the serial communication. The 8 in "8n1" for example.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="parity"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Parity setting of the serial port.</doc>
        <type name="SettingSerialParity"/>
      </property>
      <property name="send-delay"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Time to delay between each byte sent to the modem, in microseconds.</doc>
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="stopbits"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Number of stop bits for communication on the serial port.  Either 1 or 2.
The 1 in "8n1" for example.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingSerialClass"
            c:type="NMSettingSerialClass"
            glib:is-gtype-struct-for="SettingSerial">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="SettingSerialParity"
                 glib:type-name="NMSettingSerialParity"
                 glib:get-type="nm_setting_serial_parity_get_type"
                 c:type="NMSettingSerialParity">
      <doc xml:space="preserve">The parity setting of a serial port.</doc>
      <member name="none"
              value="0"
              c:identifier="NM_SETTING_SERIAL_PARITY_NONE"
              glib:nick="none">
        <doc xml:space="preserve">No parity bits (default)</doc>
      </member>
      <member name="even"
              value="1"
              c:identifier="NM_SETTING_SERIAL_PARITY_EVEN"
              glib:nick="even">
        <doc xml:space="preserve">Even parity</doc>
      </member>
      <member name="odd"
              value="2"
              c:identifier="NM_SETTING_SERIAL_PARITY_ODD"
              glib:nick="odd">
        <doc xml:space="preserve">Odd parity</doc>
      </member>
    </enumeration>
    <class name="SettingTeam"
           c:symbol-prefix="setting_team"
           c:type="NMSettingTeam"
           parent="Setting"
           glib:type-name="NMSettingTeam"
           glib:get-type="nm_setting_team_get_type"
           glib:type-struct="SettingTeamClass">
      <doc xml:space="preserve">Teaming Settings</doc>
      <constructor name="new" c:identifier="nm_setting_team_new">
        <doc xml:space="preserve">Creates a new #NMSettingTeam object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingTeam object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_config" c:identifier="nm_setting_team_get_config">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingTeam:config property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingTeam</doc>
            <type name="SettingTeam" c:type="NMSettingTeam*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="config" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The JSON configuration for the team network interface.  The property
should contain raw JSON configuration data suitable for teamd, because
the value is passed directly to teamd. If not specified, the default
configuration is used.  See man teamd.conf for the format details.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingTeamClass"
            c:type="NMSettingTeamClass"
            glib:is-gtype-struct-for="SettingTeam">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="SettingTeamPort"
           c:symbol-prefix="setting_team_port"
           c:type="NMSettingTeamPort"
           parent="Setting"
           glib:type-name="NMSettingTeamPort"
           glib:get-type="nm_setting_team_port_get_type"
           glib:type-struct="SettingTeamPortClass">
      <doc xml:space="preserve">Team Port Settings</doc>
      <constructor name="new" c:identifier="nm_setting_team_port_new">
        <doc xml:space="preserve">Creates a new #NMSettingTeamPort object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingTeamPort object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_config" c:identifier="nm_setting_team_port_get_config">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingTeamPort:config property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingTeamPort</doc>
            <type name="SettingTeamPort" c:type="NMSettingTeamPort*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="config" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The JSON configuration for the team port. The property should contain raw
JSON configuration data suitable for teamd, because the value is passed
directly to teamd. If not specified, the default configuration is
used. See man teamd.conf for the format details.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingTeamPortClass"
            c:type="NMSettingTeamPortClass"
            glib:is-gtype-struct-for="SettingTeamPort">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="SettingTun"
           c:symbol-prefix="setting_tun"
           c:type="NMSettingTun"
           parent="Setting"
           glib:type-name="NMSettingTun"
           glib:get-type="nm_setting_tun_get_type"
           glib:type-struct="SettingTunClass">
      <doc xml:space="preserve">Tunnel Settings</doc>
      <constructor name="new" c:identifier="nm_setting_tun_new" version="1.2">
        <doc xml:space="preserve">Creates a new #NMSettingTun object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingTun object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_group"
              c:identifier="nm_setting_tun_get_group"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingTun:group property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingTun</doc>
            <type name="SettingTun" c:type="NMSettingTun*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mode"
              c:identifier="nm_setting_tun_get_mode"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingTun:mode property of the setting</doc>
          <type name="SettingTunMode" c:type="NMSettingTunMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingTun</doc>
            <type name="SettingTun" c:type="NMSettingTun*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_multi_queue"
              c:identifier="nm_setting_tun_get_multi_queue"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingTun:multi-queue property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingTun</doc>
            <type name="SettingTun" c:type="NMSettingTun*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_owner"
              c:identifier="nm_setting_tun_get_owner"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingTun:owner property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingTun</doc>
            <type name="SettingTun" c:type="NMSettingTun*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pi" c:identifier="nm_setting_tun_get_pi" version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingTun:pi property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingTun</doc>
            <type name="SettingTun" c:type="NMSettingTun*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vnet_hdr"
              c:identifier="nm_setting_tun_get_vnet_hdr"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingTun:vnet_hdr property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingTun</doc>
            <type name="SettingTun" c:type="NMSettingTun*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="group"
                version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The group ID which will own the device. If set to %NULL everyone
will be able to use the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="mode"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The operating mode of the virtual device. Allowed values are
%NM_SETTING_TUN_MODE_TUN to create a layer 3 device and
%NM_SETTING_TUN_MODE_TAP to create an Ethernet-like layer 2
one.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="multi-queue"
                version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If the property is set to %TRUE, the interface will support
multiple file descriptors (queues) to parallelize packet
sending or receiving. Otherwise, the interface will only
support a single queue.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="owner"
                version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The user ID which will own the device. If set to %NULL everyone
will be able to use the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="pi" version="1.2" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE the interface will prepend a 4 byte header describing the
physical interface to the packets.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="vnet-hdr"
                version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE the IFF_VNET_HDR the tunnel packets will include a virtio
network header.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingTunClass"
            c:type="NMSettingTunClass"
            glib:is-gtype-struct-for="SettingTun">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="SettingTunMode"
                 glib:type-name="NMSettingTunMode"
                 glib:get-type="nm_setting_tun_mode_get_type"
                 c:type="NMSettingTunMode">
      <doc xml:space="preserve">#NMSettingTunMode values indicate the device type (TUN/TAP)</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_SETTING_TUN_MODE_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">an unknown device type</doc>
      </member>
      <member name="tun"
              value="1"
              c:identifier="NM_SETTING_TUN_MODE_TUN"
              glib:nick="tun">
        <doc xml:space="preserve">a TUN device</doc>
      </member>
      <member name="tap"
              value="2"
              c:identifier="NM_SETTING_TUN_MODE_TAP"
              glib:nick="tap">
        <doc xml:space="preserve">a TAP device</doc>
      </member>
    </enumeration>
    <class name="SettingUser"
           c:symbol-prefix="setting_user"
           c:type="NMSettingUser"
           parent="Setting"
           glib:type-name="NMSettingUser"
           glib:get-type="nm_setting_user_get_type"
           glib:type-struct="SettingUserClass">
      <doc xml:space="preserve">General User Profile Settings</doc>
      <constructor name="new" c:identifier="nm_setting_user_new">
        <doc xml:space="preserve">Creates a new #NMSettingUser object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingUser object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <function name="check_key"
                c:identifier="nm_setting_user_check_key"
                version="1.8"
                throws="1">
        <doc xml:space="preserve">Checks whether @key is a valid user data key. This means,
key is not %NULL, not too large and valid ASCII. Also,
only digits and numbers are allowed with a few special
characters. The key must contain at least one '.' and
look like a fully qualified DNS name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @key is a valid user data key.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to check</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="check_val"
                c:identifier="nm_setting_user_check_val"
                version="1.8"
                throws="1">
        <doc xml:space="preserve">Checks whether @val is a valid user data value. This means,
value is not %NULL, not too large and valid UTF-8.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @val is a valid user data value.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve">the value to check</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_data"
              c:identifier="nm_setting_user_get_data"
              version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value associated with @key or %NULL if no such
  value exists.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingUser instance</doc>
            <type name="SettingUser" c:type="NMSettingUser*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to lookup</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_keys" c:identifier="nm_setting_user_get_keys">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a
  %NULL-terminated array containing each key from the table.</doc>
          <array length="0" zero-terminated="0" c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingUser</doc>
            <type name="SettingUser" c:type="NMSettingUser*"/>
          </instance-parameter>
          <parameter name="out_len"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">the length of the returned array</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_data"
              c:identifier="nm_setting_user_set_data"
              version="1.8"
              throws="1">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful. The operation
  can fail if @key or @val are not valid strings according
  to nm_setting_user_check_key() and nm_setting_user_check_val().</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingUser instance</doc>
            <type name="SettingUser" c:type="NMSettingUser*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to set</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="val"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the value to set or %NULL to clear a key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="data"
                version="1.8"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A dictionary of key/value pairs with user data. This data is ignored by NetworkManager
and can be used at the users discretion. The keys only support a strict ascii format,
but the values can be arbitrary UTF8 strings up to a certain length.</doc>
        <type name="GLib.HashTable">
          <type name="utf8"/>
          <type name="utf8"/>
        </type>
      </property>
    </class>
    <record name="SettingUserClass"
            c:type="NMSettingUserClass"
            disguised="1"
            glib:is-gtype-struct-for="SettingUser">
    </record>
    <callback name="SettingValueIterFn" c:type="NMSettingValueIterFn">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="setting" transfer-ownership="none">
          <doc xml:space="preserve">The setting for which properties are being iterated, given to
nm_setting_enumerate_values()</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">The value/property name</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">The property's value</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">The property's flags, like %NM_SETTING_PARAM_SECRET</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="4">
          <doc xml:space="preserve">User data passed to nm_setting_enumerate_values()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="SettingVlan"
           c:symbol-prefix="setting_vlan"
           c:type="NMSettingVlan"
           parent="Setting"
           glib:type-name="NMSettingVlan"
           glib:get-type="nm_setting_vlan_get_type"
           glib:type-struct="SettingVlanClass">
      <doc xml:space="preserve">VLAN Settings</doc>
      <constructor name="new" c:identifier="nm_setting_vlan_new">
        <doc xml:space="preserve">Creates a new #NMSettingVlan object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingVlan object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="add_priority" c:identifier="nm_setting_vlan_add_priority">
        <doc xml:space="preserve">Adds a priority mapping to the #NMSettingVlan:ingress_priority_map or
#NMSettingVlan:egress_priority_map properties of the setting. If @from is
already in the given priority map, this function will overwrite the
existing entry with the new @to.

If @map is #NM_VLAN_INGRESS_MAP then @from is the incoming 802.1q VLAN
Priority Code Point (PCP) value, and @to is the Linux SKB priority value.

If @map is #NM_VLAN_EGRESS_MAP then @from is the Linux SKB priority value and
@to is the outgoing 802.1q VLAN Priority Code Point (PCP) value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the new priority mapping was successfully added to the
list, %FALSE if error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVlan</doc>
            <type name="SettingVlan" c:type="NMSettingVlan*"/>
          </instance-parameter>
          <parameter name="map" transfer-ownership="none">
            <doc xml:space="preserve">the type of priority map</doc>
            <type name="VlanPriorityMap" c:type="NMVlanPriorityMap"/>
          </parameter>
          <parameter name="from" transfer-ownership="none">
            <doc xml:space="preserve">the priority to map to @to</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="to" transfer-ownership="none">
            <doc xml:space="preserve">the priority to map @from to</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_priority_str"
              c:identifier="nm_setting_vlan_add_priority_str">
        <doc xml:space="preserve">Adds a priority map entry into either the #NMSettingVlan:ingress_priority_map
or the #NMSettingVlan:egress_priority_map properties.  The priority map maps
the Linux SKB priorities to 802.1p priorities.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the entry was successfully added to the list, or it
overwrote the old value, %FALSE if error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVlan</doc>
            <type name="SettingVlan" c:type="NMSettingVlan*"/>
          </instance-parameter>
          <parameter name="map" transfer-ownership="none">
            <doc xml:space="preserve">the type of priority map</doc>
            <type name="VlanPriorityMap" c:type="NMVlanPriorityMap"/>
          </parameter>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve">the string which contains a priority map, like "3:7"</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_priorities"
              c:identifier="nm_setting_vlan_clear_priorities">
        <doc xml:space="preserve">Clear all the entries from #NMSettingVlan:ingress_priority_map or
#NMSettingVlan:egress_priority_map properties.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVlan</doc>
            <type name="SettingVlan" c:type="NMSettingVlan*"/>
          </instance-parameter>
          <parameter name="map" transfer-ownership="none">
            <doc xml:space="preserve">the type of priority map</doc>
            <type name="VlanPriorityMap" c:type="NMVlanPriorityMap"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="nm_setting_vlan_get_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVlan:flags property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVlan</doc>
            <type name="SettingVlan" c:type="NMSettingVlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_id" c:identifier="nm_setting_vlan_get_id">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVlan:id property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVlan</doc>
            <type name="SettingVlan" c:type="NMSettingVlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_priorities"
              c:identifier="nm_setting_vlan_get_num_priorities">
        <doc xml:space="preserve">Returns the number of entries in the
#NMSettingVlan:ingress_priority_map or #NMSettingVlan:egress_priority_map
properties of this setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">return the number of ingress/egress priority entries, -1 if error</doc>
          <type name="gint32" c:type="gint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVlan</doc>
            <type name="SettingVlan" c:type="NMSettingVlan*"/>
          </instance-parameter>
          <parameter name="map" transfer-ownership="none">
            <doc xml:space="preserve">the type of priority map</doc>
            <type name="VlanPriorityMap" c:type="NMVlanPriorityMap"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_parent" c:identifier="nm_setting_vlan_get_parent">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVlan:parent property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVlan</doc>
            <type name="SettingVlan" c:type="NMSettingVlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_priority" c:identifier="nm_setting_vlan_get_priority">
        <doc xml:space="preserve">Retrieve one of the entries of the #NMSettingVlan:ingress_priority_map
or #NMSettingVlan:egress_priority_map properties of this setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a priority map was returned, %FALSE if error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVlan</doc>
            <type name="SettingVlan" c:type="NMSettingVlan*"/>
          </instance-parameter>
          <parameter name="map" transfer-ownership="none">
            <doc xml:space="preserve">the type of priority map</doc>
            <type name="VlanPriorityMap" c:type="NMVlanPriorityMap"/>
          </parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">the zero-based index of the ingress/egress priority map entry</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="out_from"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">on return the value of the priority map's 'from' item</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
          <parameter name="out_to"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">on return the value of priority map's 'to' item</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_priority"
              c:identifier="nm_setting_vlan_remove_priority">
        <doc xml:space="preserve">Removes the priority map at index @idx from the
#NMSettingVlan:ingress_priority_map or #NMSettingVlan:egress_priority_map
properties.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVlan</doc>
            <type name="SettingVlan" c:type="NMSettingVlan*"/>
          </instance-parameter>
          <parameter name="map" transfer-ownership="none">
            <doc xml:space="preserve">the type of priority map</doc>
            <type name="VlanPriorityMap" c:type="NMVlanPriorityMap"/>
          </parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">the zero-based index of the priority map to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_priority_by_value"
              c:identifier="nm_setting_vlan_remove_priority_by_value">
        <doc xml:space="preserve">Removes the priority map @form:@to from the #NMSettingVlan:ingress_priority_map
or #NMSettingVlan:egress_priority_map (according to @map argument)
properties.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the priority mapping was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVlan</doc>
            <type name="SettingVlan" c:type="NMSettingVlan*"/>
          </instance-parameter>
          <parameter name="map" transfer-ownership="none">
            <doc xml:space="preserve">the type of priority map</doc>
            <type name="VlanPriorityMap" c:type="NMVlanPriorityMap"/>
          </parameter>
          <parameter name="from" transfer-ownership="none">
            <doc xml:space="preserve">the priority to map to @to</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="to" transfer-ownership="none">
            <doc xml:space="preserve">the priority to map @from to</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_priority_str_by_value"
              c:identifier="nm_setting_vlan_remove_priority_str_by_value">
        <doc xml:space="preserve">Removes the priority map @str from the #NMSettingVlan:ingress_priority_map
or #NMSettingVlan:egress_priority_map (according to @map argument)
properties.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the priority mapping was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVlan</doc>
            <type name="SettingVlan" c:type="NMSettingVlan*"/>
          </instance-parameter>
          <parameter name="map" transfer-ownership="none">
            <doc xml:space="preserve">the type of priority map</doc>
            <type name="VlanPriorityMap" c:type="NMVlanPriorityMap"/>
          </parameter>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve">the string which contains a priority map, like "3:7"</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="egress-priority-map"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">For outgoing packets, a list of mappings from Linux SKB priorities to
802.1p priorities.  The mapping is given in the format "from:to" where
both "from" and "to" are unsigned integers, ie "7:3".</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="flags"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">One or more flags which control the behavior and features of the VLAN
interface.  Flags include %NM_VLAN_FLAG_REORDER_HEADERS (reordering of
output packet headers), %NM_VLAN_FLAG_GVRP (use of the GVRP protocol),
and %NM_VLAN_FLAG_LOOSE_BINDING (loose binding of the interface to its
master device's operating state). %NM_VLAN_FLAG_MVRP (use of the MVRP
protocol).

The default value of this property is NM_VLAN_FLAG_REORDER_HEADERS,
but it used to be 0. To preserve backward compatibility, the default-value
in the D-Bus API continues to be 0 and a missing property on D-Bus
is still considered as 0.</doc>
        <type name="VlanFlags"/>
      </property>
      <property name="id" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">The VLAN identifier that the interface created by this connection should
be assigned. The valid range is from 0 to 4094, without the reserved id 4095.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="ingress-priority-map"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">For incoming packets, a list of mappings from 802.1p priorities to Linux
SKB priorities.  The mapping is given in the format "from:to" where both
"from" and "to" are unsigned integers, ie "7:3".</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="parent"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If given, specifies the parent interface name or parent connection UUID
from which this VLAN interface should be created.  If this property is
not specified, the connection must contain an #NMSettingWired setting
with a #NMSettingWired:mac-address property.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingVlanClass"
            c:type="NMSettingVlanClass"
            glib:is-gtype-struct-for="SettingVlan">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="SettingVpn"
           c:symbol-prefix="setting_vpn"
           c:type="NMSettingVpn"
           parent="Setting"
           glib:type-name="NMSettingVpn"
           glib:get-type="nm_setting_vpn_get_type"
           glib:type-struct="SettingVpnClass">
      <doc xml:space="preserve">VPN Settings</doc>
      <constructor name="new" c:identifier="nm_setting_vpn_new">
        <doc xml:space="preserve">Creates a new #NMSettingVpn object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingVpn object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="add_data_item" c:identifier="nm_setting_vpn_add_data_item">
        <doc xml:space="preserve">Establishes a relationship between @key and @item internally in the
setting which may be retrieved later.  Should not be used to store passwords
or other secrets, which is what nm_setting_vpn_add_secret() is for.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVpn</doc>
            <type name="SettingVpn" c:type="NMSettingVpn*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a name that uniquely identifies the given value @item</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="item" transfer-ownership="none">
            <doc xml:space="preserve">the value to be referenced by @key</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_secret" c:identifier="nm_setting_vpn_add_secret">
        <doc xml:space="preserve">Establishes a relationship between @key and @secret internally in the
setting which may be retrieved later.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVpn</doc>
            <type name="SettingVpn" c:type="NMSettingVpn*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a name that uniquely identifies the given secret @secret</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="secret" transfer-ownership="none">
            <doc xml:space="preserve">the secret to be referenced by @key</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach_data_item"
              c:identifier="nm_setting_vpn_foreach_data_item">
        <doc xml:space="preserve">Iterates all data items stored in this setting.  It is safe to add, remove,
and modify data items inside @func, though any additions or removals made
during iteration will not be part of the iteration.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSettingVpn</doc>
            <type name="SettingVpn" c:type="NMSettingVpn*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">an user provided function</doc>
            <type name="VpnIterFunc" c:type="NMVpnIterFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to be passed to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach_secret"
              c:identifier="nm_setting_vpn_foreach_secret">
        <doc xml:space="preserve">Iterates all secrets stored in this setting.  It is safe to add, remove,
and modify secrets inside @func, though any additions or removals made during
iteration will not be part of the iteration.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSettingVpn</doc>
            <type name="SettingVpn" c:type="NMSettingVpn*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">an user provided function</doc>
            <type name="VpnIterFunc" c:type="NMVpnIterFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to be passed to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_data_item" c:identifier="nm_setting_vpn_get_data_item">
        <doc xml:space="preserve">Retrieves the data item of a key/value relationship previously established
by nm_setting_vpn_add_data_item().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the data item, if any</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVpn</doc>
            <type name="SettingVpn" c:type="NMSettingVpn*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the name of the data item to retrieve</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_num_data_items"
              c:identifier="nm_setting_vpn_get_num_data_items">
        <doc xml:space="preserve">Gets number of key/value pairs of VPN configuration data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of VPN plugin specific configuration data items</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVpn</doc>
            <type name="SettingVpn" c:type="NMSettingVpn*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_secrets"
              c:identifier="nm_setting_vpn_get_num_secrets">
        <doc xml:space="preserve">Gets number of VPN plugin specific secrets in the setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of VPN plugin specific secrets</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVpn</doc>
            <type name="SettingVpn" c:type="NMSettingVpn*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_persistent"
              c:identifier="nm_setting_vpn_get_persistent">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVpn:persistent property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVpn</doc>
            <type name="SettingVpn" c:type="NMSettingVpn*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_secret" c:identifier="nm_setting_vpn_get_secret">
        <doc xml:space="preserve">Retrieves the secret of a key/value relationship previously established
by nm_setting_vpn_add_secret().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the secret, if any</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVpn</doc>
            <type name="SettingVpn" c:type="NMSettingVpn*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the name of the secret to retrieve</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_service_type"
              c:identifier="nm_setting_vpn_get_service_type">
        <doc xml:space="preserve">Returns the service name of the VPN, which identifies the specific VPN
plugin that should be used to connect to this VPN.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the VPN plugin's service name</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVpn</doc>
            <type name="SettingVpn" c:type="NMSettingVpn*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_timeout"
              c:identifier="nm_setting_vpn_get_timeout"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVpn:timeout property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVpn</doc>
            <type name="SettingVpn" c:type="NMSettingVpn*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_user_name" c:identifier="nm_setting_vpn_get_user_name">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVpn:user-name property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVpn</doc>
            <type name="SettingVpn" c:type="NMSettingVpn*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_data_item"
              c:identifier="nm_setting_vpn_remove_data_item">
        <doc xml:space="preserve">Deletes a key/value relationship previously established by
nm_setting_vpn_add_data_item().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the data item was found and removed from the internal list,
%FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVpn</doc>
            <type name="SettingVpn" c:type="NMSettingVpn*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the name of the data item to remove</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_secret" c:identifier="nm_setting_vpn_remove_secret">
        <doc xml:space="preserve">Deletes a key/value relationship previously established by
nm_setting_vpn_add_secret().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the secret was found and removed from the internal list,
%FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVpn</doc>
            <type name="SettingVpn" c:type="NMSettingVpn*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the name of the secret to remove</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="data" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Dictionary of key/value pairs of VPN plugin specific data.  Both keys and
values must be strings.</doc>
        <type name="GLib.HashTable">
          <type name="utf8"/>
          <type name="utf8"/>
        </type>
      </property>
      <property name="persistent" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">If the VPN service supports persistence, and this property is %TRUE,
the VPN will attempt to stay connected across link changes and outages,
until explicitly disconnected.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="secrets" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Dictionary of key/value pairs of VPN plugin specific secrets like
passwords or private keys.  Both keys and values must be strings.</doc>
        <type name="GLib.HashTable">
          <type name="utf8"/>
          <type name="utf8"/>
        </type>
      </property>
      <property name="service-type" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">D-Bus service name of the VPN plugin that this setting uses to connect to
its network.  i.e. org.freedesktop.NetworkManager.vpnc for the vpnc
plugin.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="timeout"
                version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Timeout for the VPN service to establish the connection. Some services
may take quite a long time to connect.
Value of 0 means a default timeout, which is 60 seconds (unless overriden
by vpn.timeout in configuration file). Values greater than zero mean
timeout in seconds.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="user-name" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">If the VPN connection requires a user name for authentication, that name
should be provided here.  If the connection is available to more than one
user, and the VPN requires each user to supply a different name, then
leave this property empty.  If this property is empty, NetworkManager
will automatically supply the username of the user which requested the
VPN connection.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingVpnClass"
            c:type="NMSettingVpnClass"
            glib:is-gtype-struct-for="SettingVpn">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="SettingVxlan"
           c:symbol-prefix="setting_vxlan"
           c:type="NMSettingVxlan"
           parent="Setting"
           glib:type-name="NMSettingVxlan"
           glib:get-type="nm_setting_vxlan_get_type"
           glib:type-struct="SettingVxlanClass">
      <doc xml:space="preserve">VXLAN Settings</doc>
      <constructor name="new"
                   c:identifier="nm_setting_vxlan_new"
                   version="1.2">
        <doc xml:space="preserve">Creates a new #NMSettingVxlan object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingVxlan object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_ageing"
              c:identifier="nm_setting_vxlan_get_ageing"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVxlan:ageing property of the setting</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVxlan</doc>
            <type name="SettingVxlan" c:type="NMSettingVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_destination_port"
              c:identifier="nm_setting_vxlan_get_destination_port"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVxlan:destination-port property of the setting</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVxlan</doc>
            <type name="SettingVxlan" c:type="NMSettingVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_id"
              c:identifier="nm_setting_vxlan_get_id"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVxlan:id property of the setting</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVxlan</doc>
            <type name="SettingVxlan" c:type="NMSettingVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_l2_miss"
              c:identifier="nm_setting_vxlan_get_l2_miss"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVxlan:l2_miss property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVxlan</doc>
            <type name="SettingVxlan" c:type="NMSettingVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_l3_miss"
              c:identifier="nm_setting_vxlan_get_l3_miss"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVxlan:l3_miss property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVxlan</doc>
            <type name="SettingVxlan" c:type="NMSettingVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_learning"
              c:identifier="nm_setting_vxlan_get_learning"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVxlan:learning property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVxlan</doc>
            <type name="SettingVxlan" c:type="NMSettingVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_limit"
              c:identifier="nm_setting_vxlan_get_limit"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVxlan:limit property of the setting</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVxlan</doc>
            <type name="SettingVxlan" c:type="NMSettingVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_local"
              c:identifier="nm_setting_vxlan_get_local"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVxlan:local property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVxlan</doc>
            <type name="SettingVxlan" c:type="NMSettingVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parent"
              c:identifier="nm_setting_vxlan_get_parent"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVxlan:parent property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVxlan</doc>
            <type name="SettingVxlan" c:type="NMSettingVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_proxy"
              c:identifier="nm_setting_vxlan_get_proxy"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVxlan:proxy property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVxlan</doc>
            <type name="SettingVxlan" c:type="NMSettingVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_remote"
              c:identifier="nm_setting_vxlan_get_remote"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVxlan:remote property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVxlan</doc>
            <type name="SettingVxlan" c:type="NMSettingVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_rsc"
              c:identifier="nm_setting_vxlan_get_rsc"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVxlan:rsc property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVxlan</doc>
            <type name="SettingVxlan" c:type="NMSettingVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_source_port_max"
              c:identifier="nm_setting_vxlan_get_source_port_max"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVxlan:source-port-max property of the setting</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVxlan</doc>
            <type name="SettingVxlan" c:type="NMSettingVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_source_port_min"
              c:identifier="nm_setting_vxlan_get_source_port_min"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVxlan:source-port-min property of the setting</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVxlan</doc>
            <type name="SettingVxlan" c:type="NMSettingVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tos"
              c:identifier="nm_setting_vxlan_get_tos"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVxlan:tos property of the setting</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVxlan</doc>
            <type name="SettingVxlan" c:type="NMSettingVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ttl"
              c:identifier="nm_setting_vxlan_get_ttl"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVxlan:ttl property of the setting</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVxlan</doc>
            <type name="SettingVxlan" c:type="NMSettingVxlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="ageing"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Specifies the lifetime in seconds of FDB entries learnt by the kernel.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="destination-port"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Specifies the UDP destination port to communicate to the remote VXLAN
tunnel endpoint.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="id"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Specifies the VXLAN Network Identifer (or VXLAN Segment Identifier) to
use.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="l2-miss"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Specifies whether netlink LL ADDR miss notifications are generated.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="l3-miss"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Specifies whether netlink IP ADDR miss notifications are generated.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="learning"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Specifies whether unknown source link layer addresses and IP addresses
are entered into the VXLAN device forwarding database.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="limit"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Specifies the maximum number of FDB entries. A value of zero means that
the kernel will store unlimited entries.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="local"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If given, specifies the source IP address to use in outgoing packets.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="parent"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If given, specifies the parent interface name or parent connection UUID.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="proxy"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Specifies whether ARP proxy is turned on.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="remote"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Specifies the unicast destination IP address to use in outgoing packets
when the destination link layer address is not known in the VXLAN device
forwarding database, or the multicast IP address to join.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="rsc"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Specifies whether route short circuit is turned on.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="source-port-max"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Specifies the maximum UDP source port to communicate to the remote VXLAN
tunnel endpoint.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="source-port-min"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Specifies the minimum UDP source port to communicate to the remote VXLAN
tunnel endpoint.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="tos"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Specifies the TOS value to use in outgoing packets.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="ttl"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Specifies the time-to-live value to use in outgoing packets.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingVxlanClass"
            c:type="NMSettingVxlanClass"
            glib:is-gtype-struct-for="SettingVxlan">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="SettingWimax"
           c:symbol-prefix="setting_wimax"
           c:type="NMSettingWimax"
           parent="Setting"
           glib:type-name="NMSettingWimax"
           glib:get-type="nm_setting_wimax_get_type"
           glib:type-struct="SettingWimaxClass">
      <doc xml:space="preserve">WiMax Settings</doc>
      <constructor name="new"
                   c:identifier="nm_setting_wimax_new"
                   deprecated="1"
                   deprecated-version="1.2">
        <doc xml:space="preserve">Creates a new #NMSettingWimax object with default values.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingWimax object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_mac_address"
              c:identifier="nm_setting_wimax_get_mac_address"
              deprecated="1"
              deprecated-version="1.2">
        <doc xml:space="preserve">Returns the MAC address of a WiMAX device which this connection is locked
to.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the MAC address</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWimax</doc>
            <type name="SettingWimax" c:type="NMSettingWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_network_name"
              c:identifier="nm_setting_wimax_get_network_name"
              deprecated="1"
              deprecated-version="1.2">
        <doc xml:space="preserve">Returns the WiMAX NSP name (ex "Sprint" or "CLEAR") which identifies the
specific WiMAX network this setting describes a connection to.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the WiMAX NSP name</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWimax</doc>
            <type name="SettingWimax" c:type="NMSettingWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="mac-address"
                deprecated="1"
                deprecated-version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If specified, this connection will only apply to the WiMAX device whose
MAC address matches. This property does not change the MAC address of the
device (known as MAC spoofing).</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="network-name"
                deprecated="1"
                deprecated-version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Network Service Provider (NSP) name of the WiMAX network this connection
should use.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingWimaxClass"
            c:type="NMSettingWimaxClass"
            glib:is-gtype-struct-for="SettingWimax">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="SettingWired"
           c:symbol-prefix="setting_wired"
           c:type="NMSettingWired"
           parent="Setting"
           glib:type-name="NMSettingWired"
           glib:get-type="nm_setting_wired_get_type"
           glib:type-struct="SettingWiredClass">
      <doc xml:space="preserve">Wired Ethernet Settings</doc>
      <constructor name="new" c:identifier="nm_setting_wired_new">
        <doc xml:space="preserve">Creates a new #NMSettingWired object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingWired object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="add_mac_blacklist_item"
              c:identifier="nm_setting_wired_add_mac_blacklist_item">
        <doc xml:space="preserve">Adds a new MAC address to the #NMSettingWired:mac-address-blacklist property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the MAC address was added; %FALSE if the MAC address
is invalid or was already present</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
          <parameter name="mac" transfer-ownership="none">
            <doc xml:space="preserve">the MAC address string (hex-digits-and-colons notation) to blacklist</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_s390_option"
              c:identifier="nm_setting_wired_add_s390_option">
        <doc xml:space="preserve">Add an option to the table.  The option is compared to an internal list
of allowed options.  Key names may contain only alphanumeric characters
(ie [a-zA-Z0-9]).  Adding a new key replaces any existing key/value pair that
may already exist.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the option was valid and was added to the internal option
list, %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">key name for the option</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value for the option</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_mac_blacklist_items"
              c:identifier="nm_setting_wired_clear_mac_blacklist_items">
        <doc xml:space="preserve">Removes all blacklisted MAC addresses.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_auto_negotiate"
              c:identifier="nm_setting_wired_get_auto_negotiate">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWired:auto-negotiate property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_cloned_mac_address"
              c:identifier="nm_setting_wired_get_cloned_mac_address">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWired:cloned-mac-address property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_duplex" c:identifier="nm_setting_wired_get_duplex">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWired:duplex property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_generate_mac_address_mask"
              c:identifier="nm_setting_wired_get_generate_mac_address_mask"
              version="1.4">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWired:generate-mac-address-mask property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mac_address"
              c:identifier="nm_setting_wired_get_mac_address">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWired:mac-address property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mac_address_blacklist"
              c:identifier="nm_setting_wired_get_mac_address_blacklist">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWired:mac-address-blacklist property of the setting</doc>
          <array c:type="const char* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mac_blacklist_item"
              c:identifier="nm_setting_wired_get_mac_blacklist_item">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the blacklisted MAC address string (hex-digits-and-colons notation)
at index @idx</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">the zero-based index of the MAC address entry</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_mtu" c:identifier="nm_setting_wired_get_mtu">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWired:mtu property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_mac_blacklist_items"
              c:identifier="nm_setting_wired_get_num_mac_blacklist_items">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of blacklisted MAC addresses</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_s390_options"
              c:identifier="nm_setting_wired_get_num_s390_options">
        <doc xml:space="preserve">Returns the number of s390-specific options that should be set for this
device when it is activated.  This can be used to retrieve each s390
option individually using nm_setting_wired_get_s390_option().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of s390-specific device options</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_port" c:identifier="nm_setting_wired_get_port">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWired:port property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_s390_nettype"
              c:identifier="nm_setting_wired_get_s390_nettype">
        <doc xml:space="preserve">Returns the s390 device type this connection should apply to.  Will be one
of 'qeth', 'lcs', or 'ctc'.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the s390 device type</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_s390_option"
              c:identifier="nm_setting_wired_get_s390_option">
        <doc xml:space="preserve">Given an index, return the value of the s390 option at that index.  indexes
are *not* guaranteed to be static across modifications to options done by
nm_setting_wired_add_s390_option() and nm_setting_wired_remove_s390_option(),
and should not be used to refer to options except for short periods of time
such as during option iteration.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success if the index was valid and an option was found,
%FALSE if the index was invalid (ie, greater than the number of options
currently held by the setting)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the desired option, from 0 to
nm_setting_wired_get_num_s390_options() - 1</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="out_key"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve">on return, the key name of the s390 specific
  option; this value is owned by the setting and should not be modified</doc>
            <type name="utf8" c:type="const char**"/>
          </parameter>
          <parameter name="out_value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve">on return, the value of the key of the
  s390 specific option; this value is owned by the setting and should not be
  modified</doc>
            <type name="utf8" c:type="const char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_s390_option_by_key"
              c:identifier="nm_setting_wired_get_s390_option_by_key">
        <doc xml:space="preserve">Returns the value associated with the s390-specific option specified by
@key, if it exists.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value, or %NULL if the key/value pair was never added to the
setting; the value is owned by the setting and must not be modified</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key for which to retrieve the value</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_s390_subchannels"
              c:identifier="nm_setting_wired_get_s390_subchannels">
        <doc xml:space="preserve">Return the list of s390 subchannels that identify the device that this
connection is applicable to.  The connection should only be used in
conjunction with that device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">array of strings, each specifying
  one subchannel the s390 device uses to communicate to the host.</doc>
          <array c:type="const char* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_speed" c:identifier="nm_setting_wired_get_speed">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWired:speed property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_valid_s390_options"
              c:identifier="nm_setting_wired_get_valid_s390_options">
        <doc xml:space="preserve">Returns a list of valid s390 options.

The @setting argument is unused and %NULL may be passed instead.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a %NULL-terminated array of strings of valid s390 options.</doc>
          <array c:type="const char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_wake_on_lan"
              c:identifier="nm_setting_wired_get_wake_on_lan"
              version="1.2">
        <doc xml:space="preserve">Returns the Wake-on-LAN options enabled for the connection</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the Wake-on-LAN options</doc>
          <type name="SettingWiredWakeOnLan" c:type="NMSettingWiredWakeOnLan"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_wake_on_lan_password"
              c:identifier="nm_setting_wired_get_wake_on_lan_password"
              version="1.2">
        <doc xml:space="preserve">Returns the Wake-on-LAN password. This only applies to
%NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the Wake-on-LAN setting password, or %NULL if there is no password.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_mac_blacklist_item"
              c:identifier="nm_setting_wired_remove_mac_blacklist_item">
        <doc xml:space="preserve">Removes the MAC address at index @idx from the blacklist.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index number of the MAC address</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_mac_blacklist_item_by_value"
              c:identifier="nm_setting_wired_remove_mac_blacklist_item_by_value">
        <doc xml:space="preserve">Removes the MAC address @mac from the blacklist.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the MAC address was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
          <parameter name="mac" transfer-ownership="none">
            <doc xml:space="preserve">the MAC address string (hex-digits-and-colons notation) to remove from
the blacklist</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_s390_option"
              c:identifier="nm_setting_wired_remove_s390_option">
        <doc xml:space="preserve">Remove the s390-specific option referenced by @key from the internal option
list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the option was found and removed from the internal option
list, %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">key name for the option to remove</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="auto-negotiate"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, enforce auto-negotiation of port speed and duplex mode.  If
%FALSE, "speed" and "duplex" properties should be both set or link configuration
will be skipped.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="cloned-mac-address"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If specified, request that the device use this MAC address instead.
This is known as MAC cloning or spoofing.

Beside explicitly specifing a MAC address, the special values "preserve", "permanent",
"random" and "stable" are supported.
"preserve" means not to touch the MAC address on activation.
"permanent" means to use the permanent hardware address of the device.
"random" creates a random MAC address on each connect.
"stable" creates a hashed MAC address based on connection.stable-id and a
machine dependent key.

If unspecified, the value can be overwritten via global defaults, see manual
of NetworkManager.conf. If still unspecified, it defaults to "preserve"
(older versions of NetworkManager may use a different default value).

On D-Bus, this field is expressed as "assigned-mac-address" or the deprecated
"cloned-mac-address".</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="duplex" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Can be specified only when "auto-negotiate" is "off". In that case, statically
configures the device to use that specified duplex mode, either "half" or "full".
Must be set together with the "speed" property if specified.
Before specifying a duplex mode be sure your device supports it.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="generate-mac-address-mask"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">With #NMSettingWired:cloned-mac-address setting "random" or "stable",
by default all bits of the MAC address are scrambled and a locally-administered,
unicast MAC address is created. This property allows to specify that certain bits
are fixed. Note that the least significant bit of the first MAC address will
always be unset to create a unicast MAC address.

If the property is %NULL, it is eligible to be overwritten by a default
connection setting. If the value is still %NULL or an empty string, the
default is to create a locally-administered, unicast MAC address.

If the value contains one MAC address, this address is used as mask. The set
bits of the mask are to be filled with the current MAC address of the device,
while the unset bits are subject to randomization.
Setting "FE:FF:FF:00:00:00" means to preserve the OUI of the current MAC address
and only randomize the lower 3 bytes using the "random" or "stable" algorithm.

If the value contains one additional MAC address after the mask,
this address is used instead of the current MAC address to fill the bits
that shall not be randomized. For example, a value of
"FE:FF:FF:00:00:00 68:F7:28:00:00:00" will set the OUI of the MAC address
to 68:F7:28, while the lower bits are randomized. A value of
"02:00:00:00:00:00 00:00:00:00:00:00" will create a fully scrambled
globally-administered, burned-in MAC address.

If the value contains more then one additional MAC addresses, one of
them is chosen randomly. For example, "02:00:00:00:00:00 00:00:00:00:00:00 02:00:00:00:00:00"
will create a fully scrambled MAC address, randomly locally or globally
administered.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="mac-address" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">If specified, this connection will only apply to the Ethernet device
whose permanent MAC address matches. This property does not change the
MAC address of the device (i.e. MAC spoofing).</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="mac-address-blacklist"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If specified, this connection will never apply to the Ethernet device
whose permanent MAC address matches an address in the list.  Each MAC
address is in the standard hex-digits-and-colons notation
(00:11:22:33:44:55).</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="mtu"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-zero, only transmit packets of the specified size or smaller,
breaking larger packets up into multiple Ethernet frames.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="port" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Specific port type to use if multiple the device supports multiple
attachment methods.  One of "tp" (Twisted Pair), "aui" (Attachment Unit
Interface), "bnc" (Thin Ethernet) or "mii" (Media Independent Interface.
If the device supports only one port type, this setting is ignored.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="s390-nettype" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">s390 network device type; one of "qeth", "lcs", or "ctc", representing
the different types of virtual network devices available on s390 systems.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="s390-options" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Dictionary of key/value pairs of s390-specific device options.  Both keys
and values must be strings.  Allowed keys include "portno", "layer2",
"portname", "protocol", among others.  Key names must contain only
alphanumeric characters (ie, [a-zA-Z0-9]).</doc>
        <type name="GLib.HashTable">
          <type name="utf8"/>
          <type name="utf8"/>
        </type>
      </property>
      <property name="s390-subchannels" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Identifies specific subchannels that this network device uses for
communication with z/VM or s390 host.  Like the
#NMSettingWired:mac-address property for non-z/VM devices, this property
can be used to ensure this connection only applies to the network device
that uses these subchannels.  The list should contain exactly 3 strings,
and each string may only be composed of hexadecimal characters and the
period (.) character.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="speed"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Can be set to a value grater than zero only when "auto-negotiate" is "off".
In that case, statically configures the device to use that specified speed.
In Mbit/s, ie 100 == 100Mbit/s.
Must be set together with the "duplex" property when non-zero.
Before specifying a speed value be sure your device supports it.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="wake-on-lan"
                version="1.2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #NMSettingWiredWakeOnLan options to enable. Not all devices support all options.
May be any combination of %NM_SETTING_WIRED_WAKE_ON_LAN_PHY,
%NM_SETTING_WIRED_WAKE_ON_LAN_UNICAST, %NM_SETTING_WIRED_WAKE_ON_LAN_MULTICAST,
%NM_SETTING_WIRED_WAKE_ON_LAN_BROADCAST, %NM_SETTING_WIRED_WAKE_ON_LAN_ARP,
%NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC or the special values
%NM_SETTING_WIRED_WAKE_ON_LAN_DEFAULT (to use global settings) and
%NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE (to disable management of Wake-on-LAN in
NetworkManager).</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="wake-on-lan-password"
                version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If specified, the password used with magic-packet-based
Wake-on-LAN, represented as an Ethernet MAC address.  If %NULL,
no password will be required.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingWiredClass"
            c:type="NMSettingWiredClass"
            glib:is-gtype-struct-for="SettingWired">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="SettingWiredWakeOnLan"
              version="1.2"
              glib:type-name="NMSettingWiredWakeOnLan"
              glib:get-type="nm_setting_wired_wake_on_lan_get_type"
              c:type="NMSettingWiredWakeOnLan">
      <doc xml:space="preserve">Options for #NMSettingWired:wake-on-lan. Note that not all options
are supported by all devices.</doc>
      <member name="phy"
              value="2"
              c:identifier="NM_SETTING_WIRED_WAKE_ON_LAN_PHY"
              glib:nick="phy">
        <doc xml:space="preserve">Wake on PHY activity</doc>
      </member>
      <member name="unicast"
              value="4"
              c:identifier="NM_SETTING_WIRED_WAKE_ON_LAN_UNICAST"
              glib:nick="unicast">
        <doc xml:space="preserve">Wake on unicast messages</doc>
      </member>
      <member name="multicast"
              value="8"
              c:identifier="NM_SETTING_WIRED_WAKE_ON_LAN_MULTICAST"
              glib:nick="multicast">
        <doc xml:space="preserve">Wake on multicast messages</doc>
      </member>
      <member name="broadcast"
              value="16"
              c:identifier="NM_SETTING_WIRED_WAKE_ON_LAN_BROADCAST"
              glib:nick="broadcast">
        <doc xml:space="preserve">Wake on broadcast messages</doc>
      </member>
      <member name="arp"
              value="32"
              c:identifier="NM_SETTING_WIRED_WAKE_ON_LAN_ARP"
              glib:nick="arp">
        <doc xml:space="preserve">Wake on ARP</doc>
      </member>
      <member name="magic"
              value="64"
              c:identifier="NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC"
              glib:nick="magic">
        <doc xml:space="preserve">Wake on magic packet</doc>
      </member>
      <member name="default"
              value="1"
              c:identifier="NM_SETTING_WIRED_WAKE_ON_LAN_DEFAULT"
              glib:nick="default">
        <doc xml:space="preserve">Use the default value</doc>
      </member>
      <member name="ignore"
              value="32768"
              c:identifier="NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE"
              glib:nick="ignore">
        <doc xml:space="preserve">Don't change configured settings</doc>
      </member>
    </bitfield>
    <class name="SettingWireless"
           c:symbol-prefix="setting_wireless"
           c:type="NMSettingWireless"
           parent="Setting"
           glib:type-name="NMSettingWireless"
           glib:get-type="nm_setting_wireless_get_type"
           glib:type-struct="SettingWirelessClass">
      <doc xml:space="preserve">Wi-Fi Settings</doc>
      <constructor name="new" c:identifier="nm_setting_wireless_new">
        <doc xml:space="preserve">Creates a new #NMSettingWireless object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingWireless object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="add_mac_blacklist_item"
              c:identifier="nm_setting_wireless_add_mac_blacklist_item">
        <doc xml:space="preserve">Adds a new MAC address to the #NMSettingWireless:mac-address-blacklist property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the MAC address was added; %FALSE if the MAC address
is invalid or was already present</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
          <parameter name="mac" transfer-ownership="none">
            <doc xml:space="preserve">the MAC address string (hex-digits-and-colons notation) to blacklist</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_seen_bssid"
              c:identifier="nm_setting_wireless_add_seen_bssid">
        <doc xml:space="preserve">Adds a new Wi-Fi AP's BSSID to the previously seen BSSID list of the setting.
NetworkManager now tracks previously seen BSSIDs internally so this function
no longer has much use. Actually, changes you make using this function will
not be preserved.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @bssid was already known, %FALSE if not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
          <parameter name="bssid" transfer-ownership="none">
            <doc xml:space="preserve">the new BSSID to add to the list</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ap_security_compatible"
              c:identifier="nm_setting_wireless_ap_security_compatible">
        <doc xml:space="preserve">Given a #NMSettingWireless and an optional #NMSettingWirelessSecurity,
determine if the configuration given by the settings is compatible with
the security of an access point using that access point's capability flags
and mode.  Useful for clients that wish to filter a set of connections
against a set of access points and determine which connections are
compatible with which access points.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the given settings are compatible with the access point's
security flags and mode, %FALSE if they are not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="s_wireless" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
          <parameter name="s_wireless_sec" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSettingWirelessSecurity or %NULL</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </parameter>
          <parameter name="ap_flags" transfer-ownership="none">
            <doc xml:space="preserve">the %NM80211ApFlags of the given access point</doc>
            <type name="80211ApFlags" c:type="NM80211ApFlags"/>
          </parameter>
          <parameter name="ap_wpa" transfer-ownership="none">
            <doc xml:space="preserve">the %NM80211ApSecurityFlags of the given access point's WPA
capabilities</doc>
            <type name="80211ApSecurityFlags" c:type="NM80211ApSecurityFlags"/>
          </parameter>
          <parameter name="ap_rsn" transfer-ownership="none">
            <doc xml:space="preserve">the %NM80211ApSecurityFlags of the given access point's WPA2/RSN
capabilities</doc>
            <type name="80211ApSecurityFlags" c:type="NM80211ApSecurityFlags"/>
          </parameter>
          <parameter name="ap_mode" transfer-ownership="none">
            <doc xml:space="preserve">the 802.11 mode of the AP, either Ad-Hoc or Infrastructure</doc>
            <type name="80211Mode" c:type="NM80211Mode"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_mac_blacklist_items"
              c:identifier="nm_setting_wireless_clear_mac_blacklist_items">
        <doc xml:space="preserve">Removes all blacklisted MAC addresses.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_band" c:identifier="nm_setting_wireless_get_band">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:band property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bssid" c:identifier="nm_setting_wireless_get_bssid">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:bssid property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_channel"
              c:identifier="nm_setting_wireless_get_channel">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:channel property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_cloned_mac_address"
              c:identifier="nm_setting_wireless_get_cloned_mac_address">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:cloned-mac-address property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_generate_mac_address_mask"
              c:identifier="nm_setting_wireless_get_generate_mac_address_mask"
              version="1.4">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:generate-mac-address-mask property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hidden" c:identifier="nm_setting_wireless_get_hidden">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:hidden property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mac_address"
              c:identifier="nm_setting_wireless_get_mac_address">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:mac-address property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mac_address_blacklist"
              c:identifier="nm_setting_wireless_get_mac_address_blacklist">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:mac-address-blacklist property of the setting</doc>
          <array c:type="const char* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mac_address_randomization"
              c:identifier="nm_setting_wireless_get_mac_address_randomization"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:mac-address-randomization property of the
setting</doc>
          <type name="SettingMacRandomization"
                c:type="NMSettingMacRandomization"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mac_blacklist_item"
              c:identifier="nm_setting_wireless_get_mac_blacklist_item">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the blacklisted MAC address string (hex-digits-and-colons notation)
at index @idx</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">the zero-based index of the MAC address entry</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_mode" c:identifier="nm_setting_wireless_get_mode">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:mode property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mtu" c:identifier="nm_setting_wireless_get_mtu">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:mtu property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_mac_blacklist_items"
              c:identifier="nm_setting_wireless_get_num_mac_blacklist_items">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of blacklisted MAC addresses</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_seen_bssids"
              c:identifier="nm_setting_wireless_get_num_seen_bssids">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of BSSIDs in the previously seen BSSID list</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_powersave"
              c:identifier="nm_setting_wireless_get_powersave"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:powersave property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_rate" c:identifier="nm_setting_wireless_get_rate">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:rate property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_seen_bssid"
              c:identifier="nm_setting_wireless_get_seen_bssid">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the BSSID at index @i</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">index of a BSSID in the previously seen BSSID list</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_ssid" c:identifier="nm_setting_wireless_get_ssid">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:ssid property of the setting</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tx_power"
              c:identifier="nm_setting_wireless_get_tx_power">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:tx-power property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_mac_blacklist_item"
              c:identifier="nm_setting_wireless_remove_mac_blacklist_item">
        <doc xml:space="preserve">Removes the MAC address at index @idx from the blacklist.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index number of the MAC address</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_mac_blacklist_item_by_value"
              c:identifier="nm_setting_wireless_remove_mac_blacklist_item_by_value">
        <doc xml:space="preserve">Removes the MAC address @mac from the blacklist.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the MAC address was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
          <parameter name="mac" transfer-ownership="none">
            <doc xml:space="preserve">the MAC address string (hex-digits-and-colons notation) to remove from
the blacklist</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="band" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">802.11 frequency band of the network.  One of "a" for 5GHz 802.11a or
"bg" for 2.4GHz 802.11.  This will lock associations to the Wi-Fi network
to the specific band, i.e. if "a" is specified, the device will not
associate with the same network in the 2.4GHz band even if the network's
settings are compatible.  This setting depends on specific driver
capability and may not work with all drivers.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="bssid" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">If specified, directs the device to only associate with the given access
point.  This capability is highly driver dependent and not supported by
all devices.  Note: this property does not control the BSSID used when
creating an Ad-Hoc network and is unlikely to in the future.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="channel"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Wireless channel to use for the Wi-Fi connection.  The device will only
join (or create for Ad-Hoc networks) a Wi-Fi network on the specified
channel.  Because channel numbers overlap between bands, this property
also requires the "band" property to be set.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="cloned-mac-address"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If specified, request that the device use this MAC address instead.
This is known as MAC cloning or spoofing.

Beside explicitly specifing a MAC address, the special values "preserve", "permanent",
"random" and "stable" are supported.
"preserve" means not to touch the MAC address on activation.
"permanent" means to use the permanent hardware address of the device.
"random" creates a random MAC address on each connect.
"stable" creates a hashed MAC address based on connection.stable-id and a
machine dependent key.

If unspecified, the value can be overwritten via global defaults, see manual
of NetworkManager.conf. If still unspecified, it defaults to "preserve"
(older versions of NetworkManager may use a different default value).

On D-Bus, this field is expressed as "assigned-mac-address" or the deprecated
"cloned-mac-address".</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="generate-mac-address-mask"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">With #NMSettingWireless:cloned-mac-address setting "random" or "stable",
by default all bits of the MAC address are scrambled and a locally-administered,
unicast MAC address is created. This property allows to specify that certain bits
are fixed. Note that the least significant bit of the first MAC address will
always be unset to create a unicast MAC address.

If the property is %NULL, it is eligible to be overwritten by a default
connection setting. If the value is still %NULL or an empty string, the
default is to create a locally-administered, unicast MAC address.

If the value contains one MAC address, this address is used as mask. The set
bits of the mask are to be filled with the current MAC address of the device,
while the unset bits are subject to randomization.
Setting "FE:FF:FF:00:00:00" means to preserve the OUI of the current MAC address
and only randomize the lower 3 bytes using the "random" or "stable" algorithm.

If the value contains one additional MAC address after the mask,
this address is used instead of the current MAC address to fill the bits
that shall not be randomized. For example, a value of
"FE:FF:FF:00:00:00 68:F7:28:00:00:00" will set the OUI of the MAC address
to 68:F7:28, while the lower bits are randomized. A value of
"02:00:00:00:00:00 00:00:00:00:00:00" will create a fully scrambled
globally-administered, burned-in MAC address.

If the value contains more then one additional MAC addresses, one of
them is chosen randomly. For example, "02:00:00:00:00:00 00:00:00:00:00:00 02:00:00:00:00:00"
will create a fully scrambled MAC address, randomly locally or globally
administered.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="hidden" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, indicates this network is a non-broadcasting network that hides
its SSID.  In this case various workarounds may take place, such as
probe-scanning the SSID for more reliable network discovery.  However,
these workarounds expose inherent insecurities with hidden SSID networks,
and thus hidden SSID networks should be used with caution.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="mac-address" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">If specified, this connection will only apply to the Wi-Fi device whose
permanent MAC address matches. This property does not change the MAC
address of the device (i.e. MAC spoofing).</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="mac-address-blacklist"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A list of permanent MAC addresses of Wi-Fi devices to which this
connection should never apply.  Each MAC address should be given in the
standard hex-digits-and-colons notation (eg "00:11:22:33:44:55").</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="mac-address-randomization"
                version="1.2"
                deprecated="1"
                deprecated-version="1.4"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">One of %NM_SETTING_MAC_RANDOMIZATION_DEFAULT (never randomize unless
the user has set a global default to randomize and the supplicant
supports randomization),  %NM_SETTING_MAC_RANDOMIZATION_NEVER (never
randomize the MAC address), or %NM_SETTING_MAC_RANDOMIZATION_ALWAYS
(always randomize the MAC address). This property is deprecated for
'cloned-mac-address'.</doc>
        <doc-deprecated xml:space="preserve">Deprecated by NMSettingWireless:cloned-mac-address property</doc-deprecated>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="mode" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Wi-Fi network mode; one of "infrastructure", "adhoc" or "ap".  If blank,
infrastructure is assumed.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="mtu"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-zero, only transmit packets of the specified size or smaller,
breaking larger packets up into multiple Ethernet frames.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="powersave"
                version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">One of %NM_SETTING_WIRELESS_POWERSAVE_DISABLE (disable Wi-Fi power
saving), %NM_SETTING_WIRELESS_POWERSAVE_ENABLE (enable Wi-Fi power
saving), %NM_SETTING_WIRELESS_POWERSAVE_IGNORE (don't touch currently
configure setting) or %NM_SETTING_WIRELESS_POWERSAVE_DEFAULT (use the
globally configured value). All other values are reserved.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="rate"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-zero, directs the device to only use the specified bitrate for
communication with the access point.  Units are in Kb/s, ie 5500 = 5.5
Mbit/s.  This property is highly driver dependent and not all devices
support setting a static bitrate.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="seen-bssids" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">A list of BSSIDs (each BSSID formatted as a MAC address like
"00:11:22:33:44:55") that have been detected as part of the Wi-Fi
network.  NetworkManager internally tracks previously seen BSSIDs. The
property is only meant for reading and reflects the BSSID list of
NetworkManager. The changes you make to this property will not be
preserved.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="ssid" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">SSID of the Wi-Fi network. Must be specified.</doc>
        <type name="GLib.Bytes"/>
      </property>
      <property name="tx-power"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-zero, directs the device to use the specified transmit power.
Units are dBm.  This property is highly driver dependent and not all
devices support setting a static transmit power.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingWirelessClass"
            c:type="NMSettingWirelessClass"
            glib:is-gtype-struct-for="SettingWireless">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="SettingWirelessPowersave"
                 glib:type-name="NMSettingWirelessPowersave"
                 glib:get-type="nm_setting_wireless_powersave_get_type"
                 c:type="NMSettingWirelessPowersave">
      <doc xml:space="preserve">These flags indicate whether wireless powersave must be enabled.</doc>
      <member name="default"
              value="0"
              c:identifier="NM_SETTING_WIRELESS_POWERSAVE_DEFAULT"
              glib:nick="default">
        <doc xml:space="preserve">use the default value</doc>
      </member>
      <member name="ignore"
              value="1"
              c:identifier="NM_SETTING_WIRELESS_POWERSAVE_IGNORE"
              glib:nick="ignore">
        <doc xml:space="preserve">don't touch existing setting</doc>
      </member>
      <member name="disable"
              value="2"
              c:identifier="NM_SETTING_WIRELESS_POWERSAVE_DISABLE"
              glib:nick="disable">
        <doc xml:space="preserve">disable powersave</doc>
      </member>
      <member name="enable"
              value="3"
              c:identifier="NM_SETTING_WIRELESS_POWERSAVE_ENABLE"
              glib:nick="enable">
        <doc xml:space="preserve">enable powersave</doc>
      </member>
    </enumeration>
    <class name="SettingWirelessSecurity"
           c:symbol-prefix="setting_wireless_security"
           c:type="NMSettingWirelessSecurity"
           parent="Setting"
           glib:type-name="NMSettingWirelessSecurity"
           glib:get-type="nm_setting_wireless_security_get_type"
           glib:type-struct="SettingWirelessSecurityClass">
      <doc xml:space="preserve">Wi-Fi Security Settings</doc>
      <constructor name="new" c:identifier="nm_setting_wireless_security_new">
        <doc xml:space="preserve">Creates a new #NMSettingWirelessSecurity object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingWirelessSecurity object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="add_group"
              c:identifier="nm_setting_wireless_security_add_group">
        <doc xml:space="preserve">Adds an encryption algorithm to the list of allowed groupwise encryption
algorithms.  If the list is not empty, then only access points that support
one or more of the encryption algorithms in the list will be considered
compatible with this connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the algorithm was added to the list, %FALSE if it was
already in the list</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">the encryption algorithm to add, one of "wep40", "wep104",
"tkip", or "ccmp"</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_pairwise"
              c:identifier="nm_setting_wireless_security_add_pairwise">
        <doc xml:space="preserve">Adds an encryption algorithm to the list of allowed pairwise encryption
algorithms.  If the list is not empty, then only access points that support
one or more of the encryption algorithms in the list will be considered
compatible with this connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the algorithm was added to the list, %FALSE if it was
already in the list</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="pairwise" transfer-ownership="none">
            <doc xml:space="preserve">the encryption algorithm to add, one of "tkip" or "ccmp"</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_proto"
              c:identifier="nm_setting_wireless_security_add_proto">
        <doc xml:space="preserve">Adds a Wi-Fi security protocol (one of "wpa" or "rsn") to the allowed list;
only protocols in this list will be used when finding and connecting to
the Wi-Fi network specified by this connection.  For example, if the
protocol list contains only "wpa" but the access point for the SSID specified
by this connection only supports WPA2/RSN, the connection cannot be used
with the access point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the protocol was new and was added to the allowed
protocol list, or %FALSE if it was already in the list</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="proto" transfer-ownership="none">
            <doc xml:space="preserve">the protocol to add, one of "wpa" or "rsn"</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_groups"
              c:identifier="nm_setting_wireless_security_clear_groups">
        <doc xml:space="preserve">Removes all algorithms from the allowed list.  If there are no algorithms
specified then all groupwise encryption algorithms are allowed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear_pairwise"
              c:identifier="nm_setting_wireless_security_clear_pairwise">
        <doc xml:space="preserve">Removes all algorithms from the allowed list.  If there are no algorithms
specified then all pairwise encryption algorithms are allowed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear_protos"
              c:identifier="nm_setting_wireless_security_clear_protos">
        <doc xml:space="preserve">Removes all protocols from the allowed list.  If there are no protocols
specified then all protocols are allowed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_auth_alg"
              c:identifier="nm_setting_wireless_security_get_auth_alg">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWirelessSecurity:auth-alg property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_group"
              c:identifier="nm_setting_wireless_security_get_group">
        <doc xml:space="preserve">Returns the allowed groupwise encryption algorithm from allowed algorithm
list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the groupwise encryption algorithm at index @i</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">index of an item in the allowed groupwise encryption algorithm list</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_key_mgmt"
              c:identifier="nm_setting_wireless_security_get_key_mgmt">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWirelessSecurity:key-mgmt property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_leap_password"
              c:identifier="nm_setting_wireless_security_get_leap_password">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWirelessSecurity:leap-password property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_leap_password_flags"
              c:identifier="nm_setting_wireless_security_get_leap_password_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the
#NMSettingWirelessSecurity:leap-password</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_leap_username"
              c:identifier="nm_setting_wireless_security_get_leap_username">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWirelessSecurity:leap-username property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_groups"
              c:identifier="nm_setting_wireless_security_get_num_groups">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of groupwise encryption algorithms in the allowed list</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_pairwise"
              c:identifier="nm_setting_wireless_security_get_num_pairwise">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of pairwise encryption algorithms in the allowed list</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_protos"
              c:identifier="nm_setting_wireless_security_get_num_protos">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of security protocols this connection allows when
connecting to secure Wi-Fi networks</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pairwise"
              c:identifier="nm_setting_wireless_security_get_pairwise">
        <doc xml:space="preserve">Returns the allowed pairwise encryption algorithm from allowed algorithm
list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the pairwise encryption algorithm at index @i</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">index of an item in the allowed pairwise encryption algorithm list</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_proto"
              c:identifier="nm_setting_wireless_security_get_proto">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the protocol at index @i</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">an index into the protocol list</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_psk"
              c:identifier="nm_setting_wireless_security_get_psk">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWirelessSecurity:psk property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_psk_flags"
              c:identifier="nm_setting_wireless_security_get_psk_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the
#NMSettingWirelessSecurity:psk</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_wep_key"
              c:identifier="nm_setting_wireless_security_get_wep_key">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the WEP key at the given index</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">the WEP key index (0..3 inclusive)</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_wep_key_flags"
              c:identifier="nm_setting_wireless_security_get_wep_key_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the all WEP keys</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_wep_key_type"
              c:identifier="nm_setting_wireless_security_get_wep_key_type">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWirelessSecurity:wep-key-type property of the setting</doc>
          <type name="WepKeyType" c:type="NMWepKeyType"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_wep_tx_keyidx"
              c:identifier="nm_setting_wireless_security_get_wep_tx_keyidx">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWirelessSecurity:wep-tx-keyidx property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_group"
              c:identifier="nm_setting_wireless_security_remove_group">
        <doc xml:space="preserve">Removes an encryption algorithm from the allowed groupwise encryption
algorithm list.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">the index of an item in the allowed groupwise encryption algorithm list</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_group_by_value"
              c:identifier="nm_setting_wireless_security_remove_group_by_value">
        <doc xml:space="preserve">Removes an encryption algorithm from the allowed groupwise encryption
algorithm list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the algorithm was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">the encryption algorithm to remove, one of "wep40", "wep104",
"tkip", or "ccmp"</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_pairwise"
              c:identifier="nm_setting_wireless_security_remove_pairwise">
        <doc xml:space="preserve">Removes an encryption algorithm from the allowed pairwise encryption
algorithm list.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">the index of an item in the allowed pairwise encryption algorithm list</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_pairwise_by_value"
              c:identifier="nm_setting_wireless_security_remove_pairwise_by_value">
        <doc xml:space="preserve">Removes an encryption algorithm from the allowed pairwise encryption
algorithm list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the encryption algorith was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="pairwise" transfer-ownership="none">
            <doc xml:space="preserve">the encryption algorithm to remove, one of "tkip" or "ccmp"</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_proto"
              c:identifier="nm_setting_wireless_security_remove_proto">
        <doc xml:space="preserve">Removes a protocol from the allowed protocol list.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">index of the protocol to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_proto_by_value"
              c:identifier="nm_setting_wireless_security_remove_proto_by_value">
        <doc xml:space="preserve">Removes a protocol from the allowed protocol list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the protocol was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="proto" transfer-ownership="none">
            <doc xml:space="preserve">the protocol to remove, one of "wpa" or "rsn"</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_wep_key"
              c:identifier="nm_setting_wireless_security_set_wep_key">
        <doc xml:space="preserve">Sets a WEP key in the given index.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">the index of the key (0..3 inclusive)</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the WEP key as a string, in either hexadecimal, ASCII, or passphrase
form as determiend by the value of the #NMSettingWirelessSecurity:wep-key-type
property.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="auth-alg" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">When WEP is used (ie, key-mgmt = "none" or "ieee8021x") indicate the
802.11 authentication algorithm required by the AP here.  One of "open"
for Open System, "shared" for Shared Key, or "leap" for Cisco LEAP.  When
using Cisco LEAP (ie, key-mgmt = "ieee8021x" and auth-alg = "leap") the
"leap-username" and "leap-password" properties must be specified.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="group" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">A list of group/broadcast encryption algorithms which prevents
connections to Wi-Fi networks that do not utilize one of the algorithms
in the list.  For maximum compatibility leave this property empty.  Each
list element may be one of "wep40", "wep104", "tkip", or "ccmp".</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="key-mgmt" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Key management used for the connection.  One of "none" (WEP), "ieee8021x"
(Dynamic WEP), "wpa-none" (Ad-Hoc WPA-PSK), "wpa-psk" (infrastructure
WPA-PSK), or "wpa-eap" (WPA-Enterprise).  This property must be set for
any Wi-Fi connection that uses security.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="leap-password" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The login password for legacy LEAP connections (ie, key-mgmt =
"ieee8021x" and auth-alg = "leap").</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="leap-password-flags"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the
#NMSettingWirelessSecurity:leap-password property.</doc>
        <type name="SettingSecretFlags"/>
      </property>
      <property name="leap-username" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The login username for legacy LEAP connections (ie, key-mgmt =
"ieee8021x" and auth-alg = "leap").</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="pairwise" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">A list of pairwise encryption algorithms which prevents connections to
Wi-Fi networks that do not utilize one of the algorithms in the list.
For maximum compatibility leave this property empty.  Each list element
may be one of "tkip" or "ccmp".</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="proto" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">List of strings specifying the allowed WPA protocol versions to use.
Each element may be one "wpa" (allow WPA) or "rsn" (allow WPA2/RSN).  If
not specified, both WPA and RSN connections are allowed.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="psk" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Pre-Shared-Key for WPA networks.  If the key is 64-characters long, it
must contain only hexadecimal characters and is interpreted as a
hexadecimal WPA key.  Otherwise, the key must be between 8 and 63 ASCII
characters (as specified in the 802.11i standard) and is interpreted as a
WPA passphrase, and is hashed to derive the actual WPA-PSK used when
connecting to the Wi-Fi network.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="psk-flags" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSettingWirelessSecurity:psk
property.</doc>
        <type name="SettingSecretFlags"/>
      </property>
      <property name="wep-key-flags" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSettingWirelessSecurity:wep-key0,
#NMSettingWirelessSecurity:wep-key1, #NMSettingWirelessSecurity:wep-key2,
and #NMSettingWirelessSecurity:wep-key3 properties.</doc>
        <type name="SettingSecretFlags"/>
      </property>
      <property name="wep-key-type"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Controls the interpretation of WEP keys.  Allowed values are
%NM_WEP_KEY_TYPE_KEY, in which case the key is either a 10- or
26-character hexadecimal string, or a 5- or 13-character ASCII password;
or %NM_WEP_KEY_TYPE_PASSPHRASE, in which case the passphrase is provided
as a string and will be hashed using the de-facto MD5 method to derive
the actual WEP key.</doc>
        <type name="WepKeyType"/>
      </property>
      <property name="wep-key0" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Index 0 WEP key.  This is the WEP key used in most networks.  See the
"wep-key-type" property for a description of how this key is interpreted.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="wep-key1" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Index 1 WEP key.  This WEP index is not used by most networks.  See the
"wep-key-type" property for a description of how this key is interpreted.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="wep-key2" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Index 2 WEP key.  This WEP index is not used by most networks.  See the
"wep-key-type" property for a description of how this key is interpreted.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="wep-key3" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Index 3 WEP key.  This WEP index is not used by most networks.  See the
"wep-key-type" property for a description of how this key is interpreted.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="wep-tx-keyidx"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">When static WEP is used (ie, key-mgmt = "none") and a non-default WEP key
index is used by the AP, put that WEP key index here.  Valid values are 0
(default key) through 3.  Note that some consumer access points (like the
Linksys WRT54G) number the keys 1 - 4.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingWirelessSecurityClass"
            c:type="NMSettingWirelessSecurityClass"
            glib:is-gtype-struct-for="SettingWirelessSecurity">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="SettingsError"
                 glib:type-name="NMSettingsError"
                 glib:get-type="nm_settings_error_get_type"
                 c:type="NMSettingsError"
                 glib:error-domain="nm-settings-error-quark">
      <doc xml:space="preserve">Errors related to the settings/persistent configuration interface of
NetworkManager.

These may be returned from #NMClient methods that invoke D-Bus operations on
the "org.freedesktop.NetworkManager.Settings" interface, and correspond to
D-Bus errors in that namespace.</doc>
      <member name="Failed"
              value="0"
              c:identifier="NM_SETTINGS_ERROR_FAILED"
              glib:nick="Failed">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="PermissionDenied"
              value="1"
              c:identifier="NM_SETTINGS_ERROR_PERMISSION_DENIED"
              glib:nick="PermissionDenied">
        <doc xml:space="preserve">permission denied</doc>
      </member>
      <member name="NotSupported"
              value="2"
              c:identifier="NM_SETTINGS_ERROR_NOT_SUPPORTED"
              glib:nick="NotSupported">
        <doc xml:space="preserve">the requested operation is not supported by any
  active settings backend</doc>
      </member>
      <member name="InvalidConnection"
              value="3"
              c:identifier="NM_SETTINGS_ERROR_INVALID_CONNECTION"
              glib:nick="InvalidConnection">
        <doc xml:space="preserve">the connection was invalid</doc>
      </member>
      <member name="ReadOnlyConnection"
              value="4"
              c:identifier="NM_SETTINGS_ERROR_READ_ONLY_CONNECTION"
              glib:nick="ReadOnlyConnection">
        <doc xml:space="preserve">attempted to modify a read-only connection</doc>
      </member>
      <member name="UuidExists"
              value="5"
              c:identifier="NM_SETTINGS_ERROR_UUID_EXISTS"
              glib:nick="UuidExists">
        <doc xml:space="preserve">a connection with that UUID already exists</doc>
      </member>
      <member name="InvalidHostname"
              value="6"
              c:identifier="NM_SETTINGS_ERROR_INVALID_HOSTNAME"
              glib:nick="InvalidHostname">
        <doc xml:space="preserve">attempted to set an invalid hostname</doc>
      </member>
      <function name="quark" c:identifier="nm_settings_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SimpleConnection"
           c:symbol-prefix="simple_connection"
           c:type="NMSimpleConnection"
           parent="GObject.Object"
           glib:type-name="NMSimpleConnection"
           glib:get-type="nm_simple_connection_get_type"
           glib:type-struct="SimpleConnectionClass">
      <implements name="Connection"/>
      <function name="new" c:identifier="nm_simple_connection_new">
        <doc xml:space="preserve">Creates a new #NMSimpleConnection object with no #NMSetting objects. An
#NMSimpleConnection does not directly represent a D-Bus-exported connection,
but might be used in the process of creating a new one.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMConnection object</doc>
          <type name="Connection" c:type="NMConnection*"/>
        </return-value>
      </function>
      <function name="new_clone" c:identifier="nm_simple_connection_new_clone">
        <doc xml:space="preserve">Clones an #NMConnection as an #NMSimpleConnection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #NMConnection containing the same settings
and properties as the source #NMConnection</doc>
          <type name="Connection" c:type="NMConnection*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection to clone</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_from_dbus"
                c:identifier="nm_simple_connection_new_from_dbus"
                throws="1">
        <doc xml:space="preserve">Creates a new #NMSimpleConnection from a hash table describing the
connection and normalize the connection.  See nm_connection_to_dbus() for a
description of the expected hash table.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #NMSimpleConnection object, populated with
settings created from the values in the hash table, or %NULL if the
connection failed to normalize.</doc>
          <type name="Connection" c:type="NMConnection*"/>
        </return-value>
        <parameters>
          <parameter name="dict" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant of type %NM_VARIANT_TYPE_CONNECTION describing the connection</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </function>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="SimpleConnectionClass"
            c:type="NMSimpleConnectionClass"
            glib:is-gtype-struct-for="SimpleConnection">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="State"
                 glib:type-name="NMState"
                 glib:get-type="nm_state_get_type"
                 c:type="NMState">
      <doc xml:space="preserve">#NMState values indicate the current overall networking state.</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_STATE_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">Networking state is unknown. This indicates a daemon error
   that makes it unable to reasonably assess the state. In such event the
   applications are expected to assume Internet connectivity might be present
   and not disable controls that require network access.
   The graphical shells may hide the network accessibility indicator altogether
   since no meaningful status indication can be provided.</doc>
      </member>
      <member name="asleep"
              value="10"
              c:identifier="NM_STATE_ASLEEP"
              glib:nick="asleep">
        <doc xml:space="preserve">Networking is not enabled, the system is being suspended or
   resumed from suspend.</doc>
      </member>
      <member name="disconnected"
              value="20"
              c:identifier="NM_STATE_DISCONNECTED"
              glib:nick="disconnected">
        <doc xml:space="preserve">There is no active network connection.
   The graphical shell should indicate  no network connectivity and the
   applications should not attempt to access the network.</doc>
      </member>
      <member name="disconnecting"
              value="30"
              c:identifier="NM_STATE_DISCONNECTING"
              glib:nick="disconnecting">
        <doc xml:space="preserve">Network connections are being cleaned up.
   The applications should tear down their network sessions.</doc>
      </member>
      <member name="connecting"
              value="40"
              c:identifier="NM_STATE_CONNECTING"
              glib:nick="connecting">
        <doc xml:space="preserve">A network connection is being started
   The graphical shell should indicate the network is being connected while
   the applications should still make no attempts to connect the network.</doc>
      </member>
      <member name="connected_local"
              value="50"
              c:identifier="NM_STATE_CONNECTED_LOCAL"
              glib:nick="connected-local">
        <doc xml:space="preserve">There is only local IPv4 and/or IPv6 connectivity,
   but no default route to access the Internet. The graphical shell should
   indicate no network connectivity.</doc>
      </member>
      <member name="connected_site"
              value="60"
              c:identifier="NM_STATE_CONNECTED_SITE"
              glib:nick="connected-site">
        <doc xml:space="preserve">There is only site-wide IPv4 and/or IPv6 connectivity.
   This means a default route is available, but the Internet connectivity check
   (see "Connectivity" property) did not succeed. The graphical shell should
   indicate limited network connectivity.</doc>
      </member>
      <member name="connected_global"
              value="70"
              c:identifier="NM_STATE_CONNECTED_GLOBAL"
              glib:nick="connected-global">
        <doc xml:space="preserve">There is global IPv4 and/or IPv6 Internet connectivity
   This means the Internet connectivity check succeeded, the graphical shell should
   indicate full network connectivity.</doc>
      </member>
    </enumeration>
    <constant name="UTILS_HWADDR_LEN_MAX"
              value="20"
              c:type="NM_UTILS_HWADDR_LEN_MAX">
      <doc xml:space="preserve">The maximum length of hardware addresses handled by NetworkManager itself,
nm_utils_hwaddr_len(), and nm_utils_hwaddr_aton().</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <callback name="UtilsCheckFilePredicate"
              c:type="NMUtilsCheckFilePredicate"
              throws="1">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="stat"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="const stat*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="UtilsFileSearchInPathsPredicate"
              c:type="NMUtilsFileSearchInPathsPredicate">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="1">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="UtilsSecurityType"
                 glib:type-name="NMUtilsSecurityType"
                 glib:get-type="nm_utils_security_type_get_type"
                 c:type="NMUtilsSecurityType">
      <doc xml:space="preserve">Describes generic security mechanisms that 802.11 access points may offer.
Used with nm_utils_security_valid() for checking whether a given access
point is compatible with a network device.</doc>
      <member name="invalid"
              value="0"
              c:identifier="NMU_SEC_INVALID"
              glib:nick="invalid">
        <doc xml:space="preserve">unknown or invalid security, placeholder and not used</doc>
      </member>
      <member name="none"
              value="1"
              c:identifier="NMU_SEC_NONE"
              glib:nick="none">
        <doc xml:space="preserve">unencrypted and open</doc>
      </member>
      <member name="static_wep"
              value="2"
              c:identifier="NMU_SEC_STATIC_WEP"
              glib:nick="static-wep">
        <doc xml:space="preserve">static WEP keys are used for encryption</doc>
      </member>
      <member name="leap"
              value="3"
              c:identifier="NMU_SEC_LEAP"
              glib:nick="leap">
        <doc xml:space="preserve">Cisco LEAP is used for authentication and for generating the
dynamic WEP keys automatically</doc>
      </member>
      <member name="dynamic_wep"
              value="4"
              c:identifier="NMU_SEC_DYNAMIC_WEP"
              glib:nick="dynamic-wep">
        <doc xml:space="preserve">standard 802.1x is used for authentication and
generating the dynamic WEP keys automatically</doc>
      </member>
      <member name="wpa_psk"
              value="5"
              c:identifier="NMU_SEC_WPA_PSK"
              glib:nick="wpa-psk">
        <doc xml:space="preserve">WPA1 is used with Pre-Shared Keys (PSK)</doc>
      </member>
      <member name="wpa_enterprise"
              value="6"
              c:identifier="NMU_SEC_WPA_ENTERPRISE"
              glib:nick="wpa-enterprise">
        <doc xml:space="preserve">WPA1 is used with 802.1x authentication</doc>
      </member>
      <member name="wpa2_psk"
              value="7"
              c:identifier="NMU_SEC_WPA2_PSK"
              glib:nick="wpa2-psk">
        <doc xml:space="preserve">WPA2/RSN is used with Pre-Shared Keys (PSK)</doc>
      </member>
      <member name="wpa2_enterprise"
              value="8"
              c:identifier="NMU_SEC_WPA2_ENTERPRISE"
              glib:nick="wpa2-enterprise">
        <doc xml:space="preserve">WPA2 is used with 802.1x authentication</doc>
      </member>
    </enumeration>
    <constant name="VLAN_FLAGS_ALL" value="0" c:type="NM_VLAN_FLAGS_ALL">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="VPN_CONNECTION_BANNER"
              value="banner"
              c:type="NM_VPN_CONNECTION_BANNER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_CONNECTION_VPN_STATE"
              value="vpn-state"
              c:type="NM_VPN_CONNECTION_VPN_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_DBUS_PLUGIN_INTERFACE"
              value="org.freedesktop.NetworkManager.VPN.Plugin"
              c:type="NM_VPN_DBUS_PLUGIN_INTERFACE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_DBUS_PLUGIN_PATH"
              value="/org/freedesktop/NetworkManager/VPN/Plugin"
              c:type="NM_VPN_DBUS_PLUGIN_PATH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_EDITOR_PLUGIN_DESCRIPTION"
              value="description"
              c:type="NM_VPN_EDITOR_PLUGIN_DESCRIPTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_EDITOR_PLUGIN_NAME"
              value="name"
              c:type="NM_VPN_EDITOR_PLUGIN_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_EDITOR_PLUGIN_SERVICE"
              value="service"
              c:type="NM_VPN_EDITOR_PLUGIN_SERVICE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_CAN_PERSIST"
              value="can-persist"
              c:type="NM_VPN_PLUGIN_CAN_PERSIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_CONFIG_BANNER"
              value="banner"
              c:type="NM_VPN_PLUGIN_CONFIG_BANNER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_CONFIG_EXT_GATEWAY"
              value="gateway"
              c:type="NM_VPN_PLUGIN_CONFIG_EXT_GATEWAY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_CONFIG_HAS_IP4"
              value="has-ip4"
              c:type="NM_VPN_PLUGIN_CONFIG_HAS_IP4">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_CONFIG_HAS_IP6"
              value="has-ip6"
              c:type="NM_VPN_PLUGIN_CONFIG_HAS_IP6">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_CONFIG_MTU"
              value="mtu"
              c:type="NM_VPN_PLUGIN_CONFIG_MTU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_CONFIG_PROXY_PAC"
              value="pac"
              c:type="NM_VPN_PLUGIN_CONFIG_PROXY_PAC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_CONFIG_TUNDEV"
              value="tundev"
              c:type="NM_VPN_PLUGIN_CONFIG_TUNDEV">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_INFO_FILENAME"
              value="filename"
              c:type="NM_VPN_PLUGIN_INFO_FILENAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_INFO_KEYFILE"
              value="keyfile"
              c:type="NM_VPN_PLUGIN_INFO_KEYFILE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_INFO_KF_GROUP_CONNECTION"
              value="VPN Connection"
              c:type="NM_VPN_PLUGIN_INFO_KF_GROUP_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_INFO_KF_GROUP_GNOME"
              value="GNOME"
              c:type="NM_VPN_PLUGIN_INFO_KF_GROUP_GNOME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_INFO_KF_GROUP_LIBNM"
              value="libnm"
              c:type="NM_VPN_PLUGIN_INFO_KF_GROUP_LIBNM">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_INFO_NAME"
              value="name"
              c:type="NM_VPN_PLUGIN_INFO_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_ADDRESS"
              value="address"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_DNS"
              value="dns"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_DNS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_DOMAIN"
              value="domain"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_DOMAIN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_DOMAINS"
              value="domains"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_DOMAINS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_INT_GATEWAY"
              value="internal-gateway"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_INT_GATEWAY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_MSS"
              value="mss"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_MSS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_NBNS"
              value="nbns"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_NBNS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_NEVER_DEFAULT"
              value="never-default"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_NEVER_DEFAULT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_PREFIX"
              value="prefix"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_PREFIX">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_PRESERVE_ROUTES"
              value="preserve-routes"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_PRESERVE_ROUTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_PTP"
              value="ptp"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_PTP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_ROUTES"
              value="routes"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_ROUTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP6_CONFIG_ADDRESS"
              value="address"
              c:type="NM_VPN_PLUGIN_IP6_CONFIG_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP6_CONFIG_DNS"
              value="dns"
              c:type="NM_VPN_PLUGIN_IP6_CONFIG_DNS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP6_CONFIG_DOMAIN"
              value="domain"
              c:type="NM_VPN_PLUGIN_IP6_CONFIG_DOMAIN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP6_CONFIG_DOMAINS"
              value="domains"
              c:type="NM_VPN_PLUGIN_IP6_CONFIG_DOMAINS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP6_CONFIG_INT_GATEWAY"
              value="internal-gateway"
              c:type="NM_VPN_PLUGIN_IP6_CONFIG_INT_GATEWAY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP6_CONFIG_MSS"
              value="mss"
              c:type="NM_VPN_PLUGIN_IP6_CONFIG_MSS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP6_CONFIG_NEVER_DEFAULT"
              value="never-default"
              c:type="NM_VPN_PLUGIN_IP6_CONFIG_NEVER_DEFAULT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP6_CONFIG_PREFIX"
              value="prefix"
              c:type="NM_VPN_PLUGIN_IP6_CONFIG_PREFIX">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP6_CONFIG_PRESERVE_ROUTES"
              value="preserve-routes"
              c:type="NM_VPN_PLUGIN_IP6_CONFIG_PRESERVE_ROUTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP6_CONFIG_PTP"
              value="ptp"
              c:type="NM_VPN_PLUGIN_IP6_CONFIG_PTP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP6_CONFIG_ROUTES"
              value="routes"
              c:type="NM_VPN_PLUGIN_IP6_CONFIG_ROUTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_OLD_DBUS_SERVICE_NAME"
              value="service-name"
              c:type="NM_VPN_PLUGIN_OLD_DBUS_SERVICE_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_OLD_STATE"
              value="state"
              c:type="NM_VPN_PLUGIN_OLD_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_SERVICE_PLUGIN_DBUS_SERVICE_NAME"
              value="service-name"
              c:type="NM_VPN_SERVICE_PLUGIN_DBUS_SERVICE_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_SERVICE_PLUGIN_DBUS_WATCH_PEER"
              value="watch-peer"
              c:type="NM_VPN_SERVICE_PLUGIN_DBUS_WATCH_PEER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_SERVICE_PLUGIN_STATE"
              value="state"
              c:type="NM_VPN_SERVICE_PLUGIN_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <record name="VariantAttributeSpec"
            c:type="NMVariantAttributeSpec"
            disguised="1">
    </record>
    <bitfield name="VlanFlags"
              glib:type-name="NMVlanFlags"
              glib:get-type="nm_vlan_flags_get_type"
              c:type="NMVlanFlags">
      <doc xml:space="preserve">#NMVlanFlags values control the behavior of the VLAN interface.</doc>
      <member name="reorder_headers"
              value="1"
              c:identifier="NM_VLAN_FLAG_REORDER_HEADERS"
              glib:nick="reorder-headers">
        <doc xml:space="preserve">indicates that this interface should reorder
 outgoing packet headers to look more like a non-VLAN Ethernet interface</doc>
      </member>
      <member name="gvrp"
              value="2"
              c:identifier="NM_VLAN_FLAG_GVRP"
              glib:nick="gvrp">
        <doc xml:space="preserve">indicates that this interface should use GVRP to register
 itself with it's switch</doc>
      </member>
      <member name="loose_binding"
              value="4"
              c:identifier="NM_VLAN_FLAG_LOOSE_BINDING"
              glib:nick="loose-binding">
        <doc xml:space="preserve">indicates that this interface's operating
 state is tied to the underlying network interface but other details
 (like routing) are not.</doc>
      </member>
      <member name="mvrp"
              value="8"
              c:identifier="NM_VLAN_FLAG_MVRP"
              glib:nick="mvrp">
        <doc xml:space="preserve">indicates that this interface should use MVRP to register
 itself with it's switch</doc>
      </member>
    </bitfield>
    <enumeration name="VlanPriorityMap"
                 glib:type-name="NMVlanPriorityMap"
                 glib:get-type="nm_vlan_priority_map_get_type"
                 c:type="NMVlanPriorityMap">
      <doc xml:space="preserve">A selector for traffic priority maps; these map Linux SKB priorities
to 802.1p priorities used in VLANs.</doc>
      <member name="ingress_map"
              value="0"
              c:identifier="NM_VLAN_INGRESS_MAP"
              glib:nick="ingress-map">
        <doc xml:space="preserve">map for incoming data</doc>
      </member>
      <member name="egress_map"
              value="1"
              c:identifier="NM_VLAN_EGRESS_MAP"
              glib:nick="egress-map">
        <doc xml:space="preserve">map for outgoing data</doc>
      </member>
    </enumeration>
    <class name="VpnConnection"
           c:symbol-prefix="vpn_connection"
           c:type="NMVpnConnection"
           parent="ActiveConnection"
           glib:type-name="NMVpnConnection"
           glib:get-type="nm_vpn_connection_get_type"
           glib:type-struct="VpnConnectionClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <virtual-method name="vpn_state_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <type name="VpnConnection" c:type="NMVpnConnection*"/>
          </instance-parameter>
          <parameter name="state" transfer-ownership="none">
            <type name="VpnConnectionState" c:type="NMVpnConnectionState"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <type name="VpnConnectionStateReason"
                  c:type="NMVpnConnectionStateReason"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_banner" c:identifier="nm_vpn_connection_get_banner">
        <doc xml:space="preserve">Gets the VPN login banner of the active #NMVpnConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the VPN login banner of the VPN connection. This is the internal
string used by the connection, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="vpn" transfer-ownership="none">
            <doc xml:space="preserve">a #NMVpnConnection</doc>
            <type name="VpnConnection" c:type="NMVpnConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vpn_state"
              c:identifier="nm_vpn_connection_get_vpn_state">
        <doc xml:space="preserve">Gets the current #NMVpnConnection state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the VPN state of the active VPN connection.</doc>
          <type name="VpnConnectionState" c:type="NMVpnConnectionState"/>
        </return-value>
        <parameters>
          <instance-parameter name="vpn" transfer-ownership="none">
            <doc xml:space="preserve">a #NMVpnConnection</doc>
            <type name="VpnConnection" c:type="NMVpnConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="banner" transfer-ownership="none">
        <doc xml:space="preserve">The VPN login banner of the active VPN connection.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="vpn-state" transfer-ownership="none">
        <doc xml:space="preserve">The VPN state of the active VPN connection.</doc>
        <type name="VpnConnectionState"/>
      </property>
      <field name="parent">
        <type name="ActiveConnection" c:type="NMActiveConnection"/>
      </field>
      <glib:signal name="vpn-state-changed" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="VpnConnectionClass"
            c:type="NMVpnConnectionClass"
            glib:is-gtype-struct-for="VpnConnection">
      <field name="parent">
        <type name="ActiveConnectionClass" c:type="NMActiveConnectionClass"/>
      </field>
      <field name="vpn_state_changed">
        <callback name="vpn_state_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="connection" transfer-ownership="none">
              <type name="VpnConnection" c:type="NMVpnConnection*"/>
            </parameter>
            <parameter name="state" transfer-ownership="none">
              <type name="VpnConnectionState" c:type="NMVpnConnectionState"/>
            </parameter>
            <parameter name="reason" transfer-ownership="none">
              <type name="VpnConnectionStateReason"
                    c:type="NMVpnConnectionStateReason"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="VpnConnectionState"
                 glib:type-name="NMVpnConnectionState"
                 glib:get-type="nm_vpn_connection_state_get_type"
                 c:type="NMVpnConnectionState">
      <doc xml:space="preserve">VPN connection states</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_VPN_CONNECTION_STATE_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">The state of the VPN connection is
  unknown.</doc>
      </member>
      <member name="prepare"
              value="1"
              c:identifier="NM_VPN_CONNECTION_STATE_PREPARE"
              glib:nick="prepare">
        <doc xml:space="preserve">The VPN connection is preparing to
  connect.</doc>
      </member>
      <member name="need_auth"
              value="2"
              c:identifier="NM_VPN_CONNECTION_STATE_NEED_AUTH"
              glib:nick="need-auth">
        <doc xml:space="preserve">The VPN connection needs authorization
  credentials.</doc>
      </member>
      <member name="connect"
              value="3"
              c:identifier="NM_VPN_CONNECTION_STATE_CONNECT"
              glib:nick="connect">
        <doc xml:space="preserve">The VPN connection is being established.</doc>
      </member>
      <member name="ip_config_get"
              value="4"
              c:identifier="NM_VPN_CONNECTION_STATE_IP_CONFIG_GET"
              glib:nick="ip-config-get">
        <doc xml:space="preserve">The VPN connection is getting an IP
  address.</doc>
      </member>
      <member name="activated"
              value="5"
              c:identifier="NM_VPN_CONNECTION_STATE_ACTIVATED"
              glib:nick="activated">
        <doc xml:space="preserve">The VPN connection is active.</doc>
      </member>
      <member name="failed"
              value="6"
              c:identifier="NM_VPN_CONNECTION_STATE_FAILED"
              glib:nick="failed">
        <doc xml:space="preserve">The VPN connection failed.</doc>
      </member>
      <member name="disconnected"
              value="7"
              c:identifier="NM_VPN_CONNECTION_STATE_DISCONNECTED"
              glib:nick="disconnected">
        <doc xml:space="preserve">The VPN connection is disconnected.</doc>
      </member>
    </enumeration>
    <enumeration name="VpnConnectionStateReason"
                 glib:type-name="NMVpnConnectionStateReason"
                 glib:get-type="nm_vpn_connection_state_reason_get_type"
                 c:type="NMVpnConnectionStateReason">
      <doc xml:space="preserve">VPN connection state reasons</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">The reason for the VPN connection
  state change is unknown.</doc>
      </member>
      <member name="none"
              value="1"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_NONE"
              glib:nick="none">
        <doc xml:space="preserve">No reason was given for the VPN
  connection state change.</doc>
      </member>
      <member name="user_disconnected"
              value="2"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_USER_DISCONNECTED"
              glib:nick="user-disconnected">
        <doc xml:space="preserve">The VPN connection changed
  state because the user disconnected it.</doc>
      </member>
      <member name="device_disconnected"
              value="3"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED"
              glib:nick="device-disconnected">
        <doc xml:space="preserve">The VPN connection
  changed state because the device it was using was disconnected.</doc>
      </member>
      <member name="service_stopped"
              value="4"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_SERVICE_STOPPED"
              glib:nick="service-stopped">
        <doc xml:space="preserve">The service providing the
  VPN connection was stopped.</doc>
      </member>
      <member name="ip_config_invalid"
              value="5"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_IP_CONFIG_INVALID"
              glib:nick="ip-config-invalid">
        <doc xml:space="preserve">The IP config of the VPN
  connection was invalid.</doc>
      </member>
      <member name="connect_timeout"
              value="6"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_CONNECT_TIMEOUT"
              glib:nick="connect-timeout">
        <doc xml:space="preserve">The connection attempt to
  the VPN service timed out.</doc>
      </member>
      <member name="service_start_timeout"
              value="7"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT"
              glib:nick="service-start-timeout">
        <doc xml:space="preserve">A timeout occurred
  while starting the service providing the VPN connection.</doc>
      </member>
      <member name="service_start_failed"
              value="8"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_FAILED"
              glib:nick="service-start-failed">
        <doc xml:space="preserve">Starting the service
  starting the service providing the VPN connection failed.</doc>
      </member>
      <member name="no_secrets"
              value="9"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_NO_SECRETS"
              glib:nick="no-secrets">
        <doc xml:space="preserve">Necessary secrets for the VPN
  connection were not provided.</doc>
      </member>
      <member name="login_failed"
              value="10"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_LOGIN_FAILED"
              glib:nick="login-failed">
        <doc xml:space="preserve">Authentication to the VPN
  server failed.</doc>
      </member>
      <member name="connection_removed"
              value="11"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_CONNECTION_REMOVED"
              glib:nick="connection-removed">
        <doc xml:space="preserve">The connection was
  deleted from settings.</doc>
      </member>
    </enumeration>
    <interface name="VpnEditor"
               c:symbol-prefix="vpn_editor"
               c:type="NMVpnEditor"
               glib:type-name="NMVpnEditor"
               glib:get-type="nm_vpn_editor_get_type"
               glib:type-struct="VpnEditorInterface">
      <virtual-method name="changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="editor" transfer-ownership="none">
            <type name="VpnEditor" c:type="NMVpnEditor*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_widget" invoker="get_widget">
        <return-value transfer-ownership="none">
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="editor" transfer-ownership="none">
            <doc xml:space="preserve">the #NMVpnEditor</doc>
            <type name="VpnEditor" c:type="NMVpnEditor*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="update_connection"
                      invoker="update_connection"
                      throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="editor" transfer-ownership="none">
            <type name="VpnEditor" c:type="NMVpnEditor*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_widget" c:identifier="nm_vpn_editor_get_widget">
        <return-value transfer-ownership="none">
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="editor" transfer-ownership="none">
            <doc xml:space="preserve">the #NMVpnEditor</doc>
            <type name="VpnEditor" c:type="NMVpnEditor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="update_connection"
              c:identifier="nm_vpn_editor_update_connection"
              throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="editor" transfer-ownership="none">
            <type name="VpnEditor" c:type="NMVpnEditor*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </method>
      <glib:signal name="changed" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </interface>
    <record name="VpnEditorInterface"
            c:type="NMVpnEditorInterface"
            glib:is-gtype-struct-for="VpnEditor">
      <doc xml:space="preserve">Interface for editing a specific #NMConnection</doc>
      <field name="g_iface">
        <doc xml:space="preserve">the parent interface</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_widget">
        <callback name="get_widget">
          <return-value transfer-ownership="none">
            <type name="GObject.Object" c:type="GObject*"/>
          </return-value>
          <parameters>
            <parameter name="editor" transfer-ownership="none">
              <doc xml:space="preserve">the #NMVpnEditor</doc>
              <type name="VpnEditor" c:type="NMVpnEditor*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="placeholder">
        <callback name="placeholder">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="update_connection">
        <callback name="update_connection" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="editor" transfer-ownership="none">
              <type name="VpnEditor" c:type="NMVpnEditor*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="Connection" c:type="NMConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="changed">
        <callback name="changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="editor" transfer-ownership="none">
              <type name="VpnEditor" c:type="NMVpnEditor*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <interface name="VpnEditorPlugin"
               c:symbol-prefix="vpn_editor_plugin"
               c:type="NMVpnEditorPlugin"
               glib:type-name="NMVpnEditorPlugin"
               glib:get-type="nm_vpn_editor_plugin_get_type"
               glib:type-struct="VpnEditorPluginInterface">
      <function name="load"
                c:identifier="nm_vpn_editor_plugin_load"
                version="1.4"
                throws="1">
        <doc xml:space="preserve">Load the shared libary @plugin_name and create a new
#NMVpnEditorPlugin instace via the #NMVpnEditorPluginFactory
function.

This is similar to nm_vpn_editor_plugin_load_from_file(), but
it does no validation of the plugin name, instead passes it directly
to dlopen(). If you have the full path to a plugin file,
nm_vpn_editor_plugin_load_from_file() is preferred.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new plugin instance or %NULL on error.</doc>
          <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
        </return-value>
        <parameters>
          <parameter name="plugin_name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the shared library to load.
 This path will be directly passed to dlopen() without
 further checks.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="check_service" transfer-ownership="none">
            <doc xml:space="preserve">if not-null, check that the loaded plugin advertises
 the given service.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="load_from_file"
                c:identifier="nm_vpn_editor_plugin_load_from_file"
                version="1.2"
                throws="1">
        <doc xml:space="preserve">Load the shared libary @plugin_name and create a new
#NMVpnEditorPlugin instace via the #NMVpnEditorPluginFactory
function.

If @plugin_name is not an absolute path name, it assumes the file
is in the plugin directory of NetworkManager. In any case, the call
will do certain checks on the file before passing it to dlopen.
A consequence for that is, that you cannot omit the ".so" suffix
as you could for nm_vpn_editor_plugin_load().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new plugin instance or %NULL on error.</doc>
          <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
        </return-value>
        <parameters>
          <parameter name="plugin_name" transfer-ownership="none">
            <doc xml:space="preserve">The path or name of the shared library to load.
 The path must either be an absolute filename to an existing file.
 Alternatively, it can be the name (without path) of a library in the
 plugin directory of NetworkManager.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="check_service" transfer-ownership="none">
            <doc xml:space="preserve">if not-null, check that the loaded plugin advertises
 the given service.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="check_owner" transfer-ownership="none">
            <doc xml:space="preserve">if non-negative, check whether the file is owned
 by UID @check_owner or by root. In this case also check that
 the file is not writable by anybody else.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="check_file"
                     transfer-ownership="none"
                     scope="call"
                     closure="4">
            <doc xml:space="preserve">optional callback to validate the file prior to
  loading the shared library.</doc>
            <type name="UtilsCheckFilePredicate"
                  c:type="NMUtilsCheckFilePredicate"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data for @check_file</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="export_to_file" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_capabilities" invoker="get_capabilities">
        <return-value transfer-ownership="none">
          <type name="VpnEditorPluginCapability"
                c:type="NMVpnEditorPluginCapability"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_editor" invoker="get_editor" throws="1">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #NMVpnEditor or %NULL on error</doc>
          <type name="VpnEditor" c:type="NMVpnEditor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <doc xml:space="preserve">the #NMVpnEditorPlugin</doc>
            <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection to be edited</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_suggested_filename"
                      invoker="get_suggested_filename">
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_vt">
        <return-value transfer-ownership="none">
          <type name="VpnEditorPluginVT" c:type="const NMVpnEditorPluginVT*"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
          </instance-parameter>
          <parameter name="out_vt_size" transfer-ownership="none">
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="import_from_file" introspectable="0" throws="1">
        <return-value>
          <type name="Connection" c:type="NMConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="notify_plugin_info_set">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
          </instance-parameter>
          <parameter name="plugin_info"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="_NMVpnPluginInfo*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="export"
              c:identifier="nm_vpn_editor_plugin_export"
              throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_capabilities"
              c:identifier="nm_vpn_editor_plugin_get_capabilities">
        <return-value transfer-ownership="none">
          <type name="VpnEditorPluginCapability"
                c:type="NMVpnEditorPluginCapability"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_editor"
              c:identifier="nm_vpn_editor_plugin_get_editor"
              throws="1">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #NMVpnEditor or %NULL on error</doc>
          <type name="VpnEditor" c:type="NMVpnEditor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <doc xml:space="preserve">the #NMVpnEditorPlugin</doc>
            <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection to be edited</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_plugin_info"
              c:identifier="nm_vpn_editor_plugin_get_plugin_info"
              version="1.4">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">if set, return the #NMVpnPluginInfo instance.</doc>
          <type name="gpointer" c:type="_NMVpnPluginInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <doc xml:space="preserve">the #NMVpnEditorPlugin instance</doc>
            <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_suggested_filename"
              c:identifier="nm_vpn_editor_plugin_get_suggested_filename">
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_vt"
              c:identifier="nm_vpn_editor_plugin_get_vt"
              version="1.4">
        <doc xml:space="preserve">Returns an opaque VT function table for the plugin to extend
functionality. The actual meaning of NMVpnEditorPluginVT is not
defined in public API of libnm, instead it must be agreed by
both the plugin and the caller. See the header-only file
'nm-vpn-editor-plugin-call.h' which defines the meaning.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the actual size of the @plugin's virtual function table.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <doc xml:space="preserve">the #NMVpnEditorPlugin</doc>
            <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
          </instance-parameter>
          <parameter name="vt"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">buffer to be filled with the VT table of the plugin</doc>
            <type name="VpnEditorPluginVT" c:type="NMVpnEditorPluginVT*"/>
          </parameter>
          <parameter name="vt_size" transfer-ownership="none">
            <doc xml:space="preserve">the size of the buffer. Can be 0 to only query the
  size of plugin's VT.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="import"
              c:identifier="nm_vpn_editor_plugin_import"
              throws="1">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #NMConnection imported from @path, or %NULL
on error or if the file at @path was not recognized by this plugin</doc>
          <type name="Connection" c:type="NMConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <doc xml:space="preserve">the #NMVpnEditorPlugin</doc>
            <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">full path to the file to attempt to read into a new #NMConnection</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_plugin_info"
              c:identifier="nm_vpn_editor_plugin_set_plugin_info"
              version="1.4">
        <doc xml:space="preserve">Set or clear the plugin-info instance.
This takes a weak reference on @plugin_info, to avoid circular
reference as the plugin-info might also reference the editor-plugin.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <doc xml:space="preserve">the #NMVpnEditorPlugin instance</doc>
            <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
          </instance-parameter>
          <parameter name="plugin_info"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #NMVpnPluginInfo instance or %NULL</doc>
            <type name="gpointer" c:type="_NMVpnPluginInfo*"/>
          </parameter>
        </parameters>
      </method>
      <property name="description" transfer-ownership="none">
        <doc xml:space="preserve">Longer description of the VPN plugin.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="name" transfer-ownership="none">
        <doc xml:space="preserve">Short display name of the VPN plugin.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="service" transfer-ownership="none">
        <doc xml:space="preserve">D-Bus service name of the plugin's VPN service.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
    </interface>
    <bitfield name="VpnEditorPluginCapability"
              glib:type-name="NMVpnEditorPluginCapability"
              glib:get-type="nm_vpn_editor_plugin_capability_get_type"
              c:type="NMVpnEditorPluginCapability">
      <doc xml:space="preserve">Flags that indicate certain capabilities of the plugin to editor programs.</doc>
      <member name="none"
              value="0"
              c:identifier="NM_VPN_EDITOR_PLUGIN_CAPABILITY_NONE"
              glib:nick="none">
        <doc xml:space="preserve">unknown or no capability</doc>
      </member>
      <member name="import"
              value="1"
              c:identifier="NM_VPN_EDITOR_PLUGIN_CAPABILITY_IMPORT"
              glib:nick="import">
        <doc xml:space="preserve">the plugin can import new connections</doc>
      </member>
      <member name="export"
              value="2"
              c:identifier="NM_VPN_EDITOR_PLUGIN_CAPABILITY_EXPORT"
              glib:nick="export">
        <doc xml:space="preserve">the plugin can export connections</doc>
      </member>
      <member name="ipv6"
              value="4"
              c:identifier="NM_VPN_EDITOR_PLUGIN_CAPABILITY_IPV6"
              glib:nick="ipv6">
        <doc xml:space="preserve">the plugin supports IPv6 addressing</doc>
      </member>
    </bitfield>
    <record name="VpnEditorPluginInterface"
            c:type="NMVpnEditorPluginInterface"
            glib:is-gtype-struct-for="VpnEditorPlugin">
      <doc xml:space="preserve">Interface for VPN editor plugins.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">the parent interface</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_editor">
        <callback name="get_editor" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a new #NMVpnEditor or %NULL on error</doc>
            <type name="VpnEditor" c:type="NMVpnEditor*"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <doc xml:space="preserve">the #NMVpnEditorPlugin</doc>
              <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">the #NMConnection to be edited</doc>
              <type name="Connection" c:type="NMConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_capabilities">
        <callback name="get_capabilities">
          <return-value transfer-ownership="none">
            <type name="VpnEditorPluginCapability"
                  c:type="NMVpnEditorPluginCapability"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="import_from_file" introspectable="0">
        <callback name="import_from_file" introspectable="0" throws="1">
          <return-value>
            <type name="Connection" c:type="NMConnection*"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
            </parameter>
            <parameter name="path" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="export_to_file">
        <callback name="export_to_file" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
            </parameter>
            <parameter name="path" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="Connection" c:type="NMConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_suggested_filename">
        <callback name="get_suggested_filename">
          <return-value transfer-ownership="full">
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="Connection" c:type="NMConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="notify_plugin_info_set">
        <callback name="notify_plugin_info_set">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
            </parameter>
            <parameter name="plugin_info"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="_NMVpnPluginInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_vt">
        <callback name="get_vt">
          <return-value transfer-ownership="none">
            <type name="VpnEditorPluginVT"
                  c:type="const NMVpnEditorPluginVT*"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
            </parameter>
            <parameter name="out_vt_size" transfer-ownership="none">
              <type name="gsize" c:type="gsize*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="VpnEditorPluginVT"
            c:type="NMVpnEditorPluginVT"
            disguised="1">
    </record>
    <callback name="VpnIterFunc" c:type="NMVpnIterFunc">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">the name of the data or secret item</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the value of the data or secret item</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <doc xml:space="preserve">User data passed to nm_setting_vpn_foreach_data_item() or
nm_setting_vpn_foreach_secret()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="VpnPluginError"
                 glib:type-name="NMVpnPluginError"
                 glib:get-type="nm_vpn_plugin_error_get_type"
                 c:type="NMVpnPluginError"
                 glib:error-domain="nm-vpn-plugin-error-quark">
      <doc xml:space="preserve">Returned by the VPN service plugin to indicate errors. These codes correspond
to errors in the "org.freedesktop.NetworkManager.VPN.Error" namespace.</doc>
      <member name="Failed"
              value="0"
              c:identifier="NM_VPN_PLUGIN_ERROR_FAILED"
              glib:nick="Failed">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="StartingInProgress"
              value="1"
              c:identifier="NM_VPN_PLUGIN_ERROR_STARTING_IN_PROGRESS"
              glib:nick="StartingInProgress">
        <doc xml:space="preserve">the plugin is already starting,
  and another connect request was received</doc>
      </member>
      <member name="AlreadyStarted"
              value="2"
              c:identifier="NM_VPN_PLUGIN_ERROR_ALREADY_STARTED"
              glib:nick="AlreadyStarted">
        <doc xml:space="preserve">the plugin is already connected, and
  another connect request was received</doc>
      </member>
      <member name="StoppingInProgress"
              value="3"
              c:identifier="NM_VPN_PLUGIN_ERROR_STOPPING_IN_PROGRESS"
              glib:nick="StoppingInProgress">
        <doc xml:space="preserve">the plugin is already stopping,
  and another stop request was received</doc>
      </member>
      <member name="AlreadyStopped"
              value="4"
              c:identifier="NM_VPN_PLUGIN_ERROR_ALREADY_STOPPED"
              glib:nick="AlreadyStopped">
        <doc xml:space="preserve">the plugin is already stopped, and
  another disconnect request was received</doc>
      </member>
      <member name="WrongState"
              value="5"
              c:identifier="NM_VPN_PLUGIN_ERROR_WRONG_STATE"
              glib:nick="WrongState">
        <doc xml:space="preserve">the operation could not be performed in
  this state</doc>
      </member>
      <member name="BadArguments"
              value="6"
              c:identifier="NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS"
              glib:nick="BadArguments">
        <doc xml:space="preserve">the operation could not be performed as
  the request contained malformed arguments, or arguments of unexpected type.
  Usually means that one of the VPN setting data items or secrets was not of
  the expected type (ie int, string, bool, etc).</doc>
      </member>
      <member name="LaunchFailed"
              value="7"
              c:identifier="NM_VPN_PLUGIN_ERROR_LAUNCH_FAILED"
              glib:nick="LaunchFailed">
        <doc xml:space="preserve">a child process failed to launch</doc>
      </member>
      <member name="InvalidConnection"
              value="8"
              c:identifier="NM_VPN_PLUGIN_ERROR_INVALID_CONNECTION"
              glib:nick="InvalidConnection">
        <doc xml:space="preserve">the operation could not be performed
  because the connection was invalid.  Usually means that the connection's
  VPN setting was missing some required data item or secret.</doc>
      </member>
      <member name="InteractiveNotSupported"
              value="9"
              c:identifier="NM_VPN_PLUGIN_ERROR_INTERACTIVE_NOT_SUPPORTED"
              glib:nick="InteractiveNotSupported">
        <doc xml:space="preserve">the operation could not be
  performed as the plugin does not support interactive operations, such as
  ConnectInteractive() or NewSecrets()</doc>
      </member>
      <function name="quark" c:identifier="nm_vpn_plugin_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <enumeration name="VpnPluginFailure"
                 glib:type-name="NMVpnPluginFailure"
                 glib:get-type="nm_vpn_plugin_failure_get_type"
                 c:type="NMVpnPluginFailure">
      <doc xml:space="preserve">VPN plugin failure reasons</doc>
      <member name="login_failed"
              value="0"
              c:identifier="NM_VPN_PLUGIN_FAILURE_LOGIN_FAILED"
              glib:nick="login-failed">
        <doc xml:space="preserve">Login failed.</doc>
      </member>
      <member name="connect_failed"
              value="1"
              c:identifier="NM_VPN_PLUGIN_FAILURE_CONNECT_FAILED"
              glib:nick="connect-failed">
        <doc xml:space="preserve">Connect failed.</doc>
      </member>
      <member name="bad_ip_config"
              value="2"
              c:identifier="NM_VPN_PLUGIN_FAILURE_BAD_IP_CONFIG"
              glib:nick="bad-ip-config">
        <doc xml:space="preserve">Invalid IP configuration returned from
  the VPN plugin.</doc>
      </member>
    </enumeration>
    <class name="VpnPluginInfo"
           c:symbol-prefix="vpn_plugin_info"
           c:type="NMVpnPluginInfo"
           parent="GObject.Object"
           glib:type-name="NMVpnPluginInfo"
           glib:get-type="nm_vpn_plugin_info_get_type"
           glib:type-struct="VpnPluginInfoClass">
      <implements name="Gio.Initable"/>
      <constructor name="new_from_file"
                   c:identifier="nm_vpn_plugin_info_new_from_file"
                   version="1.2"
                   throws="1">
        <doc xml:space="preserve">Read the plugin info from file @filename. Does not do
any further verification on the file. You might want to check
file permissions and ownership of the file.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">%NULL if there is any error or a newly created
#NMVpnPluginInfo instance.</doc>
          <type name="VpnPluginInfo" c:type="NMVpnPluginInfo*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">filename to read.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_search_file"
                   c:identifier="nm_vpn_plugin_info_new_search_file"
                   version="1.4">
        <doc xml:space="preserve">This has the same effect as doing a full nm_vpn_plugin_info_list_load()
followed by a search for the first matching VPN plugin info that has the
given @name and/or @service.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly created instance of plugin info
  or %NULL if no matching value was found.</doc>
          <type name="VpnPluginInfo" c:type="NMVpnPluginInfo*"/>
        </return-value>
        <parameters>
          <parameter name="name"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the name to search for. Either @name or @service
  must be present.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="service"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the service to search for. Either @name  or
  @service must be present.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_data"
                   c:identifier="nm_vpn_plugin_info_new_with_data"
                   version="1.2"
                   throws="1">
        <doc xml:space="preserve">This constructor does not read any data from file but
takes instead a @keyfile argument.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">new plugin info instance.</doc>
          <type name="VpnPluginInfo" c:type="NMVpnPluginInfo*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">optional filename.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="keyfile" transfer-ownership="none">
            <doc xml:space="preserve">inject data for the plugin info instance.</doc>
            <type name="GLib.KeyFile" c:type="GKeyFile*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="list_add"
                c:identifier="nm_vpn_plugin_info_list_add"
                version="1.2"
                throws="1">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the plugin was added to @list. This will fail
to add duplicate plugins.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">list of plugins</doc>
            <type name="GLib.SList" c:type="GSList**">
              <type name="VpnPluginInfo"/>
            </type>
          </parameter>
          <parameter name="plugin_info" transfer-ownership="none">
            <doc xml:space="preserve">instance to add</doc>
            <type name="VpnPluginInfo" c:type="NMVpnPluginInfo*"/>
          </parameter>
        </parameters>
      </function>
      <function name="list_find_by_filename"
                c:identifier="nm_vpn_plugin_info_list_find_by_filename"
                version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the first plugin with a matching @filename (or %NULL).</doc>
          <type name="VpnPluginInfo" c:type="NMVpnPluginInfo*"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">list of plugins</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="VpnPluginInfo"/>
            </type>
          </parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">filename to search</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="list_find_by_name"
                c:identifier="nm_vpn_plugin_info_list_find_by_name"
                version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the first plugin with a matching @name (or %NULL).</doc>
          <type name="VpnPluginInfo" c:type="NMVpnPluginInfo*"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">list of plugins</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="VpnPluginInfo"/>
            </type>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name to search</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="list_find_by_service"
                c:identifier="nm_vpn_plugin_info_list_find_by_service"
                version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the first plugin with a matching @service (or %NULL).</doc>
          <type name="VpnPluginInfo" c:type="NMVpnPluginInfo*"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">list of plugins</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="VpnPluginInfo"/>
            </type>
          </parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">service to search. This can be the main service-type
  or one of the provided aliases.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="list_find_service_type"
                c:identifier="nm_vpn_plugin_info_list_find_service_type"
                version="1.4">
        <doc xml:space="preserve">A VPN plugin provides one or several service-types, like org.freedesktop.NetworkManager.libreswan
Certain plugins provide more then one service type, via aliases (org.freedesktop.NetworkManager.openswan).
This function looks up a service-type (or an alias) based on a name.

Preferably, the name can be a full service-type/alias of an installed
plugin. Otherwise, it can be the name of a VPN plugin (in which case, the
primary, non-aliased service-type is returned). Otherwise, it can be
one of several well known short-names (which is a hard-coded list of
types in libnm). On success, this returns a full qualified service-type
(or an alias). It doesn't say, that such an plugin is actually available,
but it could be retrieved via nm_vpn_plugin_info_list_find_by_service().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the resolved service-type or %NULL on failure.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a possibly empty #GSList of #NMVpnPluginInfo instances</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="VpnPluginInfo"/>
            </type>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a name to lookup the service-type.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="list_get_service_types"
                c:identifier="nm_vpn_plugin_info_list_get_service_types"
                version="1.4">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a %NULL terminated strv list of strings.
  The list itself and the values must be freed with g_strfreev().</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a possibly empty #GSList of #NMVpnPluginInfo</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="VpnPluginInfo"/>
            </type>
          </parameter>
          <parameter name="only_existing" transfer-ownership="none">
            <doc xml:space="preserve">only include results that are actually in @list.
  Otherwise, the result is extended with a hard-code list or
  well-known plugins</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="with_abbreviations" transfer-ownership="none">
            <doc xml:space="preserve">if %FALSE, only full service types are returned.
  Otherwise, this also includes abbreviated names that can be used
  with nm_vpn_plugin_info_list_find_service_type().</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="list_load"
                c:identifier="nm_vpn_plugin_info_list_load"
                version="1.2">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">list of plugins
loaded from the default directories rejecting duplicates.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="VpnPluginInfo"/>
          </type>
        </return-value>
      </function>
      <function name="list_remove"
                c:identifier="nm_vpn_plugin_info_list_remove"
                version="1.2">
        <doc xml:space="preserve">Remove @plugin_info from @list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @plugin_info was in @list and successfully removed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">list of plugins</doc>
            <type name="GLib.SList" c:type="GSList**">
              <type name="VpnPluginInfo"/>
            </type>
          </parameter>
          <parameter name="plugin_info" transfer-ownership="none">
            <doc xml:space="preserve">instance</doc>
            <type name="VpnPluginInfo" c:type="NMVpnPluginInfo*"/>
          </parameter>
        </parameters>
      </function>
      <function name="validate_filename"
                c:identifier="nm_vpn_plugin_info_validate_filename"
                version="1.2">
        <doc xml:space="preserve">Regular name files have a certain pattern. That basically means
they have the file extension "name". Check if @filename
is valid according to that pattern.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">the filename to check</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_aliases"
              c:identifier="nm_vpn_plugin_info_get_aliases"
              version="1.4">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">
  the aliases from the name-file.</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">plugin info instance</doc>
            <type name="VpnPluginInfo" c:type="NMVpnPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_auth_dialog"
              c:identifier="nm_vpn_plugin_info_get_auth_dialog"
              version="1.4">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the absolute path to the auth-dialog helper or %NULL.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">plugin info instance</doc>
            <type name="VpnPluginInfo" c:type="NMVpnPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_editor_plugin"
              c:identifier="nm_vpn_plugin_info_get_editor_plugin"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the cached #NMVpnEditorPlugin instance.</doc>
          <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">plugin info instance</doc>
            <type name="VpnPluginInfo" c:type="NMVpnPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_filename"
              c:identifier="nm_vpn_plugin_info_get_filename"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the filename. Can be %NULL.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">plugin info instance</doc>
            <type name="VpnPluginInfo" c:type="NMVpnPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name"
              c:identifier="nm_vpn_plugin_info_get_name"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name. Cannot be %NULL.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">plugin info instance</doc>
            <type name="VpnPluginInfo" c:type="NMVpnPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_plugin"
              c:identifier="nm_vpn_plugin_info_get_plugin"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the plugin. Can be %NULL.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">plugin info instance</doc>
            <type name="VpnPluginInfo" c:type="NMVpnPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_program"
              c:identifier="nm_vpn_plugin_info_get_program"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the program. Can be %NULL.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">plugin info instance</doc>
            <type name="VpnPluginInfo" c:type="NMVpnPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_service"
              c:identifier="nm_vpn_plugin_info_get_service"
              version="1.4">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the service. Cannot be %NULL.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">plugin info instance</doc>
            <type name="VpnPluginInfo" c:type="NMVpnPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="load_editor_plugin"
              c:identifier="nm_vpn_plugin_info_load_editor_plugin"
              version="1.2"
              throws="1">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">loads the plugin and returns the newly created
  instance. The plugin is owned by @self and can be later retrieved again
  via nm_vpn_plugin_info_get_editor_plugin(). You can load the
  plugin only once, unless you reset the state via
  nm_vpn_plugin_info_set_editor_plugin().</doc>
          <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">plugin info instance</doc>
            <type name="VpnPluginInfo" c:type="NMVpnPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="lookup_property"
              c:identifier="nm_vpn_plugin_info_lookup_property"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#NMVpnPluginInfo is internally a #GKeyFile. Returns the matching
property.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">plugin info instance</doc>
            <type name="VpnPluginInfo" c:type="NMVpnPluginInfo*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">group name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">name of the property</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_editor_plugin"
              c:identifier="nm_vpn_plugin_info_set_editor_plugin"
              version="1.2">
        <doc xml:space="preserve">Set the internal plugin instance. If %NULL, only clear the previous instance.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">plugin info instance</doc>
            <type name="VpnPluginInfo" c:type="NMVpnPluginInfo*"/>
          </instance-parameter>
          <parameter name="plugin"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">plugin instance</doc>
            <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_hints"
              c:identifier="nm_vpn_plugin_info_supports_hints"
              version="1.4">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the supports hints for secret requests, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">plugin info instance</doc>
            <type name="VpnPluginInfo" c:type="NMVpnPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="supports_multiple"
              c:identifier="nm_vpn_plugin_info_supports_multiple"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the service supports multiple instances with different bus names, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">plugin info instance</doc>
            <type name="VpnPluginInfo" c:type="NMVpnPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="filename"
                version="1.2"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The filename from which the info was loaded.
Can be %NULL if the instance was not loaded from
a file (i.e. the keyfile instance was passed to the
constructor).</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="keyfile"
                version="1.2"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Initalize the instance with a different keyfile instance.
When passing a keyfile instance, the constructor will not
try to read from filename.</doc>
        <type name="GLib.KeyFile"/>
      </property>
      <property name="name" version="1.2" transfer-ownership="none">
        <doc xml:space="preserve">The name of the VPN plugin.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="VpnPluginInfoClass"
            c:type="NMVpnPluginInfoClass"
            glib:is-gtype-struct-for="VpnPluginInfo">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="VpnPluginOld"
           c:symbol-prefix="vpn_plugin_old"
           c:type="NMVpnPluginOld"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="NMVpnPluginOld"
           glib:get-type="nm_vpn_plugin_old_get_type"
           glib:type-struct="VpnPluginOldClass">
      <implements name="Gio.Initable"/>
      <function name="get_secret_flags"
                c:identifier="nm_vpn_plugin_old_get_secret_flags"
                deprecated="1"
                deprecated-version="1.2">
        <doc xml:space="preserve">Given a VPN secret key name, attempts to find the corresponding flags data
item in @data.  If found, converts the flags data item to
#NMSettingSecretFlags and returns it.</doc>
        <doc-deprecated xml:space="preserve">replaced by NMVpnServicePlugin</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the flag data item was found and successfully converted
to flags, %FALSE if not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">hash table containing VPN key/value pair data items</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="secret_name" transfer-ownership="none">
            <doc xml:space="preserve">VPN secret key name for which to retrieve flags for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="out_flags"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">on success, the flags associated with @secret_name</doc>
            <type name="SettingSecretFlags" c:type="NMSettingSecretFlags*"/>
          </parameter>
        </parameters>
      </function>
      <function name="read_vpn_details"
                c:identifier="nm_vpn_plugin_old_read_vpn_details"
                deprecated="1"
                deprecated-version="1.2">
        <doc xml:space="preserve">Parses key/value pairs from a file descriptor (normally stdin) passed by
an applet when the applet calls the authentication dialog of the VPN plugin.</doc>
        <doc-deprecated xml:space="preserve">replaced by NMVpnServicePlugin</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if reading values was successful, %FALSE if not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:space="preserve">file descriptor to read from, usually stdin (0)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="out_data"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">on successful return, a hash table
(mapping char*:char*) containing the key/value pairs of VPN data items</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="out_secrets"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">on successful return, a hash table
(mapping char*:char*) containing the key/value pairsof VPN secrets</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="config">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
          </instance-parameter>
          <parameter name="config" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="connect" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="connect_interactive" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="details" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="disconnect"
                      invoker="disconnect"
                      deprecated="1"
                      deprecated-version="1.2"
                      throws="1">
        <doc-deprecated xml:space="preserve">replaced by NMVpnServicePlugin</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="failure"
                      invoker="failure"
                      deprecated="1"
                      deprecated-version="1.2">
        <doc-deprecated xml:space="preserve">replaced by NMVpnServicePlugin</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
          </instance-parameter>
          <parameter name="reason" transfer-ownership="none">
            <type name="VpnPluginFailure" c:type="NMVpnPluginFailure"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="ip4_config">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
          </instance-parameter>
          <parameter name="ip4_config" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="ip6_config">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
          </instance-parameter>
          <parameter name="config" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="login_banner">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
          </instance-parameter>
          <parameter name="banner" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="need_secrets" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="setting_name" transfer-ownership="none">
            <type name="utf8" c:type="const char**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="new_secrets" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="quit">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="state_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
          </instance-parameter>
          <parameter name="state" transfer-ownership="none">
            <type name="VpnServiceState" c:type="NMVpnServiceState"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="disconnect"
              c:identifier="nm_vpn_plugin_old_disconnect"
              deprecated="1"
              deprecated-version="1.2"
              throws="1">
        <doc-deprecated xml:space="preserve">replaced by NMVpnServicePlugin</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="failure"
              c:identifier="nm_vpn_plugin_old_failure"
              deprecated="1"
              deprecated-version="1.2">
        <doc-deprecated xml:space="preserve">replaced by NMVpnServicePlugin</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
          </instance-parameter>
          <parameter name="reason" transfer-ownership="none">
            <type name="VpnPluginFailure" c:type="NMVpnPluginFailure"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_connection"
              c:identifier="nm_vpn_plugin_old_get_connection"
              deprecated="1"
              deprecated-version="1.2">
        <doc-deprecated xml:space="preserve">replaced by NMVpnServicePlugin</doc-deprecated>
        <return-value transfer-ownership="full">
          <type name="Gio.DBusConnection" c:type="GDBusConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_state"
              c:identifier="nm_vpn_plugin_old_get_state"
              deprecated="1"
              deprecated-version="1.2">
        <doc-deprecated xml:space="preserve">replaced by NMVpnServicePlugin</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="VpnServiceState" c:type="NMVpnServiceState"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="secrets_required"
              c:identifier="nm_vpn_plugin_old_secrets_required"
              deprecated="1"
              deprecated-version="1.2">
        <doc xml:space="preserve">Called by VPN plugin implementations to signal to NetworkManager that secrets
are required during the connection process.  This signal may be used to
request new secrets when the secrets originally provided by NetworkManager
are insufficient, or the VPN process indicates that it needs additional
information to complete the request.</doc>
        <doc-deprecated xml:space="preserve">replaced by NMVpnServicePlugin</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <doc xml:space="preserve">the #NMVpnPluginOld</doc>
            <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">an information message about why secrets are required, if any</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="hints" transfer-ownership="none">
            <doc xml:space="preserve">VPN specific secret names for required new secrets</doc>
            <type name="utf8" c:type="const char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_config"
              c:identifier="nm_vpn_plugin_old_set_config"
              deprecated="1"
              deprecated-version="1.2">
        <doc-deprecated xml:space="preserve">replaced by NMVpnServicePlugin</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
          </instance-parameter>
          <parameter name="config" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ip4_config"
              c:identifier="nm_vpn_plugin_old_set_ip4_config"
              deprecated="1"
              deprecated-version="1.2">
        <doc-deprecated xml:space="preserve">replaced by NMVpnServicePlugin</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
          </instance-parameter>
          <parameter name="ip4_config" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ip6_config"
              c:identifier="nm_vpn_plugin_old_set_ip6_config"
              deprecated="1"
              deprecated-version="1.2">
        <doc-deprecated xml:space="preserve">replaced by NMVpnServicePlugin</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
          </instance-parameter>
          <parameter name="ip6_config" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_login_banner"
              c:identifier="nm_vpn_plugin_old_set_login_banner"
              deprecated="1"
              deprecated-version="1.2">
        <doc-deprecated xml:space="preserve">replaced by NMVpnServicePlugin</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
          </instance-parameter>
          <parameter name="banner" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_state"
              c:identifier="nm_vpn_plugin_old_set_state"
              deprecated="1"
              deprecated-version="1.2">
        <doc-deprecated xml:space="preserve">replaced by NMVpnServicePlugin</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
          </instance-parameter>
          <parameter name="state" transfer-ownership="none">
            <type name="VpnServiceState" c:type="NMVpnServiceState"/>
          </parameter>
        </parameters>
      </method>
      <property name="service-name"
                deprecated="1"
                deprecated-version="1.2"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The D-Bus service name of this plugin.</doc>
        <doc-deprecated xml:space="preserve">replaced by NMVpnServicePlugin</doc-deprecated>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="state"
                deprecated="1"
                deprecated-version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The state of the plugin.</doc>
        <doc-deprecated xml:space="preserve">replaced by NMVpnServicePlugin</doc-deprecated>
        <type name="VpnServiceState"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="config" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="GLib.Variant"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="failure" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="ip4-config" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="GLib.Variant"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="ip6-config" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="GLib.Variant"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="login-banner" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="quit" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="secrets-required" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <array>
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="state-changed" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="VpnPluginOldClass"
            c:type="NMVpnPluginOldClass"
            glib:is-gtype-struct-for="VpnPluginOld">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="state_changed">
        <callback name="state_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
            </parameter>
            <parameter name="state" transfer-ownership="none">
              <type name="VpnServiceState" c:type="NMVpnServiceState"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="ip4_config">
        <callback name="ip4_config">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
            </parameter>
            <parameter name="ip4_config" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="login_banner">
        <callback name="login_banner">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
            </parameter>
            <parameter name="banner" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="failure">
        <callback name="failure">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
            </parameter>
            <parameter name="reason" transfer-ownership="none">
              <type name="VpnPluginFailure" c:type="NMVpnPluginFailure"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="quit">
        <callback name="quit">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="config">
        <callback name="config">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
            </parameter>
            <parameter name="config" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="ip6_config">
        <callback name="ip6_config">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
            </parameter>
            <parameter name="config" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="connect">
        <callback name="connect" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="Connection" c:type="NMConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="need_secrets">
        <callback name="need_secrets" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="Connection" c:type="NMConnection*"/>
            </parameter>
            <parameter name="setting_name" transfer-ownership="none">
              <type name="utf8" c:type="const char**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="disconnect">
        <callback name="disconnect" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="new_secrets">
        <callback name="new_secrets" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="Connection" c:type="NMConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="connect_interactive">
        <callback name="connect_interactive" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnPluginOld" c:type="NMVpnPluginOld*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="Connection" c:type="NMConnection*"/>
            </parameter>
            <parameter name="details" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="VpnServicePlugin"
           c:symbol-prefix="vpn_service_plugin"
           c:type="NMVpnServicePlugin"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="NMVpnServicePlugin"
           glib:get-type="nm_vpn_service_plugin_get_type"
           glib:type-struct="VpnServicePluginClass">
      <implements name="Gio.Initable"/>
      <function name="get_secret_flags"
                c:identifier="nm_vpn_service_plugin_get_secret_flags"
                version="1.2">
        <doc xml:space="preserve">Given a VPN secret key name, attempts to find the corresponding flags data
item in @data.  If found, converts the flags data item to
#NMSettingSecretFlags and returns it.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the flag data item was found and successfully converted
to flags, %FALSE if not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">hash table containing VPN key/value pair data items</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="secret_name" transfer-ownership="none">
            <doc xml:space="preserve">VPN secret key name for which to retrieve flags for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="out_flags"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">on success, the flags associated with @secret_name</doc>
            <type name="SettingSecretFlags" c:type="NMSettingSecretFlags*"/>
          </parameter>
        </parameters>
      </function>
      <function name="read_vpn_details"
                c:identifier="nm_vpn_service_plugin_read_vpn_details"
                version="1.2">
        <doc xml:space="preserve">Parses key/value pairs from a file descriptor (normally stdin) passed by
an applet when the applet calls the authentication dialog of the VPN plugin.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if reading values was successful, %FALSE if not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:space="preserve">file descriptor to read from, usually stdin (0)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="out_data"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">on successful return, a hash table
(mapping char*:char*) containing the key/value pairs of VPN data items</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="out_secrets"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">on successful return, a hash table
(mapping char*:char*) containing the key/value pairsof VPN secrets</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="config">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
          </instance-parameter>
          <parameter name="config" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="connect" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="connect_interactive" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="details" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="disconnect" invoker="disconnect" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="failure" invoker="failure">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
          </instance-parameter>
          <parameter name="reason" transfer-ownership="none">
            <type name="VpnPluginFailure" c:type="NMVpnPluginFailure"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="ip4_config">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
          </instance-parameter>
          <parameter name="ip4_config" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="ip6_config">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
          </instance-parameter>
          <parameter name="config" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="login_banner">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
          </instance-parameter>
          <parameter name="banner" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="need_secrets" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="setting_name" transfer-ownership="none">
            <type name="utf8" c:type="const char**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="new_secrets" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="quit">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="state_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
          </instance-parameter>
          <parameter name="state" transfer-ownership="none">
            <type name="VpnServiceState" c:type="NMVpnServiceState"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="disconnect"
              c:identifier="nm_vpn_service_plugin_disconnect"
              throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="failure" c:identifier="nm_vpn_service_plugin_failure">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
          </instance-parameter>
          <parameter name="reason" transfer-ownership="none">
            <type name="VpnPluginFailure" c:type="NMVpnPluginFailure"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_connection"
              c:identifier="nm_vpn_service_plugin_get_connection"
              version="1.2">
        <return-value transfer-ownership="full">
          <type name="Gio.DBusConnection" c:type="GDBusConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="secrets_required"
              c:identifier="nm_vpn_service_plugin_secrets_required"
              version="1.2">
        <doc xml:space="preserve">Called by VPN plugin implementations to signal to NetworkManager that secrets
are required during the connection process.  This signal may be used to
request new secrets when the secrets originally provided by NetworkManager
are insufficient, or the VPN process indicates that it needs additional
information to complete the request.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <doc xml:space="preserve">the #NMVpnServicePlugin</doc>
            <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">an information message about why secrets are required, if any</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="hints" transfer-ownership="none">
            <doc xml:space="preserve">VPN specific secret names for required new secrets</doc>
            <type name="utf8" c:type="const char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_config"
              c:identifier="nm_vpn_service_plugin_set_config">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
          </instance-parameter>
          <parameter name="config" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ip4_config"
              c:identifier="nm_vpn_service_plugin_set_ip4_config">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
          </instance-parameter>
          <parameter name="ip4_config" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ip6_config"
              c:identifier="nm_vpn_service_plugin_set_ip6_config">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
          </instance-parameter>
          <parameter name="ip6_config" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_login_banner"
              c:identifier="nm_vpn_service_plugin_set_login_banner">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
          </instance-parameter>
          <parameter name="banner" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="service-name"
                version="1.2"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The D-Bus service name of this plugin.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="state"
                version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The state of the plugin.</doc>
        <type name="VpnServiceState"/>
      </property>
      <property name="watch-peer"
                version="1.2"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Whether to watch for D-Bus peer's changes.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="config" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="GLib.Variant"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="failure" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="ip4-config" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="GLib.Variant"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="ip6-config" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="GLib.Variant"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="login-banner" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="quit" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="secrets-required" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <array>
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="state-changed" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="VpnServicePluginClass"
            c:type="NMVpnServicePluginClass"
            glib:is-gtype-struct-for="VpnServicePlugin">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="state_changed">
        <callback name="state_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
            </parameter>
            <parameter name="state" transfer-ownership="none">
              <type name="VpnServiceState" c:type="NMVpnServiceState"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="ip4_config">
        <callback name="ip4_config">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
            </parameter>
            <parameter name="ip4_config" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="login_banner">
        <callback name="login_banner">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
            </parameter>
            <parameter name="banner" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="failure">
        <callback name="failure">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
            </parameter>
            <parameter name="reason" transfer-ownership="none">
              <type name="VpnPluginFailure" c:type="NMVpnPluginFailure"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="quit">
        <callback name="quit">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="config">
        <callback name="config">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
            </parameter>
            <parameter name="config" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="ip6_config">
        <callback name="ip6_config">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
            </parameter>
            <parameter name="config" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="connect">
        <callback name="connect" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="Connection" c:type="NMConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="need_secrets">
        <callback name="need_secrets" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="Connection" c:type="NMConnection*"/>
            </parameter>
            <parameter name="setting_name" transfer-ownership="none">
              <type name="utf8" c:type="const char**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="disconnect">
        <callback name="disconnect" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="new_secrets">
        <callback name="new_secrets" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="Connection" c:type="NMConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="connect_interactive">
        <callback name="connect_interactive" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="plugin" transfer-ownership="none">
              <type name="VpnServicePlugin" c:type="NMVpnServicePlugin*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="Connection" c:type="NMConnection*"/>
            </parameter>
            <parameter name="details" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="VpnServiceState"
                 glib:type-name="NMVpnServiceState"
                 glib:get-type="nm_vpn_service_state_get_type"
                 c:type="NMVpnServiceState">
      <doc xml:space="preserve">VPN daemon states</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_VPN_SERVICE_STATE_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">The state of the VPN plugin is unknown.</doc>
      </member>
      <member name="init"
              value="1"
              c:identifier="NM_VPN_SERVICE_STATE_INIT"
              glib:nick="init">
        <doc xml:space="preserve">The VPN plugin is initialized.</doc>
      </member>
      <member name="shutdown"
              value="2"
              c:identifier="NM_VPN_SERVICE_STATE_SHUTDOWN"
              glib:nick="shutdown">
        <doc xml:space="preserve">Not used.</doc>
      </member>
      <member name="starting"
              value="3"
              c:identifier="NM_VPN_SERVICE_STATE_STARTING"
              glib:nick="starting">
        <doc xml:space="preserve">The plugin is attempting to connect to a VPN server.</doc>
      </member>
      <member name="started"
              value="4"
              c:identifier="NM_VPN_SERVICE_STATE_STARTED"
              glib:nick="started">
        <doc xml:space="preserve">The plugin has connected to a VPN server.</doc>
      </member>
      <member name="stopping"
              value="5"
              c:identifier="NM_VPN_SERVICE_STATE_STOPPING"
              glib:nick="stopping">
        <doc xml:space="preserve">The plugin is disconnecting from the VPN server.</doc>
      </member>
      <member name="stopped"
              value="6"
              c:identifier="NM_VPN_SERVICE_STATE_STOPPED"
              glib:nick="stopped">
        <doc xml:space="preserve">The plugin has disconnected from the VPN server.</doc>
      </member>
    </enumeration>
    <constant name="WIMAX_NSP_NAME" value="name" c:type="NM_WIMAX_NSP_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="WIMAX_NSP_NETWORK_TYPE"
              value="network-type"
              c:type="NM_WIMAX_NSP_NETWORK_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="WIMAX_NSP_SIGNAL_QUALITY"
              value="signal-quality"
              c:type="NM_WIMAX_NSP_SIGNAL_QUALITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="WepKeyType"
                 glib:type-name="NMWepKeyType"
                 glib:get-type="nm_wep_key_type_get_type"
                 c:type="NMWepKeyType">
      <doc xml:space="preserve">The #NMWepKeyType values specify how any WEP keys present in the setting
are intepreted.  There are no standards governing how to hash the various WEP
key/passphrase formats into the actual WEP key.  Unfortunately some WEP keys
can be interpreted in multiple ways, requring the setting to specify how to
interpret the any WEP keys.  For example, the key "732f2d712e4a394a375d366931"
is both a valid Hexadecimal WEP key and a WEP passphrase.  Further, many
ASCII keys are also valid WEP passphrases, but since passphrases and ASCII
keys are hashed differently to determine the actual WEP key the type must be
specified.</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_WEP_KEY_TYPE_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">unknown WEP key type</doc>
      </member>
      <member name="key"
              value="1"
              c:identifier="NM_WEP_KEY_TYPE_KEY"
              glib:nick="key">
        <doc xml:space="preserve">indicates a hexadecimal or ASCII formatted WEP key.
Hex keys are either 10 or 26 hexadecimal characters (ie "5f782f2f5f" or
"732f2d712e4a394a375d366931"), while ASCII keys are either 5 or 13 ASCII
characters (ie "abcde" or "blahblah99$*1").</doc>
      </member>
      <member name="passphrase"
              value="2"
              c:identifier="NM_WEP_KEY_TYPE_PASSPHRASE"
              glib:nick="passphrase">
        <doc xml:space="preserve">indicates a WEP passphrase (ex "I bought a duck
on my way back from the market 235Q&amp;^%^*%") instead of a hexadecimal or ASCII
key.  Passphrases are between 8 and 64 characters inclusive and are hashed
the actual WEP key using the MD5 hash algorithm.</doc>
      </member>
      <member name="last"
              value="2"
              c:identifier="NM_WEP_KEY_TYPE_LAST"
              glib:nick="last">
        <doc xml:space="preserve">placeholder value for bounds-checking</doc>
      </member>
    </enumeration>
    <class name="WimaxNsp"
           c:symbol-prefix="wimax_nsp"
           c:type="NMWimaxNsp"
           parent="Object"
           glib:type-name="NMWimaxNsp"
           glib:get-type="nm_wimax_nsp_get_type"
           glib:type-struct="WimaxNspClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <method name="connection_valid"
              c:identifier="nm_wimax_nsp_connection_valid">
        <doc xml:space="preserve">Validates a given connection against a given WiMAX NSP to ensure that the
connection may be activated with that NSP.  The connection must match the
@nsp's network name and other attributes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection may be activated with this WiMAX NSP,
%FALSE if it cannot be.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="nsp" transfer-ownership="none">
            <doc xml:space="preserve">an #NMWimaxNsp to validate @connection against</doc>
            <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">an #NMConnection to validate against @nsp</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="filter_connections"
              c:identifier="nm_wimax_nsp_filter_connections">
        <doc xml:space="preserve">Filters a given array of connections for a given #NMWimaxNsp object and
return connections which may be activated with the NSP.  Any returned
connections will match the @nsp's network name and other attributes.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">an array of
#NMConnections that could be activated with the given @nsp.  The array should
be freed with g_ptr_array_unref() when it is no longer required.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="Connection"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="nsp" transfer-ownership="none">
            <doc xml:space="preserve">an #NMWimaxNsp to filter connections for</doc>
            <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
          </instance-parameter>
          <parameter name="connections" transfer-ownership="none">
            <doc xml:space="preserve">an array of #NMConnections to
filter</doc>
            <array name="GLib.PtrArray" c:type="const GPtrArray*">
              <type name="Connection"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="nm_wimax_nsp_get_name">
        <doc xml:space="preserve">Gets the name of the wimax NSP</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="nsp" transfer-ownership="none">
            <doc xml:space="preserve">a #NMWimaxNsp</doc>
            <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_network_type"
              c:identifier="nm_wimax_nsp_get_network_type">
        <doc xml:space="preserve">Gets the network type of the wimax NSP.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the network type</doc>
          <type name="WimaxNspNetworkType" c:type="NMWimaxNspNetworkType"/>
        </return-value>
        <parameters>
          <instance-parameter name="nsp" transfer-ownership="none">
            <doc xml:space="preserve">a #NMWimaxNsp</doc>
            <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_signal_quality"
              c:identifier="nm_wimax_nsp_get_signal_quality">
        <doc xml:space="preserve">Gets the WPA signal quality of the wimax NSP.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the signal quality</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="nsp" transfer-ownership="none">
            <doc xml:space="preserve">a #NMWimaxNsp</doc>
            <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="name" transfer-ownership="none">
        <doc xml:space="preserve">The name of the WiMAX NSP.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="network-type" transfer-ownership="none">
        <doc xml:space="preserve">The network type of the WiMAX NSP.</doc>
        <type name="WimaxNspNetworkType"/>
      </property>
      <property name="signal-quality" transfer-ownership="none">
        <doc xml:space="preserve">The signal quality of the WiMAX NSP.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Object" c:type="NMObject"/>
      </field>
    </class>
    <record name="WimaxNspClass"
            c:type="NMWimaxNspClass"
            glib:is-gtype-struct-for="WimaxNsp">
      <field name="parent">
        <type name="ObjectClass" c:type="NMObjectClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="WimaxNspNetworkType"
                 glib:type-name="NMWimaxNspNetworkType"
                 glib:get-type="nm_wimax_nsp_network_type_get_type"
                 c:type="NMWimaxNspNetworkType">
      <doc xml:space="preserve">WiMAX network type.</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_WIMAX_NSP_NETWORK_TYPE_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">unknown network type</doc>
      </member>
      <member name="home"
              value="1"
              c:identifier="NM_WIMAX_NSP_NETWORK_TYPE_HOME"
              glib:nick="home">
        <doc xml:space="preserve">home network</doc>
      </member>
      <member name="partner"
              value="2"
              c:identifier="NM_WIMAX_NSP_NETWORK_TYPE_PARTNER"
              glib:nick="partner">
        <doc xml:space="preserve">partner network</doc>
      </member>
      <member name="roaming_partner"
              value="3"
              c:identifier="NM_WIMAX_NSP_NETWORK_TYPE_ROAMING_PARTNER"
              glib:nick="roaming-partner">
        <doc xml:space="preserve">roaming partner network</doc>
      </member>
    </enumeration>
    <function name="agent_manager_error_quark"
              c:identifier="nm_agent_manager_error_quark"
              moved-to="AgentManagerError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="client_error_quark"
              c:identifier="nm_client_error_quark"
              moved-to="ClientError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMClient if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMClient errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="connection_error_quark"
              c:identifier="nm_connection_error_quark"
              moved-to="ConnectionError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="crypto_error_quark"
              c:identifier="nm_crypto_error_quark"
              moved-to="CryptoError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="device_error_quark"
              c:identifier="nm_device_error_quark"
              moved-to="DeviceError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="ip_route_attribute_validate"
              c:identifier="nm_ip_route_attribute_validate"
              moved-to="IPRoute.attribute_validate"
              version="1.8"
              throws="1">
      <doc xml:space="preserve">Validates a route attribute, i.e. checks that the attribute is a known one
and the value is of the correct type and well-formed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the attribute is valid, %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">the attribute name</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the attribute value</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
        <parameter name="family" transfer-ownership="none">
          <doc xml:space="preserve">IP address family of the route</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="known"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">on return, whether the attribute name is a known one</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="ip_route_get_variant_attribute_spec"
              c:identifier="nm_ip_route_get_variant_attribute_spec"
              moved-to="IPRoute.get_variant_attribute_spec"
              version="1.8">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the specifiers for route attributes</doc>
        <type name="VariantAttributeSpec"
              c:type="const NMVariantAttributeSpec* const*"/>
      </return-value>
    </function>
    <function name="manager_error_quark"
              c:identifier="nm_manager_error_quark"
              moved-to="ManagerError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="secret_agent_error_quark"
              c:identifier="nm_secret_agent_error_quark"
              moved-to="SecretAgentError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="settings_error_quark"
              c:identifier="nm_settings_error_quark"
              moved-to="SettingsError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="utils_ap_mode_security_valid"
              c:identifier="nm_utils_ap_mode_security_valid">
      <doc xml:space="preserve">Given a set of device capabilities, and a desired security type to check
against, determines whether the combination of device capabilities and
desired security type are valid for AP/Hotspot connections.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the device capabilities are compatible with the desired
@type, %FALSE if they are not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">the security type to check device capabilties against,
e.g. #NMU_SEC_STATIC_WEP</doc>
          <type name="UtilsSecurityType" c:type="NMUtilsSecurityType"/>
        </parameter>
        <parameter name="wifi_caps" transfer-ownership="none">
          <doc xml:space="preserve">bitfield of the capabilities of the specific Wi-Fi device, e.g.
#NM_WIFI_DEVICE_CAP_CIPHER_WEP40</doc>
          <type name="DeviceWifiCapabilities"
                c:type="NMDeviceWifiCapabilities"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_bin2hexstr" c:identifier="nm_utils_bin2hexstr">
      <doc xml:space="preserve">Converts the byte array @src into a hexadecimal string. If @final_len is
greater than -1, the returned string is terminated at that index
(returned_string[final_len] == '\0'),</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the textual form of @bytes</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="src" transfer-ownership="none">
          <doc xml:space="preserve">an array of bytes</doc>
          <array length="1" zero-terminated="0" c:type="gconstpointer">
            <type name="guint8" c:type="gconstpointer"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the length of the @src array</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="final_len" transfer-ownership="none">
          <doc xml:space="preserve">an index where to cut off the returned string, or -1</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_bond_mode_int_to_string"
              c:identifier="nm_utils_bond_mode_int_to_string"
              version="1.2">
      <doc xml:space="preserve">Convert bonding mode from integer value to descriptive name.
See https://www.kernel.org/doc/Documentation/networking/bonding.txt for
available modes.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">bonding mode string, or NULL on error</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve">bonding mode as a numeric value</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_bond_mode_string_to_int"
              c:identifier="nm_utils_bond_mode_string_to_int"
              version="1.2">
      <doc xml:space="preserve">Convert bonding mode from string representation to numeric value.
See https://www.kernel.org/doc/Documentation/networking/bonding.txt for
available modes.
The @mode string can be either a descriptive name or a number (as string).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">numeric bond mode, or -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve">bonding mode as string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_check_virtual_device_compatibility"
              c:identifier="nm_utils_check_virtual_device_compatibility">
      <doc xml:space="preserve">Determines if a connection of type @virtual_type can (in the
general case) work with connections of type @other_type.

If @virtual_type is %NM_TYPE_SETTING_VLAN, then this checks if
@other_type is a valid type for the parent of a VLAN.

If @virtual_type is a "master" type (eg, %NM_TYPE_SETTING_BRIDGE),
then this checks if @other_type is a valid type for a slave of that
master.

Note that even if this returns %TRUE it is not guaranteed that
&lt;emphasis&gt;every&lt;/emphasis&gt; connection of type @other_type is
compatible with @virtual_type; it may depend on the exact
configuration of the two connections, or on the capabilities of an
underlying device driver.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE or %FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="virtual_type" transfer-ownership="none">
          <doc xml:space="preserve">a virtual connection type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="other_type" transfer-ownership="none">
          <doc xml:space="preserve">a connection type to test against @virtual_type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_enum_from_str"
              c:identifier="nm_utils_enum_from_str"
              version="1.2">
      <doc xml:space="preserve">Converts a string to the matching enum value.

If the enum is a %G_TYPE_FLAGS the function returns the logical OR of values
matching the comma-separated tokens in the string; if an unknown token is found
the function returns %FALSE and stores a pointer to a newly allocated string
containing the unrecognized token in @err_token.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the conversion was successful, %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">the %GType of the enum</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">the input string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out_value"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">the output value</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="err_token"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">location to store the first unrecognized token</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_enum_get_values"
              c:identifier="nm_utils_enum_get_values"
              version="1.2">
      <doc xml:space="preserve">Returns the list of possible values for a given enum.</doc>
      <return-value transfer-ownership="container">
        <doc xml:space="preserve">a NULL-terminated dynamically-allocated array of static strings
or %NULL on error</doc>
        <array c:type="const char**">
          <type name="utf8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">the %GType of the enum</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="from" transfer-ownership="none">
          <doc xml:space="preserve">the first element to be returned</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="to" transfer-ownership="none">
          <doc xml:space="preserve">the last element to be returned</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_enum_to_str"
              c:identifier="nm_utils_enum_to_str"
              version="1.2">
      <doc xml:space="preserve">Converts an enum value to its string representation. If the enum is a
%G_TYPE_FLAGS the function returns a comma-separated list of matching values.
If the enum is a %G_TYPE_ENUM and the given value is not valid the
function returns %NULL.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated string or %NULL</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">the %GType of the enum</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the value to be translated</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_escape_ssid" c:identifier="nm_utils_escape_ssid">
      <doc xml:space="preserve">This function does a quick printable character conversion of the SSID, simply
replacing embedded NULLs and non-printable characters with the hexadecimal
representation of that character.  Intended for debugging only, should not
be used for display of SSIDs.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">pointer to the escaped SSID, which uses an internal static buffer
and will be overwritten by subsequent calls to this function</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="ssid" transfer-ownership="none">
          <doc xml:space="preserve">pointer to a buffer containing the SSID data</doc>
          <array length="1" zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">length of the SSID data in @ssid</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_file_is_certificate"
              c:identifier="nm_utils_file_is_certificate">
      <doc xml:space="preserve">Tests if @filename has a valid extension for an X.509 certificate file
(".cer", ".crt", ".der", or ".pem"), and contains a certificate in a format
recognized by NetworkManager.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the file is a certificate, %FALSE if it is not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">name of the file to test</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_file_is_pkcs12"
              c:identifier="nm_utils_file_is_pkcs12">
      <doc xml:space="preserve">Tests if @filename is a PKCS#&lt;!-- --&gt;12 file.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the file is PKCS#&lt;!-- --&gt;12, %FALSE if it is not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">name of the file to test</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_file_is_private_key"
              c:identifier="nm_utils_file_is_private_key">
      <doc xml:space="preserve">Tests if @filename has a valid extension for an X.509 private key file
(".der", ".key", ".pem", or ".p12"), and contains a private key in a format
recognized by NetworkManager.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the file is a private key, %FALSE if it is not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">name of the file to test</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out_encrypted"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">on return, whether the file is encrypted</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_file_search_in_paths"
              c:identifier="nm_utils_file_search_in_paths"
              throws="1">
      <doc xml:space="preserve">Searches for a @progname file in a list of search @paths.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the full path to the helper, if found, or %NULL if not found.
  The returned string is not owned by the caller, but later
  invocations of the function might overwrite it.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="progname" transfer-ownership="none">
          <doc xml:space="preserve">the helper program name, like "iptables"
  Must be a non-empty string, without path separator (/).</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="try_first"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a custom path to try first before searching.
  It is silently ignored if it is empty or not an absolute path.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="paths"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a %NULL terminated list of search paths.
  Can be empty or %NULL, in which case only @try_first is checked.</doc>
          <type name="utf8" c:type="const char* const*"/>
        </parameter>
        <parameter name="file_test_flags" transfer-ownership="none">
          <doc xml:space="preserve">the flags passed to g_file_test() when searching
  for @progname. Set it to 0 to skip the g_file_test().</doc>
          <type name="GLib.FileTest" c:type="GFileTest"/>
        </parameter>
        <parameter name="predicate"
                   transfer-ownership="none"
                   scope="call"
                   closure="5">
          <doc xml:space="preserve">if given, pass the file name to this function
  for additional checks. This check is performed after the check for
  @file_test_flags. You cannot omit both @file_test_flags and @predicate.</doc>
          <type name="UtilsFileSearchInPathsPredicate"
                c:type="NMUtilsFileSearchInPathsPredicate"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">(allow-none): user data for @predicate function.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_format_variant_attributes"
              c:identifier="nm_utils_format_variant_attributes">
      <return-value transfer-ownership="full">
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="attributes" transfer-ownership="none">
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="attr_separator" transfer-ownership="none">
          <type name="gchar" c:type="char"/>
        </parameter>
        <parameter name="key_value_separator" transfer-ownership="none">
          <type name="gchar" c:type="char"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_hexstr2bin" c:identifier="nm_utils_hexstr2bin">
      <doc xml:space="preserve">Converts a hexadecimal string @hex into an array of bytes.  The optional
separator ':' may be used between single or pairs of hexadecimal characters,
eg "00:11" or "0:1".  Any "0x" at the beginning of @hex is ignored.  @hex
may not start or end with ':'.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the converted bytes, or %NULL on error</doc>
        <type name="GLib.Bytes" c:type="GBytes*"/>
      </return-value>
      <parameters>
        <parameter name="hex" transfer-ownership="none">
          <doc xml:space="preserve">a string of hexadecimal characters with optional ':' separators</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_hwaddr_atoba" c:identifier="nm_utils_hwaddr_atoba">
      <doc xml:space="preserve">Parses @asc and converts it to binary form in a #GByteArray. See
nm_utils_hwaddr_aton() if you don't want a #GByteArray.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new #GByteArray, or %NULL if @asc couldn't
be parsed</doc>
        <array name="GLib.ByteArray" c:type="GByteArray*">
          <type name="guint8" c:type="guint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="asc" transfer-ownership="none">
          <doc xml:space="preserve">the ASCII representation of a hardware address</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the expected length in bytes of the result</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_hwaddr_aton" c:identifier="nm_utils_hwaddr_aton">
      <doc xml:space="preserve">Parses @asc and converts it to binary form in @buffer.
Bytes in @asc can be sepatared by colons (:), or hyphens (-), but not mixed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">@buffer, or %NULL if @asc couldn't be parsed
  or would be shorter or longer than @length.</doc>
        <type name="guint8" c:type="guint8*"/>
      </return-value>
      <parameters>
        <parameter name="asc" transfer-ownership="none">
          <doc xml:space="preserve">the ASCII representation of a hardware address</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="buffer"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">buffer to store the result into</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the expected length in bytes of the result and
the size of the buffer in bytes.</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_hwaddr_canonical"
              c:identifier="nm_utils_hwaddr_canonical">
      <doc xml:space="preserve">Parses @asc to see if it is a valid hardware address of the given
length, and if so, returns it in canonical form (uppercase, with
leading 0s as needed, and with colons rather than hyphens).</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the canonicalized address if @asc appears to
  be a valid hardware address of the indicated length, %NULL if not.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="asc" transfer-ownership="none">
          <doc xml:space="preserve">the ASCII representation of a hardware address</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the length of address that @asc is expected to convert to
  (or -1 to accept any length up to %NM_UTILS_HWADDR_LEN_MAX)</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_hwaddr_len" c:identifier="nm_utils_hwaddr_len">
      <doc xml:space="preserve">Returns the length in octets of a hardware address of type @type.

It is an error to call this function with any value other than
&lt;literal&gt;ARPHRD_ETHER&lt;/literal&gt; or &lt;literal&gt;ARPHRD_INFINIBAND&lt;/literal&gt;.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the length.</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">the type of address; either &lt;literal&gt;ARPHRD_ETHER&lt;/literal&gt; or
&lt;literal&gt;ARPHRD_INFINIBAND&lt;/literal&gt;</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_hwaddr_matches"
              c:identifier="nm_utils_hwaddr_matches">
      <doc xml:space="preserve">Generalized hardware address comparison function. Tests if @hwaddr1 and
@hwaddr2 "equal" (or more precisely, "equivalent"), with several advantages
over a simple memcmp():

  1. If @hwaddr1_len or @hwaddr2_len is -1, then the corresponding address is
     assumed to be ASCII rather than binary, and will be converted to binary
     before being compared.

  2. If @hwaddr1 or @hwaddr2 is %NULL, it is treated instead as though it was
     a zero-filled buffer @hwaddr1_len or @hwaddr2_len bytes long.

  3. If @hwaddr1 and @hwaddr2 are InfiniBand hardware addresses (that is, if
     they are &lt;literal&gt;INFINIBAND_ALEN&lt;/literal&gt; bytes long in binary form)
     then only the last 8 bytes are compared, since those are the only bytes
     that actually identify the hardware. (The other 12 bytes will change
     depending on the configuration of the InfiniBand fabric that the device
     is connected to.)

If a passed-in ASCII hardware address cannot be parsed, or would parse to an
address larger than %NM_UTILS_HWADDR_LEN_MAX, then it will silently fail to
match. (This means that externally-provided address strings do not need to be
sanity-checked before comparing them against known good addresses; they are
guaranteed to not match if they are invalid.)</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @hwaddr1 and @hwaddr2 are equivalent, %FALSE if they are
  different (or either of them is invalid).</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="hwaddr1"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">pointer to a binary or ASCII hardware address, or %NULL</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="hwaddr1_len" transfer-ownership="none">
          <doc xml:space="preserve">size of @hwaddr1, or -1 if @hwaddr1 is ASCII</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
        <parameter name="hwaddr2"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">pointer to a binary or ASCII hardware address, or %NULL</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="hwaddr2_len" transfer-ownership="none">
          <doc xml:space="preserve">size of @hwaddr2, or -1 if @hwaddr2 is ASCII</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_hwaddr_ntoa" c:identifier="nm_utils_hwaddr_ntoa">
      <doc xml:space="preserve">Converts @addr to textual form.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the textual form of @addr</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="addr" transfer-ownership="none">
          <doc xml:space="preserve">a binary hardware address</doc>
          <array length="1" zero-terminated="0" c:type="gconstpointer">
            <type name="guint8" c:type="gconstpointer"/>
          </array>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the length of @addr</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_hwaddr_valid" c:identifier="nm_utils_hwaddr_valid">
      <doc xml:space="preserve">Parses @asc to see if it is a valid hardware address of the given
length.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @asc appears to be a valid hardware address
  of the indicated length, %FALSE if not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="asc" transfer-ownership="none">
          <doc xml:space="preserve">the ASCII representation of a hardware address</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the length of address that @asc is expected to convert to
  (or -1 to accept any length up to %NM_UTILS_HWADDR_LEN_MAX)</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_iface_valid_name"
              c:identifier="nm_utils_iface_valid_name"
              deprecated="1"
              deprecated-version="1.6">
      <doc xml:space="preserve">Validate the network interface name.</doc>
      <doc-deprecated xml:space="preserve">use nm_utils_is_valid_iface_name() instead, with better error reporting.</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if interface name is valid, otherwise %FALSE is returned.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">Name of interface</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_inet4_ntop"
              c:identifier="nm_utils_inet4_ntop"
              introspectable="0">
      <doc xml:space="preserve">Wrapper for inet_ntop.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the input buffer @dst, or a pointer to an
 internal, static buffer. This function cannot fail.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="inaddr" transfer-ownership="none">
          <doc xml:space="preserve">the address that should be converted to string.</doc>
          <type c:type="in_addr_t"/>
        </parameter>
        <parameter name="dst" transfer-ownership="none">
          <doc xml:space="preserve">the destination buffer, it must contain at least
 &lt;literal&gt;INET_ADDRSTRLEN&lt;/literal&gt; or %NM_UTILS_INET_ADDRSTRLEN
 characters. If set to %NULL, it will return a pointer to an internal, static
 buffer (shared with nm_utils_inet6_ntop()).  Beware, that the internal
 buffer will be overwritten with ever new call of nm_utils_inet4_ntop() or
 nm_utils_inet6_ntop() that does not provied it's own @dst buffer. Also,
 using the internal buffer is not thread safe. When in doubt, pass your own
 @dst buffer to avoid these issues.</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_inet6_ntop"
              c:identifier="nm_utils_inet6_ntop"
              introspectable="0">
      <doc xml:space="preserve">Wrapper for inet_ntop.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the input buffer @dst, or a pointer to an
 internal, static buffer. %NULL is not allowed as @in6addr,
 otherwise, this function cannot fail.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="in6addr"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">the address that should be converted to string.</doc>
          <type name="gpointer" c:type="const in6_addr*"/>
        </parameter>
        <parameter name="dst" transfer-ownership="none">
          <doc xml:space="preserve">the destination buffer, it must contain at least
 &lt;literal&gt;INET6_ADDRSTRLEN&lt;/literal&gt; or %NM_UTILS_INET_ADDRSTRLEN
 characters. If set to %NULL, it will return a pointer to an internal, static
 buffer (shared with nm_utils_inet4_ntop()).  Beware, that the internal
 buffer will be overwritten with ever new call of nm_utils_inet4_ntop() or
 nm_utils_inet6_ntop() that does not provied it's own @dst buffer. Also,
 using the internal buffer is not thread safe. When in doubt, pass your own
 @dst buffer to avoid these issues.</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip4_addresses_from_variant"
              c:identifier="nm_utils_ip4_addresses_from_variant">
      <doc xml:space="preserve">Utility function to convert a #GVariant of type 'aau' representing a list of
NetworkManager IPv4 addresses (which are tuples of address, prefix, and
gateway) into a #GPtrArray of #NMIPAddress objects. The "gateway" field of
the first address (if set) will be returned in @out_gateway; the "gateway" fields
of the other addresses are ignored.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated
  #GPtrArray of #NMIPAddress objects</doc>
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="IPAddress"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a #GVariant of type 'aau'</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
        <parameter name="out_gateway"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">on return, will contain the IP gateway</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip4_addresses_to_variant"
              c:identifier="nm_utils_ip4_addresses_to_variant">
      <doc xml:space="preserve">Utility function to convert a #GPtrArray of #NMIPAddress objects representing
IPv4 addresses into a #GVariant of type 'aau' representing an array of
NetworkManager IPv4 addresses (which are tuples of address, prefix, and
gateway). The "gateway" field of the first address will get the value of
@gateway (if non-%NULL). In all of the other addresses, that field will be 0.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a new floating #GVariant representing @addresses.</doc>
        <type name="GLib.Variant" c:type="GVariant*"/>
      </return-value>
      <parameters>
        <parameter name="addresses" transfer-ownership="none">
          <doc xml:space="preserve">an array of #NMIPAddress objects</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="IPAddress"/>
          </array>
        </parameter>
        <parameter name="gateway"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">the gateway IP address</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip4_dns_from_variant"
              c:identifier="nm_utils_ip4_dns_from_variant">
      <doc xml:space="preserve">Utility function to convert a #GVariant of type 'au' representing a list of
IPv4 addresses into an array of IP address strings.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a %NULL-terminated array of IP address strings.</doc>
        <type name="utf8" c:type="char**"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a #GVariant of type 'au'</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip4_dns_to_variant"
              c:identifier="nm_utils_ip4_dns_to_variant">
      <doc xml:space="preserve">Utility function to convert an array of IP address strings int a #GVariant of
type 'au' representing an array of IPv4 addresses.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a new floating #GVariant representing @dns.</doc>
        <type name="GLib.Variant" c:type="GVariant*"/>
      </return-value>
      <parameters>
        <parameter name="dns" transfer-ownership="none">
          <doc xml:space="preserve">an array of IP address strings</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip4_get_default_prefix"
              c:identifier="nm_utils_ip4_get_default_prefix">
      <doc xml:space="preserve">When the Internet was originally set up, various ranges of IP addresses were
segmented into three network classes: A, B, and C.  This function will return
a prefix that is associated with the IP address specified defining where it
falls in the predefined classes.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the default class prefix for the given IP</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="ip" transfer-ownership="none">
          <doc xml:space="preserve">an IPv4 address (in network byte order)</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip4_netmask_to_prefix"
              c:identifier="nm_utils_ip4_netmask_to_prefix">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the CIDR prefix represented by the netmask</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="netmask" transfer-ownership="none">
          <doc xml:space="preserve">an IPv4 netmask in network byte order</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip4_prefix_to_netmask"
              c:identifier="nm_utils_ip4_prefix_to_netmask">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the netmask represented by the prefix, in network byte order</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="prefix" transfer-ownership="none">
          <doc xml:space="preserve">a CIDR prefix</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip4_routes_from_variant"
              c:identifier="nm_utils_ip4_routes_from_variant">
      <doc xml:space="preserve">Utility function to convert a #GVariant of type 'aau' representing an array
of NetworkManager IPv4 routes (which are tuples of route, prefix, next hop,
and metric) into a #GPtrArray of #NMIPRoute objects.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated
  #GPtrArray of #NMIPRoute objects</doc>
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="IPRoute"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">#GVariant of type 'aau'</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip4_routes_to_variant"
              c:identifier="nm_utils_ip4_routes_to_variant">
      <doc xml:space="preserve">Utility function to convert a #GPtrArray of #NMIPRoute objects representing
IPv4 routes into a #GVariant of type 'aau' representing an array of
NetworkManager IPv4 routes (which are tuples of route, prefix, next hop, and
metric).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a new floating #GVariant representing @routes.</doc>
        <type name="GLib.Variant" c:type="GVariant*"/>
      </return-value>
      <parameters>
        <parameter name="routes" transfer-ownership="none">
          <doc xml:space="preserve">an array of #NMIP4Route objects</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="IPRoute"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip6_addresses_from_variant"
              c:identifier="nm_utils_ip6_addresses_from_variant">
      <doc xml:space="preserve">Utility function to convert a #GVariant of type 'a(ayuay)' representing a
list of NetworkManager IPv6 addresses (which are tuples of address, prefix,
and gateway) into a #GPtrArray of #NMIPAddress objects. The "gateway" field
of the first address (if set) will be returned in @out_gateway; the "gateway"
fields of the other addresses are ignored.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated
  #GPtrArray of #NMIPAddress objects</doc>
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="IPAddress"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a #GVariant of type 'a(ayuay)'</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
        <parameter name="out_gateway"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">on return, will contain the IP gateway</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip6_addresses_to_variant"
              c:identifier="nm_utils_ip6_addresses_to_variant">
      <doc xml:space="preserve">Utility function to convert a #GPtrArray of #NMIPAddress objects representing
IPv6 addresses into a #GVariant of type 'a(ayuay)' representing an array of
NetworkManager IPv6 addresses (which are tuples of address, prefix, and
gateway).  The "gateway" field of the first address will get the value of
@gateway (if non-%NULL). In all of the other addresses, that field will be
all 0s.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a new floating #GVariant representing @addresses.</doc>
        <type name="GLib.Variant" c:type="GVariant*"/>
      </return-value>
      <parameters>
        <parameter name="addresses" transfer-ownership="none">
          <doc xml:space="preserve">an array of #NMIPAddress objects</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="IPAddress"/>
          </array>
        </parameter>
        <parameter name="gateway"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">the gateway IP address</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip6_dns_from_variant"
              c:identifier="nm_utils_ip6_dns_from_variant">
      <doc xml:space="preserve">Utility function to convert a #GVariant of type 'aay' representing a list of
IPv6 addresses into an array of IP address strings.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a %NULL-terminated array of IP address strings.</doc>
        <type name="utf8" c:type="char**"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a #GVariant of type 'aay'</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip6_dns_to_variant"
              c:identifier="nm_utils_ip6_dns_to_variant">
      <doc xml:space="preserve">Utility function to convert an array of IP address strings int a #GVariant of
type 'aay' representing an array of IPv6 addresses.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a new floating #GVariant representing @dns.</doc>
        <type name="GLib.Variant" c:type="GVariant*"/>
      </return-value>
      <parameters>
        <parameter name="dns" transfer-ownership="none">
          <doc xml:space="preserve">an array of IP address strings</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip6_routes_from_variant"
              c:identifier="nm_utils_ip6_routes_from_variant">
      <doc xml:space="preserve">Utility function to convert a #GVariant of type 'a(ayuayu)' representing an
array of NetworkManager IPv6 routes (which are tuples of route, prefix, next
hop, and metric) into a #GPtrArray of #NMIPRoute objects.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated
  #GPtrArray of #NMIPRoute objects</doc>
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="IPRoute"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">#GVariant of type 'a(ayuayu)'</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip6_routes_to_variant"
              c:identifier="nm_utils_ip6_routes_to_variant">
      <doc xml:space="preserve">Utility function to convert a #GPtrArray of #NMIPRoute objects representing
IPv6 routes into a #GVariant of type 'a(ayuayu)' representing an array of
NetworkManager IPv6 routes (which are tuples of route, prefix, next hop, and
metric).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a new floating #GVariant representing @routes.</doc>
        <type name="GLib.Variant" c:type="GVariant*"/>
      </return-value>
      <parameters>
        <parameter name="routes" transfer-ownership="none">
          <doc xml:space="preserve">an array of #NMIPRoute objects</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="IPRoute"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip_addresses_from_variant"
              c:identifier="nm_utils_ip_addresses_from_variant">
      <doc xml:space="preserve">Utility function to convert a #GVariant representing a list of new-style
NetworkManager IPv4 or IPv6 addresses (as described in the documentation for
nm_utils_ip_addresses_to_variant()) into a #GPtrArray of #NMIPAddress
objects.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated
  #GPtrArray of #NMIPAddress objects</doc>
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="IPAddress"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a #GVariant of type 'aa{sv}'</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
        <parameter name="family" transfer-ownership="none">
          <doc xml:space="preserve">an IP address family</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip_addresses_to_variant"
              c:identifier="nm_utils_ip_addresses_to_variant">
      <doc xml:space="preserve">Utility function to convert a #GPtrArray of #NMIPAddress objects representing
IPv4 or IPv6 addresses into a #GVariant of type 'aa{sv}' representing an
array of new-style NetworkManager IP addresses. All addresses will include
"address" (an IP address string), and "prefix" (a uint). Some addresses may
include additional attributes.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a new floating #GVariant representing @addresses.</doc>
        <type name="GLib.Variant" c:type="GVariant*"/>
      </return-value>
      <parameters>
        <parameter name="addresses" transfer-ownership="none">
          <doc xml:space="preserve">an array of #NMIPAddress objects</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="IPAddress"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip_routes_from_variant"
              c:identifier="nm_utils_ip_routes_from_variant">
      <doc xml:space="preserve">Utility function to convert a #GVariant representing a list of new-style
NetworkManager IPv4 or IPv6 addresses (which are tuples of destination,
prefix, next hop, metric, and additional attributes) into a #GPtrArray of
#NMIPRoute objects.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated
  #GPtrArray of #NMIPRoute objects</doc>
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="IPRoute"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a #GVariant of type 'aa{sv}'</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
        <parameter name="family" transfer-ownership="none">
          <doc xml:space="preserve">an IP address family</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip_routes_to_variant"
              c:identifier="nm_utils_ip_routes_to_variant">
      <doc xml:space="preserve">Utility function to convert a #GPtrArray of #NMIPRoute objects representing
IPv4 or IPv6 routes into a #GVariant of type 'aa{sv}' representing an array
of new-style NetworkManager IP routes (which are tuples of destination,
prefix, next hop, metric, and additional attributes).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a new floating #GVariant representing @routes.</doc>
        <type name="GLib.Variant" c:type="GVariant*"/>
      </return-value>
      <parameters>
        <parameter name="routes" transfer-ownership="none">
          <doc xml:space="preserve">an array of #NMIPRoute objects</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="IPRoute"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ipaddr_valid" c:identifier="nm_utils_ipaddr_valid">
      <doc xml:space="preserve">Checks if @ip contains a valid IP address of the given family.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE or %FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="family" transfer-ownership="none">
          <doc xml:space="preserve">&lt;literal&gt;AF_INET&lt;/literal&gt; or &lt;literal&gt;AF_INET6&lt;/literal&gt;, or
  &lt;literal&gt;AF_UNSPEC&lt;/literal&gt; to accept either</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="ip" transfer-ownership="none">
          <doc xml:space="preserve">an IP address</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_is_empty_ssid" c:identifier="nm_utils_is_empty_ssid">
      <doc xml:space="preserve">Different manufacturers use different mechanisms for not broadcasting the
AP's SSID.  This function attempts to detect blank/empty SSIDs using a
number of known SSID-cloaking methods.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the SSID is "empty", %FALSE if it is not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="ssid" transfer-ownership="none">
          <doc xml:space="preserve">pointer to a buffer containing the SSID data</doc>
          <array length="1" zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">length of the SSID data in @ssid</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_is_json_object"
              c:identifier="nm_utils_is_json_object"
              version="1.6"
              throws="1">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether the passed string is valid JSON.
  If libnm is not compiled with libjansson support, this check will
  also return %TRUE for possibly invalid inputs. If that is a problem
  for you, you must validate the JSON yourself.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">the JSON string to test</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_is_uuid" c:identifier="nm_utils_is_uuid">
      <doc xml:space="preserve">Checks if @str is a UUID</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @str is a UUID, %FALSE if not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a string that might be a UUID</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_is_valid_iface_name"
              c:identifier="nm_utils_is_valid_iface_name"
              throws="1">
      <doc xml:space="preserve">Validate the network interface name.

This function is a 1:1 copy of the kernel's interface validation
function in net/core/dev.c.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if interface name is valid, otherwise %FALSE is returned.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">Name of interface</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_parse_variant_attributes"
              c:identifier="nm_utils_parse_variant_attributes"
              version="1.8"
              throws="1">
      <doc xml:space="preserve">Parse attributes from a string.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #GHashTable mapping attribute names to #GVariant values.</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">the input string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="attr_separator" transfer-ownership="none">
          <doc xml:space="preserve">the attribute separator character</doc>
          <type name="gchar" c:type="char"/>
        </parameter>
        <parameter name="key_value_separator" transfer-ownership="none">
          <doc xml:space="preserve">character separating key and values</doc>
          <type name="gchar" c:type="char"/>
        </parameter>
        <parameter name="ignore_unknown" transfer-ownership="none">
          <doc xml:space="preserve">whether unknown attributes should be ignored</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="spec" transfer-ownership="none">
          <doc xml:space="preserve">the attribute format specifiers</doc>
          <type name="VariantAttributeSpec"
                c:type="const NMVariantAttributeSpec* const*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_same_ssid" c:identifier="nm_utils_same_ssid">
      <doc xml:space="preserve">Earlier versions of the Linux kernel added a NULL byte to the end of the
SSID to enable easy printing of the SSID on the console or in a terminal,
but this behavior was problematic (SSIDs are simply byte arrays, not strings)
and thus was changed.  This function compensates for that behavior at the
cost of some compatibility with odd SSIDs that may legitimately have trailing
NULLs, even though that is functionally pointless.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the SSIDs are the same, %FALSE if they are not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="ssid1" transfer-ownership="none">
          <doc xml:space="preserve">the first SSID to compare</doc>
          <array length="1" zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="len1" transfer-ownership="none">
          <doc xml:space="preserve">length of the SSID data in @ssid1</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="ssid2" transfer-ownership="none">
          <doc xml:space="preserve">the second SSID to compare</doc>
          <array length="3" zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="len2" transfer-ownership="none">
          <doc xml:space="preserve">length of the SSID data in @ssid2</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="ignore_trailing_null" transfer-ownership="none">
          <doc xml:space="preserve">%TRUE to ignore one trailing NULL byte</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_security_valid"
              c:identifier="nm_utils_security_valid">
      <doc xml:space="preserve">Given a set of device capabilities, and a desired security type to check
against, determines whether the combination of device, desired security
type, and AP capabilities intersect.

NOTE: this function cannot handle checking security for AP/Hotspot mode;
use nm_utils_ap_mode_security_valid() instead.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the device capabilities and AP capabilties intersect and are
compatible with the desired @type, %FALSE if they are not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">the security type to check AP flags and device capabilties against,
e.g. #NMU_SEC_STATIC_WEP</doc>
          <type name="UtilsSecurityType" c:type="NMUtilsSecurityType"/>
        </parameter>
        <parameter name="wifi_caps" transfer-ownership="none">
          <doc xml:space="preserve">bitfield of the capabilities of the specific Wi-Fi device, e.g.
#NM_WIFI_DEVICE_CAP_CIPHER_WEP40</doc>
          <type name="DeviceWifiCapabilities"
                c:type="NMDeviceWifiCapabilities"/>
        </parameter>
        <parameter name="have_ap" transfer-ownership="none">
          <doc xml:space="preserve">whether the @ap_flags, @ap_wpa, and @ap_rsn arguments are valid</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="adhoc" transfer-ownership="none">
          <doc xml:space="preserve">whether the capabilities being tested are from an Ad-Hoc AP (IBSS)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="ap_flags" transfer-ownership="none">
          <doc xml:space="preserve">bitfield of AP capabilities, e.g. #NM_802_11_AP_FLAGS_PRIVACY</doc>
          <type name="80211ApFlags" c:type="NM80211ApFlags"/>
        </parameter>
        <parameter name="ap_wpa" transfer-ownership="none">
          <doc xml:space="preserve">bitfield of AP capabilties derived from the AP's WPA beacon,
e.g. (#NM_802_11_AP_SEC_PAIR_TKIP | #NM_802_11_AP_SEC_KEY_MGMT_PSK)</doc>
          <type name="80211ApSecurityFlags" c:type="NM80211ApSecurityFlags"/>
        </parameter>
        <parameter name="ap_rsn" transfer-ownership="none">
          <doc xml:space="preserve">bitfield of AP capabilties derived from the AP's RSN/WPA2 beacon,
e.g. (#NM_802_11_AP_SEC_PAIR_CCMP | #NM_802_11_AP_SEC_PAIR_TKIP)</doc>
          <type name="80211ApSecurityFlags" c:type="NM80211ApSecurityFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ssid_to_utf8" c:identifier="nm_utils_ssid_to_utf8">
      <doc xml:space="preserve">Wi-Fi SSIDs are byte arrays, they are _not_ strings.  Thus, an SSID may
contain embedded NULLs and other unprintable characters.  Often it is
useful to print the SSID out for debugging purposes, but that should be the
_only_ use of this function.  Do not use this function for any persistent
storage of the SSID, since the printable SSID returned from this function
cannot be converted back into the real SSID of the access point.

This function does almost everything humanly possible to convert the input
into a printable UTF-8 string, using roughly the following procedure:

1) if the input data is already UTF-8 safe, no conversion is performed
2) attempts to get the current system language from the LANG environment
   variable, and depending on the language, uses a table of alternative
   encodings to try.  For example, if LANG=hu_HU, the table may first try
   the ISO-8859-2 encoding, and if that fails, try the Windows-1250 encoding.
   If all fallback encodings fail, replaces non-UTF-8 characters with '?'.
3) If the system language was unable to be determined, falls back to the
   ISO-8859-1 encoding, then to the Windows-1251 encoding.
4) If step 3 fails, replaces non-UTF-8 characters with '?'.

Again, this function should be used for debugging and display purposes
_only_.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">an allocated string containing a UTF-8
representation of the SSID, which must be freed by the caller using g_free().
Returns %NULL on errors.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="ssid" transfer-ownership="none">
          <doc xml:space="preserve">pointer to a buffer containing the SSID data</doc>
          <array length="1" zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">length of the SSID data in @ssid</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_uuid_generate" c:identifier="nm_utils_uuid_generate">
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated UUID suitable for use as the #NMSettingConnection
object's #NMSettingConnection:id: property.  Should be freed with g_free()</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
    </function>
    <function name="utils_version"
              c:identifier="nm_utils_version"
              version="1.6.0">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the version ID of the libnm version. That is, the %NM_VERSION
  at runtime.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
    </function>
    <function name="utils_wep_key_valid" c:identifier="nm_utils_wep_key_valid">
      <doc xml:space="preserve">Checks if @key is a valid WEP key</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @key is a WEP key, %FALSE if not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">a string that might be a WEP key</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="wep_type" transfer-ownership="none">
          <doc xml:space="preserve">the #NMWepKeyType type of the WEP key</doc>
          <type name="WepKeyType" c:type="NMWepKeyType"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_wifi_2ghz_freqs"
              c:identifier="nm_utils_wifi_2ghz_freqs"
              version="1.2">
      <doc xml:space="preserve">Utility function to return 2.4 GHz Wi-Fi frequencies (802.11bg band).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">zero-terminated array of frequencies numbers (in MHz)</doc>
        <type name="guint" c:type="const guint*"/>
      </return-value>
    </function>
    <function name="utils_wifi_5ghz_freqs"
              c:identifier="nm_utils_wifi_5ghz_freqs"
              version="1.2">
      <doc xml:space="preserve">Utility function to return 5 GHz Wi-Fi frequencies (802.11a band).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">zero-terminated array of frequencies numbers (in MHz)</doc>
        <type name="guint" c:type="const guint*"/>
      </return-value>
    </function>
    <function name="utils_wifi_channel_to_freq"
              c:identifier="nm_utils_wifi_channel_to_freq">
      <doc xml:space="preserve">Utility function to translate a Wi-Fi channel to its corresponding frequency.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the frequency represented by the channel of the band,
         or -1 when the freq is invalid, or 0 when the band
         is invalid</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="channel" transfer-ownership="none">
          <doc xml:space="preserve">channel</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
        <parameter name="band" transfer-ownership="none">
          <doc xml:space="preserve">frequency band for wireless ("a" or "bg")</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_wifi_find_next_channel"
              c:identifier="nm_utils_wifi_find_next_channel">
      <doc xml:space="preserve">Utility function to find out next/previous Wi-Fi channel for a channel.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the next channel in the specified direction or 0</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="channel" transfer-ownership="none">
          <doc xml:space="preserve">current channel</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
        <parameter name="direction" transfer-ownership="none">
          <doc xml:space="preserve">whether going downward (0 or less) or upward (1 or more)</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="band" transfer-ownership="none">
          <doc xml:space="preserve">frequency band for wireless ("a" or "bg")</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_wifi_freq_to_channel"
              c:identifier="nm_utils_wifi_freq_to_channel">
      <doc xml:space="preserve">Utility function to translate a Wi-Fi frequency to its corresponding channel.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the channel represented by the frequency or 0</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="freq" transfer-ownership="none">
          <doc xml:space="preserve">frequency</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_wifi_is_channel_valid"
              c:identifier="nm_utils_wifi_is_channel_valid">
      <doc xml:space="preserve">Utility function to verify Wi-Fi channel validity.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE or %FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="channel" transfer-ownership="none">
          <doc xml:space="preserve">channel</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
        <parameter name="band" transfer-ownership="none">
          <doc xml:space="preserve">frequency band for wireless ("a" or "bg")</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_wifi_strength_bars"
              c:identifier="nm_utils_wifi_strength_bars">
      <doc xml:space="preserve">Converts @strength into a 4-character-wide graphical representation of
strength suitable for printing to stdout. If the current locale and terminal
support it, this will use unicode graphics characters to represent
"bars". Otherwise it will use 0 to 4 asterisks.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the graphical representation of the access point strength</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="strength" transfer-ownership="none">
          <doc xml:space="preserve">the access point strength, from 0 to 100</doc>
          <type name="guint8" c:type="guint8"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_wpa_psk_valid" c:identifier="nm_utils_wpa_psk_valid">
      <doc xml:space="preserve">Checks if @psk is a valid WPA PSK</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @psk is a WPA PSK, %FALSE if not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="psk" transfer-ownership="none">
          <doc xml:space="preserve">a string that might be a WPA PSK</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vpn_editor_plugin_load"
              c:identifier="nm_vpn_editor_plugin_load"
              moved-to="VpnEditorPlugin.load"
              version="1.4"
              throws="1">
      <doc xml:space="preserve">Load the shared libary @plugin_name and create a new
#NMVpnEditorPlugin instace via the #NMVpnEditorPluginFactory
function.

This is similar to nm_vpn_editor_plugin_load_from_file(), but
it does no validation of the plugin name, instead passes it directly
to dlopen(). If you have the full path to a plugin file,
nm_vpn_editor_plugin_load_from_file() is preferred.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new plugin instance or %NULL on error.</doc>
        <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
      </return-value>
      <parameters>
        <parameter name="plugin_name" transfer-ownership="none">
          <doc xml:space="preserve">The name of the shared library to load.
 This path will be directly passed to dlopen() without
 further checks.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="check_service" transfer-ownership="none">
          <doc xml:space="preserve">if not-null, check that the loaded plugin advertises
 the given service.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vpn_editor_plugin_load_from_file"
              c:identifier="nm_vpn_editor_plugin_load_from_file"
              moved-to="VpnEditorPlugin.load_from_file"
              version="1.2"
              throws="1">
      <doc xml:space="preserve">Load the shared libary @plugin_name and create a new
#NMVpnEditorPlugin instace via the #NMVpnEditorPluginFactory
function.

If @plugin_name is not an absolute path name, it assumes the file
is in the plugin directory of NetworkManager. In any case, the call
will do certain checks on the file before passing it to dlopen.
A consequence for that is, that you cannot omit the ".so" suffix
as you could for nm_vpn_editor_plugin_load().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new plugin instance or %NULL on error.</doc>
        <type name="VpnEditorPlugin" c:type="NMVpnEditorPlugin*"/>
      </return-value>
      <parameters>
        <parameter name="plugin_name" transfer-ownership="none">
          <doc xml:space="preserve">The path or name of the shared library to load.
 The path must either be an absolute filename to an existing file.
 Alternatively, it can be the name (without path) of a library in the
 plugin directory of NetworkManager.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="check_service" transfer-ownership="none">
          <doc xml:space="preserve">if not-null, check that the loaded plugin advertises
 the given service.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="check_owner" transfer-ownership="none">
          <doc xml:space="preserve">if non-negative, check whether the file is owned
 by UID @check_owner or by root. In this case also check that
 the file is not writable by anybody else.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="check_file"
                   transfer-ownership="none"
                   scope="call"
                   closure="4">
          <doc xml:space="preserve">optional callback to validate the file prior to
  loading the shared library.</doc>
          <type name="UtilsCheckFilePredicate"
                c:type="NMUtilsCheckFilePredicate"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">user data for @check_file</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="vpn_plugin_error_quark"
              c:identifier="nm_vpn_plugin_error_quark"
              moved-to="VpnPluginError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
  </namespace>
</repository>
